I have the following description of Python tool and its Design Plan, for a BUC Spur optimizer tool (This is not a SaaS product, it is for my personal usage only). I have started development of this tool. Your task is to review the current state of the tool for correctness against the specs and overall.

TOOL SPECS / DESCRIPTION:

---

## System context: RF Block-Up-Converter (BUC)

**Targets (for context; out of scope unless noted):**

* RF output band: **27.5–31.0 GHz**
* Instantaneous bandwidth: **≥ 400 MHz**
* System EIRP target: **50–61 dBW** assuming +25 dB beamformer (Analog Devices) and 35 dBi antenna → **BUC out: +20 to +31 dBm** (−10 to +1 dBW)
* Gain flatness (p-p): **≤ 0.2/0.4/0.8/2.0 dB** over **50/250/400 MHz/full band**
* Group-delay ripple (p-p): **≤ 1/2.5/4 ns** over **100/250/400 MHz** spans
* Phase noise: exceeds **IESS-308/309** by ≥ **5 dB** except **−60 dBc/Hz @ 100 Hz**
* Spurs: **≤ −60 dBc** (in-band and out-of-band)
* **ACLR & regrowth: TS 38.101-05 (REL-18), section 9.5.2.3 and 10.5** *(kept verbatim; still out of scope)*
* Port return loss: **≥ 15 dB**
* IF input from modem: **950–2150 MHz**, **−40 to 0 dBm**, **50 Ω**
* Reference: external **10 MHz**

> **Scope of this tool:** **Spurious optimization only.** Phase noise, gain/flatness, group delay, ACLR/regrowth, return loss, and EIRP are **out of scope**. Use the lines above only where they interact with spur evaluation.

## Frequency plan and architecture

* **IF1 (from modem):** Any bandwidth **≥ 400 MHz** that fits within **950–2150 MHz**.
  Choose IF1 center so the **entire** signal bandwidth lies within the IF band:
  **IF1_center ∈ [950 MHz + BW/2, 2150 MHz − BW/2]**.

* **Dual conversion:**

  * **LO1 (Synth 1) → Mixer 1:** IF1 → **IF2**
  * **IF2 band-pass filter (BPF):** idealized window or modeled from YAML/CSV S21
  * **LO2 (Synth 2) → Mixer 2:** IF2 → **RF** (center anywhere within **27.5–31.0 GHz**, preserving bandwidth)
  * **RF BPF:** modeled from YAML/CSV S21

* Evaluate **all** content at IF1, IF2, and RF, including images, LO feedthrough, and **any** in-band or out-of-band spurs.

* **Mapping freedom:** A given IF1 allocation may up-convert to **any valid RF allocation** in 27.5–31.0 GHz (one-to-many). Over a sweep of IF1 centers/bandwidths, mapping is **many-to-many**.
  **The optimal settings will generally vary across the band; the tool must output a *set* of settings covering the entire space.**

## Spur-critical considerations

* **LO1/LO2 planning:** Use dual-conversion degrees of freedom to avoid images, LO leakage, and high-order products.
* **IF2 & RF filtering inter-dependency:** LO1/LO2 choices set min/max IF2; the IF2 BPF window constrains viable LO plans. These must be **co-optimized**.
* **Comprehensive propagation:** Model Mixer-1 spurs translating through Mixer-2, e.g.
  ( m_2 \cdot \mathrm{LO2} \pm \big(n_2 \cdot (m_1 \cdot \mathrm{LO1} \pm n_1 \cdot \mathrm{IF1})\big) ), plus synthesizer harmonics and LO feedthrough for both stages.
* **Realistic levels:** Use **real mixer spur tables** (datasheets/measurements) and LO synthesizer YAMLs (e.g., LMX2592/LMX2595) with frequency range, step sizes, PFD, divider structures, output power/harmonics, and optional **fractional-N/PFD spur families** (k·fPFD ± …) with user-set amplitudes/roll-off.

## What to design

Design a **Python tool** focused on **dual-conversion BUC spur optimization**. The tool must:

1. **Inputs (files & parameters)**

* Mixer spur tables (YAML) for each candidate mixer.
* LO synthesizer data (YAML) for each candidate LO (frequency limits, step sizes, integer/fractional modes, PFD/ref constraints, output power, harmonics/multipliers/dividers, optional PFD spur families).
* RF filter S-parameters (YAML/CSV: frequency vs S21).
* **IF2 filter model parameters** (see below).
* IF1/RF bands and required signal bandwidth(s) (≥ 400 MHz).
* **Spur mask configuration**: default **−60 dBc** flat mask; allow configurable in-band vs OOB masks and/or offset-dependent masks (piecewise or tabular).
* Search granularity: LO step, center-frequency grid, bandwidth grid; synthesizer lock-time (for policy scoring).

2. **IF2 filter model (decision variables)**

* Passband: flat with configurable insertion loss across the entire passband.
* Roll-off: symmetric about center; constant **dB/decade** from passband edge to **−80 dB**, then a flat floor beyond.
* **Optimized parameters:** IF2 **center** and **bandwidth** (not fixed).

3. **Decision variables (global)**

* **LO1 frequency** and **LO2 frequency** (including allowed integer dividers/multipliers per synthesizer constraints).
* **IF2 BPF center** and **IF2 BPF bandwidth**.

4. **Constraints**

* RF centers anywhere within **27.5–31.0 GHz**, preserving the IF1 bandwidth.
* Respect synthesizer limits, step sizes, PFD/reference constraints, lock times, and modeled spur families.
* Apply IF2 and RF BPF attenuation to every spur/image/leakage frequency.
* Evaluate spur products up to configurable orders. **Defaults:** per-stage (|m|,|n| \le 7); and a combined cross-stage bound (|m_1|+|n_1|+|m_2|+|n_2| \le 12). All limits are user-configurable.

5. **Objective (policy-level)**

* Find a **frequency-plan policy** (\pi) that maps each request ((\mathrm{IF1\ center}, \mathrm{BW}, \mathrm{RF\ center})) to a setting ((\mathrm{LO1}, \mathrm{LO2}, \mathrm{IF2\ center}, \mathrm{IF2\ BW})).
* **Primary metric:** maximize the **worst-case spur margin** of the **policy** over all allowed IF1 centers/bandwidths and RF placements (i.e., optimize the *set* of plans, not a single LO pair).
* **Secondary tiebreakers:** minimize total **retunes** (account for synthesizer **step sizes** and **lock times**), minimize LO excursion/complexity, prefer IF2 windows enabling broad coverage, and minimize sensitivity to small grid shifts.

6. **Algorithmic approach**

* Use **affine frequency mapping** to deterministically enumerate spur locations for each candidate setting.
* Cascade model:

  1. Generate Mixer-1 desired & spur set at IF2 input/output.
  2. Apply **IF2 BPF attenuation** at each spur frequency.
  3. Mix into Mixer-2, adding second-stage spurs and LO2 harmonics.
  4. Apply **RF BPF attenuation** at each resulting frequency.
* **Amplitude combination:** Mixer spur levels are interpreted **relative to the desired tone** at each mixer’s output. Apply filter attenuation at the spur’s frequency; when multiple mechanisms coincide in frequency, **sum powers linearly** (not in dB), then convert to dB for margin calculations.
* Classify **in-band** vs **out-of-band** spurs; evaluate against the configured mask.
* **Policy search over tiles:** Tile the ((\mathrm{IF1\ center}, \mathrm{BW}, \mathrm{RF\ center})) space; choose local optima per tile; then **post-process** to coalesce adjacent tiles with identical settings and enforce **handover continuity** (hysteresis/guard bands).
* **Pruning/acceleration:** order-based bounds, image-rejection prechecks, frequency-range exclusions, dominance filters; early discard of infeasible LO/IF2 windows.
* Reproducible and deterministic: fixed seeds and deterministic grids.

7. **Outputs & reports (family of plans)**

* **Frequency-plan family (policy):** a tiled lookup (CSV/YAML) over ((\mathrm{IF1\ center}, \mathrm{BW}, \mathrm{RF\ center})) with recommended ((\mathrm{LO1}, \mathrm{LO2}, \mathrm{IF2\ center}, \mathrm{IF2\ BW})) and **spur margin** per tile. Adjacent tiles are merged where the same settings apply.
* **Runtime selector (\pi):** a simple function that, given ((\mathrm{IF1\ center}, \mathrm{BW}, \mathrm{RF\ center})), returns the recommended settings with optional **hysteresis** and **guard-band** rules to avoid chatter at tile edges.
* **Retune budget & lock-time accounting:** expected LO retunes for representative traffic patterns, using synthesizer lock times from the YAMLs.
* **Alternatives:** ranked settings within **X dB** of each tile’s optimum, with tradeoffs.
* **Spur ledgers:** dominant products, frequencies, estimated levels, filter attenuations, final margins for representative tiles.
* Export: policy table and IF2 filter spec (YAML), plus human-readable PDF/HTML summary.
* **Determinism metadata:** emit grids, step sizes, order limits, seeds, and tool/library versions to reproduce results.

8. **Validation**

* Consistency checks (units, grids, band edges).
* Analytic spot checks (e.g., low-side vs high-side injection) to verify affine mappings.
* Optional perturbation (± one grid step) to assess robustness.
* Compare predicted spur ledgers vs measured spur surveys when available.

## What to deliver 

* A detailed **architecture/design**: data schemas, spur enumeration math, cascade/attenuation computation, policy search strategy, tiling/merging, and pruning heuristics.
* Pseudocode or a step-by-step algorithm for the **policy** optimization loop (tiling → local optima → merge → continuity rules).
* Example input YAML stubs (mixer spur table, LO synth, RF/IF2 filter) and an illustrative end-to-end example (no code execution required).
* Validation tests and reporting layout.


---

DESIGN PLAN:

---

# Design Plan — Dual-Conversion BUC Spur-Optimization Tool

A Python tool that generates a **family of dual-conversion frequency plans** (LO1, LO2, IF2-BPF center/BW, RF BPF choice) maximizing **worst-case spur margin** across the operating space. The tool co-optimizes LO planning with IF2/RF filtering, rigorously models mixer spur behavior and synthesizer spur families, and outputs a deterministic tiled policy with merge/hysteresis, alternatives, retune accounting, and full spur ledgers.

---

## 1) System Context & Scope

* **Operating bands**

  * **IF1** (from modem): 950–2150 MHz. Signal bandwidths **≥ 400 MHz**; IF1 center must keep entire bandwidth in-range.
  * **RF**: 27.5–31.0 GHz. Mapping preserves instantaneous bandwidth and allows spectral inversion.
* **Architecture**: dual conversion
  IF1 —(Mixer-1 with LO1)→ **IF2** —(IF2 BPF)→ —(Mixer-2 with LO2)→ **RF** —(RF BPF)→ Output
* **Scope**: **Spurious optimization only**. Phase noise, gain/flatness, group delay, ACLR/regrowth, return loss, and EIRP are out of scope except where they interact with spur evaluation (e.g., masks, filters).

---

## 2) Objectives

1. **Primary**: Maximize **minimum spur margin** (in-band & OOB masks) over a **policy** that covers all tiles in the (IF1_center, BW, RF_center) space.
2. **Secondary tiebreakers**:

   * Minimize expected **retunes/lock time** under representative traffic.
   * Minimize LO excursions/complexity; prefer IF2 windows reusable across tiles.
   * Maximize robustness to small grid shifts; minimize sensitivity/brittleness.

---

## 3) Inputs (Files & Parameters)

### 3.1 Project / Analysis Config (YAML)

```yaml
project:
  name: "KaBUC-SpurPlan"
  seed: 42
  reference_10mhz_hz: 10000000

bands:
  if1_hz: {min: 950e6, max: 2150e6}
  rf_hz:  {min: 27.5e9, max: 31.0e9}
  required_bandwidths_hz: [400e6]  # extendable

grids:
  if1_center_step_hz: 25e6
  rf_center_step_hz: 25e6
  bw_grid_hz: [400e6]            # can include 450e6, etc.
  snap_if1_rf_to_grid: true

masks:
  inband:
    default_dbc: -60
    table: []                     # optional [{offset_hz, limit_dbc}, ...]
  outofband:
    default_dbc: -60
    table: []                     # absolute RF or edge-relative

rbw_binning:
  rbw_hz: 10e3
  rbw_frac_of_bw: 0.0025
  rbw_ppm_of_freq: 0
  coalesce_window: "max(rbw_hz, rbw_frac_of_bw*BW, rbw_ppm_of_freq*freq*1e-6)"

search:
  lo1_candidates: ["LMX2595_A","ADF4371_B"]
  lo2_candidates: ["LMX2592_A"]
  mixer1_candidates: ["MXR1"]
  mixer2_candidates: ["MXR2"]
  rf_bpf_choices: ["RF_S21_28to31GHz.csv"]   # discrete DV
  if2_filter_model: "IF2_Model_01"

orders:
  m1n1_max_abs: 7
  m2n2_max_abs: 7
  cross_stage_sum_max: 12

constraints:
  enforce_desired_mn11_only: true # desired paths restricted to (±1,±1) unless set false
  guard_margin_db: 2.0            # pessimism to absorb model bias

early_reject:
  image_in_if2_passband: true
  loft_in_if2_or_rf_passbands: true
  rf_first_order_image_in_passband: true

runtime_policy:
  hysteresis_hz: 10e6
  prefer_fewer_retunes: true
  lock_time_penalty_weight: 1.0
  markov_transition_matrix_csv: null

targets:
  min_margin_db: 0
  alt_within_db: 3.0              # keep alternatives within this
```

### 3.2 Mixer Model (YAML)

```yaml
name: "MXR1"
type: "double-balanced"
if_range_hz: [50e6, 8e9]
lo_range_hz: [100e6, 18e9]
rf_range_hz: [50e6, 18e9]

required_lo_drive_dbm: {min: +11, max: +17}
drive_derate:
  nominal_dbm: +13
  slope_db_per_db: 1.0        # spur gets worse this many dB per dB underdrive
  max_derate_db: 6.0

spur_table:                    # rejection vs DESIRED at mixer OUTPUT (dBc)
  domain: ["lo_hz","if_hz"]    # optional; otherwise scalar
  extrapolation: "clamp"       # clamp outside
  entries:
    - m: 1; n: 1; rej_dbc: -35
    - m: 1; n: 2; rej_dbc: -45
    - m: 2; n: 1; rej_dbc: -40
  grids:
    lo_hz: [500e6, 2e9, 6e9, 12e9]
    if_hz: [100e6, 500e6, 1e9]
    rej_dbc: [[-32,-34,-36], [-33,-35,-37], [-35,-37,-40], [-36,-38,-42]]

isolation:                     # explicit feedthrough/leakage at mixer OUTPUT
  lo_to_rf_db: -40             # LOFT
  if_to_rf_db: -60             # IF leakage (or IF->RF for upconverter orientation)

lo_family_scaling:             # order-aware scaling for LO harmonic/PFD use
  default_slope_db_per_db: 1.0 # spur level change per dB LO component change × |m|
  cap_db: 12

notes: "Tables interpreted at mixer output; derate & family scaling applied before filters."
```

> Provide one YAML per candidate mixer (Mixer-1 and Mixer-2).

### 3.3 LO Synthesizer Model (YAML)

```yaml
name: "LMX2595_A"
ref_constraints:
  allowed_refs_hz: [10e6]

freq_range_hz: [10e6, 20e9]
step_hz: 1e3

output_power_model:              # output power vs frequency/divider
  table:
    freq_hz: [5e9, 10e9, 15e9, 20e9]
    p_out_dbm: [+8, +7, +6, +5]
  divider_adjust_db:
    "/1": 0
    "/2": -1
    "/4": -2
    "/8": -3

distribution:                    # path to mixer input
  path_losses_db: {lo1: 3.0}     # cable/splitter losses per path
  pad_options_db: [0, 3, 6]

modes:
  - name: "fracN"
    enabled: true
    pfd_hz_range: [10e6, 200e6]
    pfd_dividers: [1,2,4,8]
    vco_dividers: [1,2,4,8,16]
    lock_time_model:
      base_ms: 0.40
      per_mhz_ms: 0.002         # extra per MHz hop at LO output
      mode_penalties_ms: {int_to_frac: 0.30, frac_to_int: 0.20}
    harmonics_at_output:         # relative at LO output after dividers
      - k: 2; rel_dBc: -25
      - k: 3; rel_dBc: -35
    pfd_spurs_at_output:
      families:
        - name: "k*fPFD"
          components:
            - k: 1; base_rel_dBc: -60; rolloff_dB_per_dec: 6
            - k: 2; base_rel_dBc: -65; rolloff_dB_per_dec: 6
    frac_boundary_spurs:
      enabled: true
      amplitude_at_eps0p5_rel_dBc: -58
      rolloff_slope_db_per_dec: 10

divider_spectrum:                # folding/attenuation from VCO to output
  "/1": { harm_delta_dBc: 0 }
  "/2": { harm_delta_dBc: +6 }
  "/4": { harm_delta_dBc: +12 }
  "/8": { harm_delta_dBc: +18 }
```

> Provide one YAML per candidate LO; include separate path losses for each LO→mixer route.

### 3.4 RF BPF (CSV/YAML)

* Columns: `freq_hz, s21_db`. Interpolate in log-frequency, linear in dB. Multiple files allowed as **discrete** decision variables.

### 3.5 IF2 Parametric BPF (YAML)

```yaml
name: "IF2_Model_01"
type: "symmetric_powerlaw"
passband_il_db: 1.0            # flat within passband
stop_floor_db: -80.0
rolloff_db_per_dec: 40.0       # slope outside passband edge to floor
min_bw_hz: 500e6
max_bw_hz: 6000e6
center_range_hz: [500e6, 9000e6]
search:
  seeds_per_tile: 8
  local_refinement: "coordinate_descent"  # 2-D: center and BW
  max_refine_iters: 12
  bounds_guard_hz: 0.0
```

---

## 4) Signal & Spur Modeling

### 4.1 Desired Path

* Stage-1 desired: `(m1*, n1*) = (±1, ±1)` with chosen high/low-side injection; inversion allowed.
* Stage-2 desired: `(m2*, n2*) = (±1, ±1)`; inversion allowed.
* Optionally allow higher-order desired paths if explicitly enabled in config.

### 4.2 LO Equivalent Carriers

For each LO:

* **Main** tone at `f_LO`.
* **Harmonics** `k*f_LO` with `rel_dBc` at the **output** after dividers (including `divider_spectrum` adjustments).
* **PFD spur families** at `f_LO ± k*f_PFD` with frequency-dependent roll-off.
* **Fractional-N boundary** spur envelope vs fractional error.

### 4.3 Stage-1 Enumeration

For all spur indices `(m1,n1)` within limits (excluding both zero), and for each LO1 equivalent carrier `c1`:

1. Compute the **IF2 output band**:

   ```
   B1_out = m1 * c1.freq  ±  n1 * IF1_band
   ```
2. Mixer-1 rejection `L1_rel_nom = rej(m1,n1; f_LO1, f_IF1)` via table, with **clamp extrapolation**.
3. **LO drive legality**: compute delivered LO power to Mixer-1:

   ```
   P_del = P_LO_out(f_LO1, divider) + divider_adjust - path_loss - pad
   ```

   * If out of `[min, max]`, try pad options; if under-driven by Δ, apply:

     ```
     L1_rel = L1_rel_nom + slope_db_per_db * Δ (capped)
     ```
4. **LO family scaling**: modify spur level for **non-main** LO carriers using an **order-aware slope**:

   ```
   Δ_LO = c1.rel_dBc (relative to main tone at mixer input)
   L1_rel_eff = L1_rel + lo_family_scaling.default_slope_db_per_db * |m1| * Δ_LO (capped)
   ```

### 4.4 IF2 BPF Attenuation (Differential)

Let `A_IF2(f)` be attenuation vs frequency for the parametric window:

```
ΔA_IF2 = A_IF2(spur_freq) - A_IF2(desired_IF2_center)
```

Flat passband → desired experiences passband IL; spurs outside see slope until floor.

### 4.5 Stage-2 Enumeration

For each surviving Stage-1 mechanism band and each `(m2,n2)` within limits and cross-stage sum cap, and for each LO2 equivalent carrier `c2`:

1. RF band produced:

   ```
   B2_out = m2 * c2.freq  ±  n2 * B1_out
   ```
2. Mixer-2 rejection `L2_rel_nom = rej(m2,n2; f_LO2, f_B1_center)`.
3. **LO2 drive legality & derate**: same as Stage-1.
4. **LO2 family scaling**:

   ```
   Δ_LO2 = c2.rel_dBc
   L2_rel_eff = L2_rel_nom + lo_family_scaling.default_slope_db_per_db * |m2| * Δ_LO2 (capped)
   ```

### 4.6 Explicit Feedthrough / Leakage Mechanisms

* **Mixer-1 LO feedthrough**: tone at `f_LO1` (after `c1=k=1`) with isolation `lo_to_rf_db` at Stage-1 output; mixed by Stage-2 like any Stage-1 tone.
* **Mixer-1 IF leakage**: tone(s) at IF1 band with `if_to_rf_db` at Stage-1 output; propagate through Stage-2.
* **Mixer-2 LO feedthrough**: tone at `f_LO2` appears at RF with `lo_to_rf_db` after Stage-2 (filtered by RF BPF).

### 4.7 RF BPF Attenuation (Differential)

Let `A_RF(f)` be RF filter attenuation:

```
ΔA_RF = A_RF(spur_freq) - A_RF(desired_RF_center)
```

### 4.8 Final Relative Spur Level & RBW Coalescing

* Compose levels (all in dB/dBc):

  ```
  L_rel_RF = L1_rel_eff + ΔA_IF2 + L2_rel_eff + ΔA_RF
  ```
* **RBW bins**: window width

  ```
  Δf_bin = max( rbw_hz, rbw_frac_of_bw*BW, rbw_ppm_of_freq*freq*1e-6 )
  ```

  Coalesce all mechanisms whose RF frequencies fall within the same bin by **summing linear power**.
  In-band classification uses RF passband limits expanded by ±Δf_bin/2 to avoid edge aliasing.

---

## 5) Constraints

* IF1 center must keep the full **BW** inside [950, 2150] MHz.
* RF center must be within [27.5, 31.0] GHz; the selected RF BPF must pass the desired RF band.
* Respect synthesizer frequency limits, step sizes, divider structures, PFD constraints, reference, and mode legality.
* IF2 parametric window must fully contain the **desired** IF2 band; optional guard margins.
* Apply both IF2 and RF BPF attenuation to every spur/image/leakage.
* Evaluate spur orders with defaults: per-stage `|m|,|n| ≤ 7`; cross-stage `|m1|+|n1|+|m2|+|n2| ≤ 12`. All configurable.

---

## 6) Policy Search & Optimization

### 6.1 Tiling

Create deterministic tiles over:

* `IF1_center ∈ [950e6 + BW/2, 2150e6 − BW/2]` with `if1_center_step_hz`
* `RF_center ∈ [27.5e9, 31.0e9]` with `rf_center_step_hz`
* `BW ∈ bw_grid_hz (≥ 400e6)`

### 6.2 Candidate Generation (per tile)

1. Enumerate **legal** LO1 and LO2 settings (modes, VCO/dividers, steps).
   Compute **delivered drives**, apply pads to be legal where possible.
2. For each RF BPF choice:

   * Propose **IF2 seeds**: center at desired IF2; ±edge-hugging; BW multipliers (1.05×…1.5×).
   * **2-D local refinement** (deterministic coordinate descent or bounded pattern search) over (center, BW) with cached attenuation evaluations, capped by `max_refine_iters`.

### 6.3 Early Rejects

* Reject if Stage-1 **image** or **LOFT** lands inside IF2 passband (configurable).
* Reject if likely Stage-2 **first-order images** (|m2|,|n2| ≤ 2) land inside RF passband for the candidate.
* Use bound checks: if partial budget indicates no chance to hit masks, skip deeper enumeration.

### 6.4 Scoring & Robustness

For each candidate:

1. Enumerate **all** spur mechanisms (Sections 4.3–4.8).
2. RBW-coalesce and classify **in-band** vs **OOB**.
3. For each bin `f`:
   `margin(f) = mask_limit_dBc(f) − L_rel_RF(f) − guard_margin_db`
4. Tile score = **minimum** margin across all bins.
5. Robustness: re-evaluate (cached) at ±half-step IF1 and ±half-step RF center (same BW). Tile score = **min** across these perturbations. Record **brittleness score** (slope of margin vs perturbation).

### 6.5 Alternatives, Merge, and Smoothing

* Keep **best** candidate and **alternatives** within `alt_within_db`.
* Merge adjacent tiles if settings identical or if swapping reduces **expected retunes** (weighted by `lock_time_penalty_weight` and optional Markov traffic model) with ≤ ε dB loss (ε default 0.5 dB).
* Apply **hysteresis** around tile edges to prevent chatter.

### 6.6 Retune Accounting

* Simulate representative traversals (uniform sweep; optional Markov chain).
* Count LO retunes; compute **lock time** per hop using `lock_time_model`:
  `lock = base + per_mhz*|Δf_out| + mode_transition_penalty`
* Report totals, rates, and distributions.

---

## 7) Pseudocode (Core)

### 7.1 Per-Tile Evaluation

```python
def enumerate_tile(tile, lo1, lo2, if2_win, rf_bpf, mix1, mix2, cfg):
    des1 = select_desired_stage1(tile, lo1, cfg)  # (±1,±1), inject high/low side
    des2 = select_desired_stage2(tile, lo2, des1, cfg)

    C1 = equivalent_carriers(lo1, cfg)  # main, harm, PFD, boundary; post-divider levels
    C2 = equivalent_carriers(lo2, cfg)

    bins = FrequencyBins(cfg.rbw_binning)

    # Mixer-1 legality & derate
    lo1_drive = delivered_drive(lo1, path="lo1", cfg=cfg)
    L1_derate = derate_from_drive(mix1, lo1_drive)

    # Mixer-2 legality & derate
    lo2_drive = delivered_drive(lo2, path="lo2", cfg=cfg)
    L2_derate = derate_from_drive(mix2, lo2_drive)

    # Explicit feedthrough/leakage at Stage-1 output
    stage1_specials = generate_stage1_specials(mix1, lo1, tile, C1)

    for (m1, n1) in spur_indices(cfg.orders.m1n1_max_abs):
        if m1 == 0 and n1 == 0: continue
        if abs(m1) + abs(n1) > cfg.orders.m1n1_max_abs: continue
        L1_nom = mixer_rejection(mix1, m1, n1, lo1.freq, tile.if1_center)

        for c1 in C1:
            B1_out = affine_band(m1 * c1.freq, sign(n1) * tile.if1_band)
            if early_reject_if2(B1_out, if2_win, cfg): continue

            dA_if2 = A_if2(B1_out, if2_win) - A_if2(des1.center, if2_win)
            L1_eff = L1_nom + L1_derate + family_scale(mix1, m1, c1.rel_dBc)

            # Stage-2 mixing of this mechanism
            for (m2, n2) in spur_indices(cfg.orders.m2n2_max_abs):
                if m2 == 0 and n2 == 0: continue
                if abs(m1)+abs(n1)+abs(m2)+abs(n2) > cfg.orders.cross_stage_sum_max: continue

                L2_nom = mixer_rejection(mix2, m2, n2, lo2.freq, center(B1_out))
                for c2 in C2:
                    B2_out = affine_band(m2 * c2.freq, sign(n2) * B1_out)
                    if early_reject_rf(B2_out, rf_bpf, cfg): continue

                    dA_rf = A_rf(B2_out, rf_bpf) - A_rf(des2.center, rf_bpf)
                    L_rf = L1_eff + dA_if2 + (L2_nom + L2_derate + family_scale(mix2, m2, c2.rel_dBc)) + dA_rf
                    bins.add(B2_out, L_rf)

    # Propagate explicit Stage-1 specials through Stage-2
    for mech in stage1_specials:
        propagate_to_rf(mech, lo2, C2, if2_win, rf_bpf, mix2, L2_derate, bins, cfg)

    summary = evaluate_bins_and_margins(bins, tile, rf_bpf, cfg)
    return summary  # worst margin, dominant bins, brittleness proxy
```

### 7.2 Optimization Driver

```python
def optimize_policy(cfg):
    tiles = make_tiles(cfg.bands, cfg.grids)
    results = {}

    for tile in deterministic_order(tiles):
        best = None
        alts = []

        for lo1 in legal_lo_settings(cfg.lo1_candidates, tile, stage=1, cfg=cfg):
            if not drive_legal(lo1, mixer="m1", cfg=cfg): continue
            for lo2 in legal_lo_settings(cfg.lo2_candidates, tile, stage=2, cfg=cfg):
                if not drive_legal(lo2, mixer="m2", cfg=cfg): continue
                for rf_bpf in cfg.search.rf_bpf_choices:

                    seeds = propose_if2_seeds(tile, lo1, lo2, rf_bpf, cfg)
                    for if2_win in refine_if2_window(seeds, cfg):  # 2-D refinement
                        if not contains_desired_if2(tile, if2_win): continue
                        if early_reject_images(tile, lo1, lo2, if2_win, rf_bpf, cfg): continue

                        summ = enumerate_tile(tile, lo1, lo2, if2_win, rf_bpf,
                                              mixers.m1, mixers.m2, cfg)
                        score = apply_robustness_and_guard(summ, tile, cfg)
                        cand = (lo1, lo2, if2_win, rf_bpf, summ, score)

                        if is_better(cand, best): best, alts = cand, []
                        elif within_db(cand, best, cfg.targets.alt_within_db): alts.append(cand)

        results[tile.id] = finalize_tile(best, alts, cfg)

    policy = merge_and_smooth(results, cfg.runtime_policy, traffic_model=cfg.runtime_policy.markov_transition_matrix_csv)
    return policy
```

---

## 8) Outputs & Reports

### 8.1 Policy Table (CSV/YAML)

```
tile_id, if1_center_hz, bw_hz, rf_center_hz,
lo1_hz, lo1_mode, lo1_vco_dividers, lo1_drive_dbm,
lo2_hz, lo2_mode, lo2_vco_dividers, lo2_drive_dbm,
if2_center_hz, if2_bw_hz, rf_bpf_id,
desired_stage1_tuple, desired_stage2_tuple,  # (m,n,sign) for traceability
spur_margin_db, brittleness_db_per_step,
lock_time_ms_accum, retune_cost, notes
```

### 8.2 Alternatives (Top-K within ΔdB)

Same columns plus `rank` and `delta_margin_db`.

### 8.3 Spur Ledgers (per representative tile)

```
bin_center_hz, inband, combined_level_dbc, mask_limit_dbc, margin_db,
components: [
  {stage1:(m1,n1,lo1_comp), stage2:(m2,n2,lo2_comp),
   f_rf_hz, L1_rel_dbc, dA_if2_db, L2_rel_dbc, lo_family_terms_db: (ΔLO1*m1, ΔLO2*m2),
   dA_rf_db}
]
```

### 8.4 Coverage Gaps

* Tiles with **no legal candidate** or **margin < target** by X dB, listing dominant blockers and suggested mitigation (e.g., shift IF2 center +Y MHz; choose RF_BPF_Z; prefer low-side LO1).

### 8.5 Retune & Lock-Time Report

* Expected retunes and total lock time for scenarios (uniform, Markov).
* Heatmaps: (a) spur margin, (b) retune density, (c) brittleness.

### 8.6 Determinism Metadata

* Grids, step sizes, order caps, seeds, exact hash of inputs, and tool/library versions to reproduce a byte-identical result.

---

## 9) Validation Suite

1. **Units & Band Edges**

   * IF1 containment, RF mapping inside limits, RF BPF passband check.
2. **Reference Normalization**

   * Use ΔA_IF2/ΔA_RF so desired attenuation cancels; move spur onto slope → correct delta in final level.
3. **Drive Legality & Derate**

   * Under-drive LO1 or LO2 by 3 dB → spur levels worsen ≈3 dB (within slope tolerance).
4. **LO Family Scaling**

   * Reduce LO harmonic by 10 dB → an `(m=2, n=1)` spur weakens ≈20 dB (capped as configured).
5. **Divider Folding**

   * Change divider /2→/4: verify which harmonics survive and new relative levels per `divider_spectrum`.
6. **RBW Coalescing**

   * Two tones within Δf_bin at −65 dBc each combine to ≈−62 dBc; separate beyond Δf_bin.
7. **Desired-Path Consistency**

   * Stage-2 table reference tied to selected Stage-1 desired tuple (same inversion).
8. **Early Reject Behaviors**

   * Images/LOFT in IF2 passband trigger reject; first-order Stage-2 images in RF passband trigger reject.
9. **Perturbation Robustness**

   * ±half-step IF1/RF centers; record margin drop and **brittleness score**.
10. **Determinism**

    * Re-run end-to-end; policy & metadata are byte-identical.

---

## 10) Heuristics, Pruning & Caching

* **Pruning**

  * Reject candidates early if partial budgets show massive margin; skip deeper second-stage enumeration.
  * Frequency-range exclusion for Stage-2 where `B2_out` cannot fall within `[RF_min−guard, RF_max+guard]`.
* **Caching**

  * RF S21 segment interpolation; IF2 attenuation grids for seed windows; mixer rejection lookups on `(f_LO, f_IF)` lattice with clamp.
  * RBW bins persisted per seed to accelerate local IF2 refinement.
* **Parallelization**

  * Tiles are embarrassingly parallel; assign deterministic partitions to preserve reproducibility.

---

## 11) Example Stubs

### 11.1 Example Tile

* `IF1_center = 1.55 GHz`, `BW = 400 MHz`
* `RF_center = 29.25 GHz`

**Candidate (illustrative)**

* Stage-1 desired: **high-side**, `f_LO1 = 6.20 GHz` → `IF2_center ≈ 4.65 GHz`.
* IF2 after 2-D refinement: `center = 4.65 GHz`, `BW = 500 MHz`.
* Stage-2 desired: **sum**, `f_LO2 = 24.60 GHz` → `RF_center = 29.25 GHz`.
* RF BPF: `RF_S21_28to31GHz.csv`.
* Drives: both LOs legal using pad options.
* Worst-bin margin: **+8.1 dB** with **brittleness 0.3 dB per half-step**.
* Alternative within **0.7 dB**: slightly offset IF2 center to push `(1,2)→(1,1)` product deeper into IF2 slope.

---

## 12) Runtime Selector (Policy π)

```python
plan = load_policy("policy.csv", hysteresis_hz=10e6)

def select_settings(if1_center_hz, bw_hz, rf_center_hz, last=None):
    tile = plan.locate(if1_center_hz, bw_hz, rf_center_hz)
    if last and near_boundary(tile, last, plan.hysteresis_hz):
        return last
    return plan[tile.id]
```

* Returns LO1/LO2 frequencies, modes/dividers, delivered drives, IF2 center/BW, RF BPF choice, expected margin, and desired tuples for traceability.

---

## 13) Reporting Layout (PDF/HTML)

1. **Executive Summary**

   * Coverage heatmap (minimum spur margin), list of gaps with root-cause mechanisms.
2. **Policy Table**

   * Merged tiles with settings, margins, brittleness, and retune metrics.
3. **Alternatives**

   * Top-K per tile within Δ dB, with trade-offs (e.g., fewer retunes vs slightly lower margin).
4. **Spur Ledgers**

   * For representative tiles: each dominant bin’s **waterfall** (L1, ΔA_IF2, L2, LO family terms, ΔA_RF).
5. **Retune Budget**

   * Scenario-wise counts, accumulated lock times, distributions; hop-size histograms.
6. **Determinism & Config**

   * All grids, orders, seeds, masks, model versions, file hashes.

---

## 14) Implementation Notes

* All computations **deterministic**: fixed seeds, fixed grid orders, stable sorting for ties.
* Power summations performed in linear domain; convert to dB for margins.
* Spectral inversion handled explicitly; mask lookup uses absolute frequency with in-band edges expanded by Δf_bin/2.
* Configurable **guard margin** subtracted from margins to avoid optimistic rankings.
* Emit desired tuples and inversion flags per tile to make RF mapping auditable.

---

**Result:** A deterministic, measurement-aligned optimization tool that co-plans LO1/LO2 and IF2, rigorously propagates mixer and synthesizer spurs with order-aware LO-family scaling, accounts for legal LO drive at **both** mixers, models divider-dependent spectral behavior and Δf-dependent lock times, and delivers a robust, policy-level frequency-plan family with complete reporting and validation.

---

CURRENT PROJECT CODEBASE (JSON FORMATTED):

---

{
  "type": "directory",
  "name": "bucso_repo",
  "path": ".",
  "children": [
    {
      "type": "directory",
      "name": "src",
      "path": "src",
      "children": [
        {
          "type": "directory",
          "name": "bucso",
          "path": "src\\bucso",
          "children": [
            {
              "type": "file",
              "name": "__init__.py",
              "path": "src\\bucso\\__init__.py",
              "size": 0,
              "content_truncated": false,
              "contents": "",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "cli.py",
              "path": "src\\bucso\\cli.py",
              "size": 14298,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nimport os, sys, json, yaml, hashlib\r\nfrom pathlib import Path\r\nimport typer\r\nfrom rich import print\r\nfrom rich.table import Table\r\nfrom rich.progress import Progress, BarColumn, TimeElapsedColumn, TimeRemainingColumn, MofNCompleteColumn, SpinnerColumn\r\n\r\nfrom .models import Config\r\nfrom .policy import optimize as optimize_policy\r\nfrom .tiling import make_tiles\r\n\r\napp = typer.Typer(no_args_is_help=True)\r\n\r\n@app.command()\r\ndef init_stubs(dst: str = \"examples\"):\r\n    \"\"\"Write example YAML/CSV stubs.\"\"\"\r\n    p = Path(dst)\r\n    p.mkdir(parents=True, exist_ok=True)\r\n    (p/\"config.yaml\").write_text(EXAMPLE_CONFIG)\r\n    (p/\"MXR1.yaml\").write_text(EXAMPLE_MIXER)\r\n    (p/\"MXR2.yaml\").write_text(EXAMPLE_MIXER2)\r\n    (p/\"LMX2595_A.yaml\").write_text(EXAMPLE_LO)\r\n    (p/\"LMX2592_A.yaml\").write_text(EXAMPLE_LO2)\r\n    (p/\"IF2_Model_01.yaml\").write_text(EXAMPLE_IF2)\r\n    (p/\"RF_S21_28to31GHz.csv\").write_text(EXAMPLE_RF_CSV)\r\n    print(f\"[green]Stub inputs written to {p}[/green]\")\r\n\r\ndef _resolve_model_paths(cfg: Config, cfg_path: str) -> list[str]:\r\n    \"\"\"Collect absolute file paths for hashing/metadata.\"\"\"\r\n    base = Path(cfg_path).parent.resolve()\r\n    files: list[str] = [str(Path(cfg_path).resolve())]\r\n\r\n    def _abspath(p):\r\n        return str((p if os.path.isabs(p) else base / p).resolve())\r\n\r\n    files.extend(_abspath(p) for p in cfg.search.mixer1_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.mixer2_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.lo1_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.lo2_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.rf_bpf_choices)\r\n    files.append(_abspath(cfg.search.if2_filter_model))\r\n    # de-dup and keep deterministic order\r\n    files = sorted(set(files))\r\n    return files\r\n\r\ndef _write_runtime_selector(dst_py: Path, hysteresis_hz: float):\r\n    \"\"\"Emit a simple runtime selector π that loads policy.csv and applies hysteresis.\"\"\"\r\n    code = f'''# Auto-generated runtime selector (π)\r\nfrom __future__ import annotations\r\nimport csv\r\nfrom dataclasses import dataclass\r\nfrom pathlib import Path\r\n\r\nHYSTERESIS_HZ = {hysteresis_hz:.1f}\r\n\r\n@dataclass(frozen=True)\r\nclass Row:\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n    lo1_name: str\r\n    lo1_hz: float\r\n    lo1_mode: str\r\n    lo1_divider: str\r\n    lo1_pad_db: float\r\n    lo2_name: str\r\n    lo2_hz: float\r\n    lo2_mode: str\r\n    lo2_divider: str\r\n    lo2_pad_db: float\r\n    if2_center_hz: float\r\n    if2_bw_hz: float\r\n    rf_bpf_id: str\r\n    spur_margin_db: float\r\n    desired_stage1_sign: int\r\n    desired_stage2_sign: int\r\n\r\ndef load_policy_csv(path: str | Path) -> list[Row]:\r\n    rows: list[Row] = []\r\n    with open(path, \"r\", newline=\"\") as f:\r\n        for r in csv.DictReader(f):\r\n            rows.append(Row(\r\n                if1_center_hz=float(r[\"if1_center_hz\"]),\r\n                bw_hz=float(r[\"bw_hz\"]),\r\n                rf_center_hz=float(r[\"rf_center_hz\"]),\r\n                lo1_name=r[\"lo1_name\"],\r\n                lo1_hz=float(r[\"lo1_hz\"]),\r\n                lo1_mode=r[\"lo1_mode\"],\r\n                lo1_divider=r[\"lo1_divider\"],\r\n                lo1_pad_db=float(r[\"lo1_pad_db\"]),\r\n                lo2_name=r[\"lo2_name\"],\r\n                lo2_hz=float(r[\"lo2_hz\"]),\r\n                lo2_mode=r[\"lo2_mode\"],\r\n                lo2_divider=r[\"lo2_divider\"],\r\n                lo2_pad_db=float(r[\"lo2_pad_db\"]),\r\n                if2_center_hz=float(r[\"if2_center_hz\"]),\r\n                if2_bw_hz=float(r[\"if2_bw_hz\"]),\r\n                rf_bpf_id=r[\"rf_bpf_id\"],\r\n                spur_margin_db=float(r[\"spur_margin_db\"]),\r\n                desired_stage1_sign=int(r.get(\"desired_stage1_sign\",\"1\")),\r\n                desired_stage2_sign=int(r.get(\"desired_stage2_sign\",\"1\")),\r\n            ))\r\n    return rows\r\n\r\ndef select_settings(rows: list[Row], if1_center_hz: float, bw_hz: float, rf_center_hz: float, last: Row | None = None) -> Row:\r\n    # Hysteresis: if last exists and requested RF is within ±HYSTERESIS_HZ, keep last\r\n    if last and abs(rf_center_hz - last.rf_center_hz) <= HYSTERESIS_HZ and abs(if1_center_hz - last.if1_center_hz) <= HYSTERESIS_HZ and abs(bw_hz - last.bw_hz) < 1:\r\n        return last\r\n    # Nearest neighbor on (if1_center, bw, rf_center)\r\n    best = None; best_d = 1e99\r\n    for r in rows:\r\n        if abs(r.bw_hz - bw_hz) > 1:  # require exact BW\r\n            continue\r\n        d = abs(r.if1_center_hz - if1_center_hz) + abs(r.rf_center_hz - rf_center_hz)\r\n        if d < best_d:\r\n            best, best_d = r, d\r\n    return best if best else rows[0]\r\n'''\r\n    dst_py.parent.mkdir(parents=True, exist_ok=True)\r\n    dst_py.write_text(code, encoding=\"utf-8\")\r\n\r\n@app.command()\r\ndef validate(cfg_path: str):\r\n    \"\"\"Validate config YAML loads and basic constraints.\"\"\"\r\n    cfg = Config(**yaml.safe_load(Path(cfg_path).read_text()))\r\n    assert cfg.bands.if1_hz.min < cfg.bands.if1_hz.max\r\n    assert cfg.bands.rf_hz.min < cfg.bands.rf_hz.max\r\n    print(\"[green]Config validated.[/green]\")\r\n\r\n@app.command()\r\ndef optimize(cfg_path: str, out: str = \"out\", models_dir: str | None = None):\r\n    \"\"\"Run optimization and write policy YAML/CSV + runtime selector. Shows a progress bar.\"\"\"\r\n    cfg = Config(**yaml.safe_load(Path(cfg_path).read_text()))\r\n    mdir = models_dir or str(Path(cfg_path).parent)\r\n\r\n    # Compute tiles up-front so we can size the progress bar deterministically\r\n    tiles = make_tiles(\r\n        cfg.bands.if1_hz.min, cfg.bands.if1_hz.max,\r\n        cfg.bands.rf_hz.min, cfg.bands.rf_hz.max,\r\n        cfg.grids.bw_grid_hz, cfg.grids.if1_center_step_hz, cfg.grids.rf_center_step_hz\r\n    )\r\n    total_tiles = len(tiles)\r\n\r\n    # Progress bar\r\n    progress_columns = (\r\n        SpinnerColumn(),\r\n        \"[bold]Optimizing[/bold]\",\r\n        BarColumn(bar_width=None),\r\n        MofNCompleteColumn(),\r\n        TimeElapsedColumn(),\r\n        TimeRemainingColumn(),\r\n    )\r\n\r\n    # File list (for hashes)\r\n    input_files = _resolve_model_paths(cfg, cfg_path)\r\n\r\n    with Progress(*progress_columns) as progress:\r\n        task_id = progress.add_task(\"Optimizing\", total=total_tiles)\r\n\r\n        def _progress_cb(done: int):\r\n            # called once per tile completion from the policy layer\r\n            progress.update(task_id, advance=done)\r\n\r\n        policy = optimize_policy(cfg, mdir, input_files=input_files, progress_cb=_progress_cb)\r\n\r\n    outp = Path(out); outp.mkdir(parents=True, exist_ok=True)\r\n    (outp/\"policy.yaml\").write_text(yaml.safe_dump(policy, sort_keys=False))\r\n    # Compact CSV\r\n    rows = policy[\"rows\"]\r\n    import pandas as pd\r\n    df = pd.DataFrame(rows)\r\n    df.to_csv(outp/\"policy.csv\", index=False)\r\n    print(f\"[green]Wrote {len(rows)} policy rows to {outp}[/green]\")\r\n\r\n    # Spur ledgers (optional, compact JSONL per tile)\r\n    ledgers = policy.get(\"ledgers\", {})\r\n    if ledgers:\r\n        (outp/\"ledgers.jsonl\").write_text(\r\n            \"\\n\".join(json.dumps({\"tile_id\": int(k), \"bins\": v}, ensure_ascii=False) for k, v in ledgers.items()),\r\n            encoding=\"utf-8\"\r\n        )\r\n\r\n    # Spans & coverage gaps\r\n    if policy.get(\"spans\"):\r\n        (outp/\"spans.yaml\").write_text(yaml.safe_dump(policy[\"spans\"], sort_keys=False), encoding=\"utf-8\")\r\n    if policy.get(\"coverage_gaps\"):\r\n        (outp/\"coverage_gaps.yaml\").write_text(yaml.safe_dump(policy[\"coverage_gaps\"], sort_keys=False), encoding=\"utf-8\")\r\n\r\n    # Runtime selector (π)\r\n    _write_runtime_selector(outp/\"runtime_selector.py\", hysteresis_hz=cfg.runtime_policy.hysteresis_hz)\r\n\r\n    print(f\"[green]Wrote runtime selector to {outp/'runtime_selector.py'}[/green]\")\r\n\r\n@app.command()\r\ndef report(policy_yaml: str, html: str = \"out/summary.html\"):\r\n    \"\"\"Very light HTML summary.\"\"\"\r\n    policy = yaml.safe_load(Path(policy_yaml).read_text())\r\n    from jinja2 import Template\r\n    tpl = Template(\"\"\"\r\n    <html><head><meta charset=\"utf-8\"><title>BUCSO Summary</title>\r\n    <style>table {border-collapse: collapse} td,th{border:1px solid #ccc;padding:4px}</style>\r\n    </head><body>\r\n    <h1>{{proj.name}}</h1>\r\n    <p>Rows: {{rows|length}} | Seed: {{meta.deterministic_seed}}</p>\r\n    <p>Total lock: {{meta.retune_accounting.total_lock_ms}} ms | Retunes: {{meta.retune_accounting.retunes}} | Avg/step: {{meta.retune_accounting.avg_lock_ms_per_hop}} ms</p>\r\n    <p>Input hashes:</p>\r\n    <pre style=\"font-size:12px\">{{ meta.file_hashes | tojson(indent=2) }}</pre>\r\n    <table>\r\n      <tr>\r\n        <th>tile</th><th>IF1c</th><th>BW</th><th>RFc</th>\r\n        <th>LO1</th><th>LO2</th><th>IF2c</th><th>IF2BW</th><th>RF BPF</th><th>Margin (dB)</th>\r\n      </tr>\r\n      {% for r in rows %}\r\n      <tr>\r\n        <td>{{r.tile_id}}</td>\r\n        <td>{{\"%.3f\"%(r.if1_center_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.0f\"%(r.bw_hz/1e6)}} MHz</td>\r\n        <td>{{\"%.3f\"%(r.rf_center_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.3f\"%(r.lo1_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.3f\"%(r.lo2_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.3f\"%(r.if2_center_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.0f\"%(r.if2_bw_hz/1e6)}} MHz</td>\r\n        <td>{{r.rf_bpf_id}}</td>\r\n        <td>{{\"%.1f\"%r.spur_margin_db}}</td>\r\n      </tr>\r\n      {% endfor %}\r\n    </table>\r\n    </body></html>\"\"\")\r\n    html_text = tpl.render(proj=policy[\"project\"], rows=policy[\"rows\"], meta=policy[\"meta\"])\r\n    Path(html).parent.mkdir(parents=True, exist_ok=True)\r\n    Path(html).write_text(html_text, encoding=\"utf-8\")\r\n    print(f\"[green]Wrote {html}[/green]\")\r\n\r\n# --- Example stubs embedded so `init-stubs` needs no downloads ---\r\n\r\nEXAMPLE_CONFIG = \"\"\"\\\r\nproject:\r\n  name: \"KaBUC-SpurPlan\"\r\n  seed: 42\r\n  reference_10mhz_hz: 10000000\r\n\r\nbands:\r\n  if1_hz: {min: 950e6, max: 2150e6}\r\n  rf_hz: {min: 27.5e9, max: 31.0e9}\r\n  required_bandwidths_hz: [400e6]\r\n\r\ngrids:\r\n  if1_center_step_hz: 100e6\r\n  rf_center_step_hz: 250e6\r\n  bw_grid_hz: [400e6]\r\n  snap_if1_rf_to_grid: true\r\n\r\nmasks:\r\n  inband: {default_dbc: -60, table: []}\r\n  outofband: {default_dbc: -60, table: []}\r\n\r\nrbw_binning:\r\n  rbw_hz: 10e3\r\n  rbw_frac_of_bw: 0.0025\r\n  rbw_ppm_of_freq: 0\r\n\r\nsearch:\r\n  lo1_candidates: [\"LMX2595_A.yaml\"]\r\n  lo2_candidates: [\"LMX2592_A.yaml\"]\r\n  mixer1_candidates: [\"MXR1.yaml\"]\r\n  mixer2_candidates: [\"MXR2.yaml\"]\r\n  rf_bpf_choices: [\"RF_S21_28to31GHz.csv\"]\r\n  if2_filter_model: \"IF2_Model_01.yaml\"\r\n\r\norders:\r\n  m1n1_max_abs: 7\r\n  m2n2_max_abs: 7\r\n  cross_stage_sum_max: 12\r\n\r\nconstraints:\r\n  enforce_desired_mn11_only: true\r\n  guard_margin_db: 2.0\r\n\r\nearly_reject:\r\n  image_in_if2_passband: true\r\n  loft_in_if2_or_rf_passbands: true\r\n  rf_first_order_image_in_passband: true\r\n\r\nruntime_policy:\r\n  hysteresis_hz: 10e6\r\n  prefer_fewer_retunes: true\r\n  lock_time_penalty_weight: 1.0\r\n  markov_transition_matrix_csv: null\r\n\r\ntargets:\r\n  min_margin_db: 0\r\n  alt_within_db: 3.0\r\n\"\"\"\r\n\r\nEXAMPLE_MIXER = \"\"\"\\\r\nname: \"MXR1\"\r\ntype: \"double-balanced\"\r\nif_range_hz: [50e6, 8e9]\r\nlo_range_hz: [100e6, 18e9]\r\nrf_range_hz: [50e6, 18e9]\r\n\r\nrequired_lo_drive_dbm: {min: 11, max: 17}\r\ndrive_derate: {nominal_dbm: 13, slope_db_per_db: 1.0, max_derate_db: 6}\r\n\r\nspur_table:\r\n  entries:\r\n    - {m: 1, n: 1, rej_dbc: -35}\r\n    - {m: 1, n: 2, rej_dbc: -45}\r\n    - {m: 2, n: 1, rej_dbc: -40}\r\n  grids:\r\n    lo_hz: [500e6, 2e9, 6e9, 12e9]\r\n    if_hz: [100e6, 500e6, 1e9]\r\n    rej_dbc: [[-32,-34,-36], [-33,-35,-37], [-35,-37,-40], [-36,-38,-42]]\r\n\r\nisolation:\r\n  lo_to_rf_db: -40\r\n  if_to_rf_db: -60\r\n\r\nlo_family_scaling:\r\n  default_slope_db_per_db: 1.0\r\n  cap_db: 12\r\n\"\"\"\r\n\r\nEXAMPLE_MIXER2 = \"\"\"\\\r\nname: \"MXR2\"\r\ntype: \"double-balanced\"\r\nif_range_hz: [50e6, 12e9]\r\nlo_range_hz: [100e6, 26e9]\r\nrf_range_hz: [50e6, 32e9]\r\n\r\nrequired_lo_drive_dbm: {min: 11, max: 17}\r\ndrive_derate: {nominal_dbm: 13, slope_db_per_db: 1.0, max_derate_db: 6}\r\n\r\nspur_table:\r\n  entries:\r\n    - {m: 1, n: 1, rej_dbc: -30}\r\n    - {m: 1, n: 2, rej_dbc: -38}\r\n    - {m: 2, n: 1, rej_dbc: -36}\r\n  grids:\r\n    lo_hz: [2e9, 10e9, 20e9, 26e9]\r\n    if_hz: [100e6, 2e9, 6e9]\r\n    rej_dbc: [[-28,-30,-32], [-29,-31,-33], [-31,-33,-35], [-32,-34,-36]]\r\n\r\nisolation:\r\n  lo_to_rf_db: -38\r\n  if_to_rf_db: -55\r\n\r\nlo_family_scaling:\r\n  default_slope_db_per_db: 1.0\r\n  cap_db: 12\r\n\"\"\"\r\n\r\nEXAMPLE_LO = \"\"\"\\\r\nname: \"LMX2595_A\"\r\nref_constraints:\r\n  allowed_refs_hz: [10e6]\r\n\r\nfreq_range_hz: [10e6, 20e9]\r\nstep_hz: 1e6\r\n\r\noutput_power_model:\r\n  table:\r\n    freq_hz: [5e9, 10e9, 15e9, 20e9]\r\n    p_out_dbm: [19, 19, 19, 19]\r\n  divider_adjust_db:\r\n    \"/1\": 0\r\n    \"/2\": -1\r\n    \"/4\": -2\r\n    \"/8\": -3\r\n\r\ndistribution:\r\n  path_losses_db: {lo1: 3.0}\r\n  pad_options_db: [0, 3, 6]\r\n\r\nmodes:\r\n  - name: \"fracN\"\r\n    enabled: true\r\n    pfd_hz_range: [10e6, 200e6]\r\n    pfd_dividers: [1,2,4,8]\r\n    vco_dividers: [1,2,4,8,16]\r\n    lock_time_model:\r\n      base_ms: 0.40\r\n      per_mhz_ms: 0.002\r\n      mode_penalties_ms: {int_to_frac: 0.30, frac_to_int: 0.20}\r\n    harmonics_at_output:\r\n      - {k: 2, rel_dBc: -25}\r\n      - {k: 3, rel_dBc: -35}\r\n    pfd_spurs_at_output:\r\n      families: []\r\n\r\ndivider_spectrum:\r\n  \"/1\": { harm_delta_dBc: 0 }\r\n  \"/2\": { harm_delta_dBc: 6 }\r\n  \"/4\": { harm_delta_dBc: 12 }\r\n  \"/8\": { harm_delta_dBc: 18 }\r\n\"\"\"\r\n\r\nEXAMPLE_LO2 = \"\"\"\\\r\nname: \"LMX2592_A\"\r\nref_constraints:\r\n  allowed_refs_hz: [10e6]\r\n\r\nfreq_range_hz: [10e6, 26e9]\r\nstep_hz: 1e6\r\n\r\noutput_power_model:\r\n  table:\r\n    freq_hz: [5e9, 10e9, 20e9, 26e9]\r\n    p_out_dbm: [15, 15, 15, 15]\r\n  divider_adjust_db:\r\n    \"/1\": 0\r\n\r\ndistribution:\r\n  path_losses_db: {lo2: 4.0}\r\n  pad_options_db: [0, 3, 6]\r\n\r\nmodes:\r\n  - name: \"fracN\"\r\n    enabled: true\r\n    pfd_hz_range: [10e6, 200e6]\r\n    pfd_dividers: [1,2,4,8]\r\n    vco_dividers: [1,2,4,8,16]\r\n    lock_time_model:\r\n      base_ms: 0.50\r\n      per_mhz_ms: 0.002\r\n      mode_penalties_ms: {int_to_frac: 0.30, frac_to_int: 0.20}\r\n    harmonics_at_output:\r\n      - {k: 2, rel_dBc: -25}\r\n    pfd_spurs_at_output:\r\n      families: []\r\n\r\ndivider_spectrum:\r\n  \"/1\": { harm_delta_dBc: 0 }\r\n\"\"\"\r\n\r\nEXAMPLE_IF2 = \"\"\"\\\r\nname: \"IF2_Model_01\"\r\ntype: \"symmetric_powerlaw\"\r\npassband_il_db: 1.0\r\nstop_floor_db: -80.0\r\nrolloff_db_per_dec: 40.0\r\nmin_bw_hz: 500e6\r\nmax_bw_hz: 6000e6\r\ncenter_range_hz: [500e6, 9000e6]\r\nsearch:\r\n  seeds_per_tile: 8\r\n  local_refinement: \"coordinate_descent\"\r\n  max_refine_iters: 12\r\n  bounds_guard_hz: 0.0\r\n\"\"\"\r\n\r\nEXAMPLE_RF_CSV = \"\"\"\\\r\nfreq_hz,s21_db\r\n2.60e10,-30\r\n2.75e10,-5\r\n2.90e10,-1\r\n3.10e10,-1\r\n3.25e10,-10\r\n\"\"\"\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "filters.py",
              "path": "src\\bucso\\filters.py",
              "size": 2640,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass, field\r\nfrom typing import Callable\r\nimport numpy as np\r\nimport pandas as pd\r\nfrom scipy.interpolate import interp1d\r\n\r\n\r\n@dataclass\r\nclass RFBPF:\r\n    freq_hz: np.ndarray\r\n    s21_db: np.ndarray\r\n    id: str\r\n\r\n    # cached members (not shown in repr)\r\n    _x: np.ndarray = field(init=False, repr=False)\r\n    _y: np.ndarray = field(init=False, repr=False)\r\n    _interp: Callable[[np.ndarray], np.ndarray] = field(init=False, repr=False)\r\n\r\n    @classmethod\r\n    def from_csv(cls, path: str) -> \"RFBPF\":\r\n        df = pd.read_csv(path)\r\n        # Ensure sorted by frequency for deterministic, correct interpolation\r\n        df = df.sort_values(\"freq_hz\", kind=\"mergesort\")\r\n        f = df[\"freq_hz\"].to_numpy(dtype=float)\r\n        s = df[\"s21_db\"].to_numpy(dtype=float)\r\n        obj = cls(freq_hz=f, s21_db=s, id=path)\r\n        # Build interpolator once (log-frequency, linear dB) with extrapolation\r\n        obj._x = np.log10(obj.freq_hz)\r\n        obj._y = obj.s21_db\r\n        obj._interp = interp1d(\r\n            obj._x, obj._y,\r\n            kind=\"linear\",\r\n            fill_value=\"extrapolate\",\r\n            assume_sorted=True,\r\n        )\r\n        return obj\r\n\r\n    def attn_at(self, f_hz):\r\n        \"\"\"\r\n        Return attenuation at f_hz (Hz). Accepts scalar or ndarray.\r\n        Always returns an ndarray of dtype float (shape follows input).\r\n        NOTE: Do NOT clamp here; we rely on extrapolation of the log-frequency interpolator.\r\n        \"\"\"\r\n        fx = np.log10(np.asarray(f_hz, dtype=float))\r\n        return np.asarray(self._interp(fx), dtype=float)\r\n\r\n\r\n@dataclass\r\nclass IF2Parametric:\r\n    center_hz: float\r\n    bw_hz: float\r\n    passband_il_db: float\r\n    stop_floor_db: float\r\n    rolloff_db_per_dec: float  # positive number (magnitude)\r\n    # symmetric_powerlaw\r\n\r\n    def attn_at(self, f_hz: float) -> float:\r\n        \"\"\"\r\n        Flat IL inside passband; outside, slope to floor (negative).\r\n        (Scalar implementation — cheap and fine for current call sites.)\r\n        \"\"\"\r\n        edge = self.bw_hz / 2.0\r\n        df = abs(f_hz - self.center_hz)\r\n        if df <= edge:\r\n            return -abs(self.passband_il_db)\r\n        # decades beyond edge\r\n        decades = np.log10(max(df / edge, 1e-9))\r\n        attn = -abs(self.passband_il_db) - self.rolloff_db_per_dec * decades\r\n        return max(attn, self.stop_floor_db)\r\n\r\n    def contains_desired(self, center: float, bw: float) -> bool:\r\n        # require desired band fully inside passband rectangle\r\n        return (abs(center - self.center_hz) + bw / 2.0) <= (self.bw_hz / 2.0)\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "mixer.py",
              "path": "src\\bucso\\mixer.py",
              "size": 4618,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom typing import Dict\r\nfrom functools import lru_cache\r\nimport numpy as np\r\nfrom .models import MixerModel\r\nfrom .utils import clamp\r\n\r\n\r\ndef _bilinear_clamped(z: np.ndarray, x_axis: np.ndarray, y_axis: np.ndarray, x: float, y: float) -> float:\r\n    \"\"\"\r\n    Bilinear interpolation over a rect grid with clamp-at-edges behavior.\r\n    z shape must be (len(x_axis), len(y_axis)) in the same orientation used in the YAML.\r\n    \"\"\"\r\n    # map value->index space (scalar)\r\n    xi = np.interp(x, x_axis, np.arange(len(x_axis)))\r\n    yi = np.interp(y, y_axis, np.arange(len(y_axis)))\r\n    i0 = int(clamp(np.floor(xi + 1e-9), 0, len(x_axis) - 2))\r\n    j0 = int(clamp(np.floor(yi + 1e-9), 0, len(y_axis) - 2))\r\n    tx = xi - i0\r\n    ty = yi - j0\r\n    return float(\r\n        z[i0, j0] * (1 - tx) * (1 - ty)\r\n        + z[i0 + 1, j0] * (tx) * (1 - ty)\r\n        + z[i0, j0 + 1] * (1 - tx) * (ty)\r\n        + z[i0 + 1, j0 + 1] * (tx) * (ty)\r\n    )\r\n\r\n\r\nclass Mixer:\r\n    \"\"\"\r\n    Mixer rejection lookup with:\r\n      - scalar entries for specific (m,n)\r\n      - optional per-(m,n) grids (grids_by_order: {\"m,n\": {lo_hz, if_hz, rej_dbc}})\r\n      - optional legacy single grid assumed to be (1,1)\r\n      - configurable fallback for unknown orders\r\n    Also provides simple drive-derate and order-aware LO family scaling.\r\n    \"\"\"\r\n\r\n    def __init__(self, mdl: MixerModel):\r\n        self.mdl = mdl\r\n\r\n        st: Dict[str, object] = mdl.spur_table or {}\r\n\r\n        # New: per-(m,n) grids\r\n        self._grids_by_order: Dict[str, Dict[str, np.ndarray]] = {}\r\n        if \"grids_by_order\" in st and isinstance(st[\"grids_by_order\"], dict):\r\n            for key, g in st[\"grids_by_order\"].items():\r\n                self._grids_by_order[str(key)] = {\r\n                    \"lo\": np.array((g.get(\"lo_hz\") or []), float),\r\n                    \"if\": np.array((g.get(\"if_hz\") or []), float),\r\n                    \"rej\": np.array((g.get(\"rej_dbc\") or []), float),\r\n                }\r\n\r\n        # Legacy: a single grid interpreted as the (1,1) grid.\r\n        self._grid_default = None\r\n        if \"grids\" in st and isinstance(st[\"grids\"], dict):\r\n            g = st[\"grids\"]\r\n            self._grid_default = {\r\n                \"lo\": np.array((g.get(\"lo_hz\") or []), float),\r\n                \"if\": np.array((g.get(\"if_hz\") or []), float),\r\n                \"rej\": np.array((g.get(\"rej_dbc\") or []), float),\r\n            }\r\n\r\n        # Scalar entries\r\n        self._entries = st.get(\"entries\", []) or []\r\n\r\n        # Quantization for cache keys (Hz)\r\n        self._q_hz = 1e6\r\n\r\n    def set_cache_quantum_hz(self, q_hz: float):\r\n        self._q_hz = float(q_hz)\r\n        self._rej_cached.cache_clear()\r\n\r\n    def clear_cache(self):\r\n        self._rej_cached.cache_clear()\r\n\r\n    @lru_cache(maxsize=65536)\r\n    def _rej_cached(self, m: int, n: int, lo_q: float, if_q: float) -> float:\r\n        # 1) Exact scalar entry wins\r\n        for e in self._entries:\r\n            if e.get(\"m\") == m and e.get(\"n\") == n:\r\n                return float(e[\"rej_dbc\"])\r\n\r\n        # 2) Per-(m,n) grid if present\r\n        key = f\"{int(m)},{int(n)}\"\r\n        grid = self._grids_by_order.get(key)\r\n        if grid and grid[\"rej\"].size and grid[\"lo\"].size and grid[\"if\"].size:\r\n            return _bilinear_clamped(grid[\"rej\"], grid[\"lo\"], grid[\"if\"], lo_q, if_q)\r\n\r\n        # 3) Legacy default grid only for (1,1)\r\n        if (m == 1 and n == 1) and (self._grid_default is not None):\r\n            gd = self._grid_default\r\n            if gd[\"rej\"].size and gd[\"lo\"].size and gd[\"if\"].size:\r\n                return _bilinear_clamped(gd[\"rej\"], gd[\"lo\"], gd[\"if\"], lo_q, if_q)\r\n\r\n        # 4) Conservative fallback\r\n        return float(self.mdl.fallback_rej_dbc)\r\n\r\n    def rejection_dbc(self, m: int, n: int, lo_hz: float, if_hz: float) -> float:\r\n        q = self._q_hz\r\n        return self._rej_cached(m, n, round(lo_hz / q) * q, round(if_hz / q) * q)\r\n\r\n    def drive_derate_db(self, delivered_dbm: float) -> float:\r\n        reqmin = self.mdl.required_lo_drive_dbm[\"min\"]\r\n        if delivered_dbm >= reqmin:\r\n            return 0.0\r\n        delta = reqmin - delivered_dbm\r\n        slope = self.mdl.drive_derate.slope_db_per_db\r\n        cap = self.mdl.drive_derate.max_derate_db\r\n        return min(cap, slope * delta)\r\n\r\n    def family_scale_db(self, order_abs: int, lo_rel_dBc: float) -> float:\r\n        slope = self.mdl.lo_family_scaling.get(\"default_slope_db_per_db\", 1.0)\r\n        cap = self.mdl.lo_family_scaling.get(\"cap_db\", 12.0)\r\n        val = slope * abs(order_abs) * lo_rel_dBc\r\n        return max(-cap, min(cap, val))\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "models.py",
              "path": "src\\bucso\\models.py",
              "size": 5017,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom typing import List, Optional, Dict, Tuple\r\nfrom pydantic import BaseModel, Field\r\nimport numpy as np\r\n\r\nHz = float\r\ndB = float\r\n\r\n\r\nclass Project(BaseModel):\r\n    name: str = \"KaBUC-SpurPlan\"\r\n    seed: int = 42\r\n    reference_10mhz_hz: Hz = 10_000_000.0\r\n\r\n\r\nclass BandLimits(BaseModel):\r\n    min: Hz\r\n    max: Hz\r\n\r\n\r\nclass Bands(BaseModel):\r\n    if1_hz: BandLimits\r\n    rf_hz: BandLimits\r\n    required_bandwidths_hz: List[Hz] = [400e6]\r\n\r\n\r\nclass Grids(BaseModel):\r\n    if1_center_step_hz: Hz = 25e6\r\n    rf_center_step_hz: Hz = 25e6\r\n    bw_grid_hz: List[Hz] = [400e6]\r\n    snap_if1_rf_to_grid: bool = True\r\n\r\n\r\nclass MaskTableEntry(BaseModel):\r\n    offset_hz: Hz\r\n    limit_dbc: dB\r\n\r\n\r\nclass MaskSpec(BaseModel):\r\n    default_dbc: dB = -60.0\r\n    # safer than a bare [] default\r\n    table: List[MaskTableEntry] = Field(default_factory=list)\r\n\r\n\r\nclass Masks(BaseModel):\r\n    inband: MaskSpec = MaskSpec()\r\n    outofband: MaskSpec = MaskSpec()\r\n\r\n\r\nclass RBWBinning(BaseModel):\r\n    rbw_hz: Hz = 10e3\r\n    rbw_frac_of_bw: float = 0.0025\r\n    rbw_ppm_of_freq: float = 0.0\r\n\r\n\r\nclass Orders(BaseModel):\r\n    m1n1_max_abs: int = 7\r\n    m2n2_max_abs: int = 7\r\n    cross_stage_sum_max: int = 12\r\n\r\n\r\nclass Constraints(BaseModel):\r\n    enforce_desired_mn11_only: bool = True\r\n    guard_margin_db: dB = 2.0\r\n\r\n\r\nclass EarlyReject(BaseModel):\r\n    image_in_if2_passband: bool = True\r\n    loft_in_if2_or_rf_passbands: bool = True\r\n    rf_first_order_image_in_passband: bool = True\r\n\r\n\r\nclass RuntimePolicy(BaseModel):\r\n    hysteresis_hz: Hz = 10e6\r\n    prefer_fewer_retunes: bool = True\r\n    lock_time_penalty_weight: float = 1.0\r\n    markov_transition_matrix_csv: Optional[str] = None\r\n\r\n\r\nclass Targets(BaseModel):\r\n    min_margin_db: dB = 0.0\r\n    alt_within_db: dB = 3.0\r\n\r\n\r\nclass Search(BaseModel):\r\n    lo1_candidates: List[str]\r\n    lo2_candidates: List[str]\r\n    mixer1_candidates: List[str]\r\n    mixer2_candidates: List[str]\r\n    rf_bpf_choices: List[str]\r\n    if2_filter_model: str\r\n\r\n\r\nclass Config(BaseModel):\r\n    project: Project\r\n    bands: Bands\r\n    grids: Grids\r\n    masks: Masks = Masks()\r\n    rbw_binning: RBWBinning = RBWBinning()\r\n    search: Search\r\n    orders: Orders = Orders()\r\n    constraints: Constraints = Constraints()\r\n    early_reject: EarlyReject = EarlyReject()\r\n    runtime_policy: RuntimePolicy = RuntimePolicy()\r\n    targets: Targets = Targets()\r\n\r\n\r\n# Mixer & LO YAML models (simplified for starter)\r\nclass MixerSpurEntry(BaseModel):\r\n    m: int\r\n    n: int\r\n    rej_dbc: dB\r\n\r\n\r\nclass MixerIsolation(BaseModel):\r\n    lo_to_rf_db: dB = -40.0\r\n    if_to_rf_db: dB = -60.0\r\n\r\n\r\nclass MixerDriveDerate(BaseModel):\r\n    nominal_dbm: float = 13.0\r\n    slope_db_per_db: float = 1.0\r\n    max_derate_db: float = 6.0\r\n\r\n\r\nclass MixerModel(BaseModel):\r\n    name: str\r\n    type: str = \"double-balanced\"\r\n    if_range_hz: Tuple[Hz, Hz]\r\n    lo_range_hz: Tuple[Hz, Hz]\r\n    rf_range_hz: Tuple[Hz, Hz]\r\n    required_lo_drive_dbm: Dict[str, float] = {\"min\": 11.0, \"max\": 17.0}\r\n    drive_derate: MixerDriveDerate = MixerDriveDerate()\r\n    # spur_table supports:\r\n    #   - entries: [ {m,n,rej_dbc}, ... ]\r\n    #   - grids_by_order: {\"m,n\": {lo_hz, if_hz, rej_dbc}}\r\n    #   - (legacy) grids: {lo_hz, if_hz, rej_dbc} interpreted as (1,1)\r\n    spur_table: Dict[str, object]\r\n    isolation: MixerIsolation = MixerIsolation()\r\n    lo_family_scaling: Dict[str, float] = {\"default_slope_db_per_db\": 1.0, \"cap_db\": 12.0}\r\n    notes: Optional[str] = None\r\n    # configurable fallback for missing table entries (keep but consider tightening in config)\r\n    fallback_rej_dbc: dB = -20.0\r\n\r\n\r\nclass Harmonic(BaseModel):\r\n    k: int\r\n    rel_dBc: dB\r\n\r\n\r\nclass PfdComponent(BaseModel):\r\n    k: int\r\n    base_rel_dBc: dB\r\n    rolloff_dB_per_dec: float\r\n\r\n\r\nclass PfdFamily(BaseModel):\r\n    name: str\r\n    components: List[PfdComponent]\r\n\r\n\r\nclass LockTimeModel(BaseModel):\r\n    base_ms: float = 0.4\r\n    per_mhz_ms: float = 0.002\r\n    mode_penalties_ms: Dict[str, float] = {}\r\n\r\n\r\nclass Mode(BaseModel):\r\n    name: str\r\n    enabled: bool = True\r\n    pfd_hz_range: Tuple[Hz, Hz]\r\n    pfd_dividers: List[int]\r\n    vco_dividers: List[int]\r\n    lock_time_model: LockTimeModel\r\n    harmonics_at_output: List[Harmonic] = []\r\n    pfd_spurs_at_output: Dict[str, List[PfdFamily]] | Dict[str, object] | None = None\r\n    frac_boundary_spurs: Dict[str, object] | None = None\r\n\r\n\r\nclass DividerSpectrum(BaseModel):\r\n    harm_delta_dBc: dB = 0.0\r\n\r\n\r\nclass OutputPowerTable(BaseModel):\r\n    table: Dict[str, List[float]]\r\n    divider_adjust_db: Dict[str, float] = {}\r\n\r\n\r\nclass Distribution(BaseModel):\r\n    path_losses_db: Dict[str, float]\r\n    pad_options_db: List[float] = [0.0, 3.0, 6.0]\r\n\r\n\r\nclass LOMdl(BaseModel):\r\n    name: str\r\n    ref_constraints: Dict[str, List[Hz]]\r\n    freq_range_hz: Tuple[Hz, Hz]\r\n    step_hz: Hz = 1e3\r\n    output_power_model: OutputPowerTable\r\n    distribution: Distribution\r\n    modes: List[Mode]\r\n    divider_spectrum: Dict[str, DividerSpectrum]\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "policy.py",
              "path": "src\\bucso\\policy.py",
              "size": 40304,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass, asdict\r\nfrom typing import List, Dict, Callable, Optional, Tuple\r\nimport os, yaml, math, hashlib, importlib.metadata\r\nimport numpy as np\r\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\r\n\r\nfrom .models import Config, MixerModel, LOMdl, Mode\r\nfrom .filters import IF2Parametric, RFBPF\r\nfrom .mixer import Mixer\r\nfrom .synth import Synth\r\nfrom .tiling import make_tiles\r\nfrom .spur import enumerate_spurs, desired_paths\r\nfrom .utils import Band\r\n\r\n\r\n@dataclass\r\nclass PlanRow:\r\n    tile_id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n    lo1_name: str\r\n    lo1_hz: float\r\n    lo1_mode: str\r\n    lo1_divider: str\r\n    lo1_pad_db: float\r\n    lo1_lock_ms: float\r\n    lo2_name: str\r\n    lo2_hz: float\r\n    lo2_mode: str\r\n    lo2_divider: str\r\n    lo2_pad_db: float\r\n    lo2_lock_ms: float\r\n    if2_center_hz: float\r\n    if2_bw_hz: float\r\n    rf_bpf_id: str\r\n    spur_margin_db: float\r\n    brittleness_db_per_step: float\r\n    # Traceability: desired signs used\r\n    desired_stage1_sign: int\r\n    desired_stage2_sign: int\r\n\r\n\r\ndef _load_yaml(root: str, name_or_path: str):\r\n    path = name_or_path if os.path.isabs(name_or_path) else os.path.join(root, name_or_path)\r\n    with open(path, \"r\") as f:\r\n        return yaml.safe_load(f)\r\n\r\ndef _file_hash(path: str) -> str:\r\n    h = hashlib.sha256()\r\n    with open(path, \"rb\") as f:\r\n        for chunk in iter(lambda: f.read(1 << 20), b\"\"):\r\n            h.update(chunk)\r\n    return h.hexdigest()\r\n\r\ndef _overlap_1d(a_center: float, a_bw: float, b_center: float, b_bw: float) -> bool:\r\n    a_lo = a_center - a_bw / 2.0\r\n    a_hi = a_center + a_bw / 2.0\r\n    b_lo = b_center - b_bw / 2.0\r\n    b_hi = b_center + b_bw / 2.0\r\n    return not (a_hi < b_lo or b_hi < a_lo)\r\n\r\n\r\ndef _early_reject_gate(\r\n    tile_if1: Band,\r\n    lo1_hz: float,\r\n    lo2_hz: float,\r\n    inj1: int,\r\n    s2: int,\r\n    if2: IF2Parametric,\r\n    rf_bpf: RFBPF,\r\n    cfg: Config,\r\n) -> bool:\r\n    \"\"\"\r\n    Stronger early rejects with band-overlap checks.\r\n    Returns True if candidate should be rejected.\r\n    \"\"\"\r\n    if not (\r\n        cfg.early_reject.image_in_if2_passband\r\n        or cfg.early_reject.loft_in_if2_or_rf_passbands\r\n        or cfg.early_reject.rf_first_order_image_in_passband\r\n    ):\r\n        return False\r\n\r\n    # Desired bands for equivalence tests\r\n    if2_des, rf_des = desired_paths(tile_if1, lo1_hz, lo2_hz, inj1, s2)\r\n\r\n    # Stage-1 images (sum & diff) against IF2 passband — don't reject if it's the desired path\r\n    if cfg.early_reject.image_in_if2_passband:\r\n        for sgn in (+1, -1):\r\n            img2_c = abs(lo1_hz + sgn * tile_if1.center_hz)\r\n            is_desired = abs(img2_c - if2_des.center_hz) <= 1e-6\r\n            if (not is_desired) and _overlap_1d(img2_c, tile_if1.bw_hz, if2.center_hz, if2.bw_hz):\r\n                return True\r\n\r\n    # LO1 feedthrough inside IF2 passband\r\n    if cfg.early_reject.loft_in_if2_or_rf_passbands:\r\n        if _overlap_1d(lo1_hz, 0.0, if2.center_hz, if2.bw_hz):\r\n            return True\r\n\r\n    # Stage-2 first-order images (±LO2 ± IF2) overlapping RF desired band\r\n    if cfg.early_reject.rf_first_order_image_in_passband:\r\n        for sgn1 in (+1, -1):\r\n            for sgn2 in (+1, -1):\r\n                f_c = abs(sgn1 * lo2_hz + sgn2 * if2_des.center_hz)\r\n                if _overlap_1d(f_c, if2_des.bw_hz, rf_des.center_hz, rf_des.bw_hz):\r\n                    is_desired = (sgn1 == s2) and (sgn2 == +1)\r\n                    is_desired_equiv = (sgn1 == -s2) and (sgn2 == -1)  # |·| symmetry\r\n                    # Reject only if a different first-order image overlaps\r\n                    if not (is_desired or is_desired_equiv):\r\n                        return True\r\n\r\n    return False\r\n\r\n\r\n# --- Helpers -------------------------------------------------------------\r\n\r\ndef _rf_band_ok(rf_filter: RFBPF, rf_band_center: float, rf_bw: float, max_il_db: float = 3.0) -> bool:\r\n    \"\"\"Require the desired RF band (center ± BW/2) to be inside the passband by IL >= -max_il_db.\"\"\"\r\n    half = rf_bw * 0.5\r\n    fs = (rf_band_center - half, rf_band_center, rf_band_center + half)\r\n    attn = [float(rf_filter.attn_at(f)) for f in fs]\r\n    return min(attn) >= -max_il_db\r\n\r\n\r\n# --- IF2 refinement (deterministic coordinate descent) ------------------------\r\n\r\ndef _coordinate_descent_if2(\r\n    if2_const: dict,\r\n    seed_center_hz: float,\r\n    seed_bw_hz: float,\r\n    tile_if1: Band,\r\n    lo1,\r\n    lo2,\r\n    rf_filter: RFBPF,\r\n    mixer1: Mixer,\r\n    mixer2: Mixer,\r\n    cfg: Config,\r\n    inj1: int,\r\n    s2: int,\r\n    carriers_lo1,\r\n    carriers_lo2,\r\n    max_iters: int,\r\n    step_frac_center: float,\r\n    step_frac_bw: float,\r\n    bw_limits: tuple[float, float],\r\n    center_limits: tuple[float, float],\r\n) -> IF2Parametric:\r\n    \"\"\"\r\n    Internal helper that actually runs the loop. if2_const has keys:\r\n      passband_il_db, stop_floor_db, rolloff_db_per_dec\r\n    \"\"\"\r\n    c = float(seed_center_hz)\r\n    b = float(seed_bw_hz)\r\n    best_win = IF2Parametric(\r\n        center_hz=c, bw_hz=b,\r\n        passband_il_db=if2_const[\"passband_il_db\"],\r\n        stop_floor_db=if2_const[\"stop_floor_db\"],\r\n        rolloff_db_per_dec=if2_const[\"rolloff_db_per_dec\"],\r\n    )\r\n\r\n    # Evaluate objective\r\n    def score(win: IF2Parametric) -> float:\r\n        if2_des_center = abs(inj1 * lo1.f_out_hz - tile_if1.center_hz)\r\n        if not win.contains_desired(center=if2_des_center, bw=tile_if1.bw_hz):\r\n            return -1e9\r\n        summ = enumerate_spurs(\r\n            tile_if1, lo1, lo2, win, rf_filter, mixer1, mixer2, cfg,\r\n            inj1_sign=inj1, s2_sign=s2, carriers_lo1=carriers_lo1, carriers_lo2=carriers_lo2\r\n        )\r\n        return float(summ.worst_margin_db)\r\n\r\n    best = score(best_win)\r\n    dc = max(1.0, step_frac_center) * (tile_if1.bw_hz * 0.5)  # start with half-BW scaled step\r\n    db = max(1.0, step_frac_bw) * (tile_if1.bw_hz * 0.3)\r\n\r\n    for _ in range(max_iters):\r\n        improved = False\r\n        # Try center +/- dc\r\n        for sign in (+1, -1):\r\n            c_try = float(np.clip(c + sign * dc, center_limits[0], center_limits[1]))\r\n            win = IF2Parametric(c_try, b, if2_const[\"passband_il_db\"], if2_const[\"stop_floor_db\"], if2_const[\"rolloff_db_per_dec\"])\r\n            s = score(win)\r\n            if s > best + 1e-6:\r\n                best, c, best_win = s, c_try, win\r\n                improved = True\r\n        # Try BW +/- db\r\n        for sign in (+1, -1):\r\n            b_try = float(np.clip(b + sign * db, bw_limits[0], bw_limits[1]))\r\n            win = IF2Parametric(c, b_try, if2_const[\"passband_il_db\"], if2_const[\"stop_floor_db\"], if2_const[\"rolloff_db_per_dec\"])\r\n            s = score(win)\r\n            if s > best + 1e-6:\r\n                best, b, best_win = s, b_try, win\r\n                improved = True\r\n\r\n        # Shrink steps\r\n        dc *= 0.5\r\n        db *= 0.5\r\n\r\n    return best_win\r\n\r\n\r\ndef _robustness_score(\r\n    base_summary,\r\n    tile_if1: Band,\r\n    lo1, lo2,\r\n    if2_use: IF2Parametric,\r\n    rf_filter: RFBPF,\r\n    mixer1: Mixer,\r\n    mixer2: Mixer,\r\n    cfg: Config,\r\n    inj1: int,\r\n    s2: int,\r\n    carriers_lo1,\r\n    carriers_lo2,\r\n    rf_center_nominal: float,\r\n    if1_step: float,\r\n    rf_step: float,\r\n) -> Tuple[float, float]:\r\n    \"\"\"\r\n    Evaluate worst-case margin under ± half-step perturbations of IF1 and RF centers.\r\n    We keep the LO/IF2 settings fixed and only change the evaluation reference.\r\n    Returns (robust_min_margin, brittleness_db_per_step).\r\n    \"\"\"\r\n    margins = [float(base_summary.worst_margin_db)]\r\n\r\n    # IF1 ± half step (true recomputation, because IF2 desired depends on IF1)\r\n    for sign in (+1, -1):\r\n        if1_pert = Band(tile_if1.center_hz + sign * 0.5 * if1_step, tile_if1.bw_hz)\r\n        summ = enumerate_spurs(\r\n            if1_pert, lo1, lo2, if2_use, rf_filter, mixer1, mixer2, cfg,\r\n            inj1_sign=inj1, s2_sign=s2, carriers_lo1=carriers_lo1, carriers_lo2=carriers_lo2\r\n        )\r\n        margins.append(float(summ.worst_margin_db))\r\n\r\n    # RF ± half step (classification/limit reference moves; hardware fixed)\r\n    for sign in (+1, -1):\r\n        rf_ref = rf_center_nominal + sign * 0.5 * rf_step\r\n        summ = enumerate_spurs(\r\n            tile_if1, lo1, lo2, if2_use, rf_filter, mixer1, mixer2, cfg,\r\n            inj1_sign=inj1, s2_sign=s2, carriers_lo1=carriers_lo1, carriers_lo2=carriers_lo2,\r\n            rf_center_override_hz=rf_ref, rf_bw_override_hz=tile_if1.bw_hz,\r\n        )\r\n        margins.append(float(summ.worst_margin_db))\r\n\r\n    robust = float(min(margins))\r\n    drop = float(max(margins) - robust) if margins else 0.0\r\n    # Keep unit as \"drop in dB\"\r\n    brittleness = drop\r\n    return robust, brittleness\r\n\r\n\r\ndef _eval_tile(task_args) -> tuple[PlanRow | None, list[dict], dict] | None:\r\n    \"\"\"\r\n    Worker function: evaluate one tile with carriers, early rejects, RF-BPF choice,\r\n    robustness, and alternatives within Δ dB of best.\r\n    Returns (best_row, alternatives_list, ledger_for_best) or None if no candidate.\r\n    \"\"\"\r\n    t, cfg_dict, models_dir = task_args\r\n    cfg = Config(**cfg_dict)\r\n\r\n    # Load models (ALL candidates)\r\n    mixer1_mdls = [Mixer(MixerModel(**_load_yaml(models_dir, p))) for p in cfg.search.mixer1_candidates]\r\n    mixer2_mdls = [Mixer(MixerModel(**_load_yaml(models_dir, p))) for p in cfg.search.mixer2_candidates]\r\n    lo1_synths = [Synth(LOMdl(**_load_yaml(models_dir, p))) for p in cfg.search.lo1_candidates]\r\n    lo2_synths = [Synth(LOMdl(**_load_yaml(models_dir, p))) for p in cfg.search.lo2_candidates]\r\n\r\n    # RF BPF set (decision variable)\r\n    rf_paths = cfg.search.rf_bpf_choices\r\n    rf_filters = []\r\n    for rp in rf_paths:\r\n        path = rp if os.path.isabs(rp) else os.path.join(models_dir, rp)\r\n        rf_filters.append(RFBPF.from_csv(path))\r\n\r\n    if2_yaml = _load_yaml(models_dir, cfg.search.if2_filter_model)\r\n\r\n    def _f(x, default=None):\r\n        if x is None:\r\n            return float(default) if default is not None else None\r\n        try:\r\n            return float(x)\r\n        except (TypeError, ValueError):\r\n            return float(str(x))\r\n\r\n    if2_pass_il = _f(if2_yaml.get(\"passband_il_db\", 1.0), 1.0)\r\n    if2_floor = _f(if2_yaml.get(\"stop_floor_db\", -80.0), -80.0)\r\n    if2_roll = _f(if2_yaml.get(\"rolloff_db_per_dec\", 40.0), 40.0)\r\n    if2_min_bw = _f(if2_yaml.get(\"min_bw_hz\", 500e6), 500e6)\r\n    if2_max_bw = _f(if2_yaml.get(\"max_bw_hz\", 6000e6), 6000e6)\r\n    _cr = if2_yaml.get(\"center_range_hz\", [500e6, 9000e6]) or [500e6, 9000e6]\r\n    if2_center_range = (_f(_cr[0], 500e6), _f(_cr[1], 9000e6))\r\n\r\n    # Search parameters (if present)\r\n    search_cfg = (if2_yaml.get(\"search\") or {})\r\n    seeds_per_tile = int(search_cfg.get(\"seeds_per_tile\", 8) or 8)  # reserved, currently not used\r\n    refine_kind = str(search_cfg.get(\"local_refinement\", \"coordinate_descent\"))\r\n    max_refine_iters = int(search_cfg.get(\"max_refine_iters\", 12) or 12)\r\n\r\n    tile_if1 = Band(t.if1_center_hz, t.bw_hz)\r\n    best_row: PlanRow | None = None\r\n    best_summary = None\r\n    best_score = -1e9\r\n    alternatives: list[dict] = []\r\n    best_ledger: dict = {}\r\n\r\n    # --- Derive IF2 seeds around IF1 center (targeted search) ---\r\n    seed_center_muls = (0.7, 0.85, 1.0, 1.15, 1.3)\r\n    if2_center_seeds = [float(np.clip(m * t.if1_center_hz, if2_center_range[0], if2_center_range[1])) for m in seed_center_muls]\r\n    if2_center_seeds = sorted(set(if2_center_seeds))  # determinism\r\n\r\n    # IF2 BW seeds around required BW\r\n    bw_seed_list = (1.05, 1.2, 1.5)\r\n\r\n    for mixer1 in mixer1_mdls:\r\n        for mixer2 in mixer2_mdls:\r\n            for inj1 in (+1, -1):\r\n                for if2c_seed in if2_center_seeds:\r\n                    for bw_mul in bw_seed_list:\r\n                        if2_bw_seed = float(np.clip(bw_mul * t.bw_hz, if2_min_bw, if2_max_bw))\r\n                        if2_template = IF2Parametric(if2c_seed, if2_bw_seed, if2_pass_il, if2_floor, if2_roll)\r\n\r\n                        # Stage-1 target LO1s from seed center; include (IF2+IF1) and (IF2-IF1) if >0\r\n                        lo1_targets = [inj1 * (if2c_seed + t.if1_center_hz)]\r\n                        alt_t = inj1 * (if2c_seed - t.if1_center_hz)\r\n                        if alt_t > 0:\r\n                            lo1_targets.append(alt_t)\r\n\r\n                        # Enumerate LO1 and LO2 legal settings in a widened window (P2)\r\n                        for lo1_synth in lo1_synths:\r\n                            fmin1 = max(1.0, min(lo1_targets) - 3 * t.bw_hz)\r\n                            fmax1 = max(lo1_targets) + 3 * t.bw_hz\r\n                            lo1_settings = lo1_synth.legal_settings(\r\n                                name_filter=None,\r\n                                f_min=fmin1,\r\n                                f_max=fmax1,\r\n                                path=\"lo1\",\r\n                                drive_min_dbm=mixer1.mdl.required_lo_drive_dbm[\"min\"],\r\n                                drive_max_dbm=mixer1.mdl.required_lo_drive_dbm[\"max\"],\r\n                            )\r\n                            if not lo1_settings:\r\n                                continue\r\n\r\n                            for lo1 in lo1_settings:\r\n                                # NOW we know the desired IF2 center; require the desired band inside IF2 passband\r\n                                if2_des_center = abs(inj1 * lo1.f_out_hz - t.if1_center_hz)\r\n                                if not if2_template.contains_desired(if2_des_center, t.bw_hz):\r\n                                    continue\r\n\r\n                                for s2 in (+1, -1):\r\n                                    # Stage-2 targets based on desired RF = | s2*LO2 + IF2 | = t.rf_center_hz\r\n                                    candidates = [s2 * (t.rf_center_hz - if2c_seed), s2 * (-t.rf_center_hz - if2c_seed)]\r\n                                    for lo2_synth in lo2_synths:\r\n                                        fmin2 = min(candidates) - 3 * t.bw_hz\r\n                                        fmax2 = max(candidates) + 3 * t.bw_hz\r\n                                        lo2_settings = lo2_synth.legal_settings(\r\n                                            name_filter=None,\r\n                                            f_min=max(1.0, fmin2),\r\n                                            f_max=fmax2,\r\n                                            path=\"lo2\",\r\n                                            drive_min_dbm=mixer2.mdl.required_lo_drive_dbm[\"min\"],\r\n                                            drive_max_dbm=mixer2.mdl.required_lo_drive_dbm[\"max\"],\r\n                                        )\r\n                                        if not lo2_settings:\r\n                                            continue\r\n\r\n                                        for lo2 in lo2_settings:\r\n                                            # Verify desired RF placement under these LOs\r\n                                            _, rf_des_chk = desired_paths(tile_if1, lo1.f_out_hz, lo2.f_out_hz, inj1, s2)\r\n                                            if abs(rf_des_chk.center_hz - t.rf_center_hz) > (cfg.grids.rf_center_step_hz * 0.5 + 1e3):\r\n                                                continue\r\n\r\n                                            # Build equivalent carriers (with divider-spectrum behavior) using chosen PFD\r\n                                            mode1 = next((m for m in lo1_synth.mdl.modes if m.name == lo1.mode), lo1_synth.mdl.modes[0])\r\n                                            mode2 = next((m for m in lo2_synth.mdl.modes if m.name == lo2.mode), lo2_synth.mdl.modes[0])\r\n                                            C1 = lo1_synth.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n                                            C2 = lo2_synth.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n\r\n                                            # Desired RF band must be inside RF BPF passband (edges too)\r\n                                            for rf_filter in rf_filters:\r\n                                                if not _rf_band_ok(rf_filter, rf_des_chk.center_hz, t.bw_hz, max_il_db=3.0):\r\n                                                    continue\r\n\r\n                                                # Early reject gates (includes desired-equivalence checks)\r\n                                                if _early_reject_gate(tile_if1, lo1.f_out_hz, lo2.f_out_hz, inj1, s2, if2_template, rf_filter, cfg):\r\n                                                    continue\r\n\r\n                                                # --- IF2 refinement (coordinate descent) ---\r\n                                                if refine_kind == \"coordinate_descent\" and max_refine_iters > 0:\r\n                                                    if2_const = {\r\n                                                        \"passband_il_db\": if2_pass_il,\r\n                                                        \"stop_floor_db\": if2_floor,\r\n                                                        \"rolloff_db_per_dec\": if2_roll,\r\n                                                    }\r\n                                                    if2_use = _coordinate_descent_if2(\r\n                                                        if2_const=if2_const,\r\n                                                        seed_center_hz=if2c_seed,\r\n                                                        seed_bw_hz=if2_bw_seed,\r\n                                                        tile_if1=tile_if1,\r\n                                                        lo1=lo1,\r\n                                                        lo2=lo2,\r\n                                                        rf_filter=rf_filter,\r\n                                                        mixer1=mixer1,\r\n                                                        mixer2=mixer2,\r\n                                                        cfg=cfg,\r\n                                                        inj1=inj1,\r\n                                                        s2=s2,\r\n                                                        carriers_lo1=C1,\r\n                                                        carriers_lo2=C2,\r\n                                                        max_iters=max_refine_iters,\r\n                                                        step_frac_center=0.1,\r\n                                                        step_frac_bw=0.15,\r\n                                                        bw_limits=(if2_min_bw, if2_max_bw),\r\n                                                        center_limits=if2_center_range,\r\n                                                    )\r\n                                                else:\r\n                                                    if2_use = if2_template\r\n\r\n                                                # Base evaluation\r\n                                                summ = enumerate_spurs(\r\n                                                    tile_if1,\r\n                                                    lo1,\r\n                                                    lo2,\r\n                                                    if2_use,\r\n                                                    rf_filter,\r\n                                                    mixer1,\r\n                                                    mixer2,\r\n                                                    cfg,\r\n                                                    inj1_sign=inj1,\r\n                                                    s2_sign=s2,\r\n                                                    carriers_lo1=C1,\r\n                                                    carriers_lo2=C2,\r\n                                                )\r\n\r\n                                                # Robustness evaluation (± half-steps)\r\n                                                robust_margin, brittleness = _robustness_score(\r\n                                                    base_summary=summ,\r\n                                                    tile_if1=tile_if1,\r\n                                                    lo1=lo1,\r\n                                                    lo2=lo2,\r\n                                                    if2_use=if2_use,\r\n                                                    rf_filter=rf_filter,\r\n                                                    mixer1=mixer1,\r\n                                                    mixer2=mixer2,\r\n                                                    cfg=cfg,\r\n                                                    inj1=inj1,\r\n                                                    s2=s2,\r\n                                                    carriers_lo1=C1,\r\n                                                    carriers_lo2=C2,\r\n                                                    rf_center_nominal=t.rf_center_hz,\r\n                                                    if1_step=cfg.grids.if1_center_step_hz,\r\n                                                    rf_step=cfg.grids.rf_center_step_hz,\r\n                                                )\r\n\r\n                                                score = robust_margin\r\n\r\n                                                # Construct row for this candidate\r\n                                                row = PlanRow(\r\n                                                    tile_id=t.id,\r\n                                                    if1_center_hz=t.if1_center_hz,\r\n                                                    bw_hz=t.bw_hz,\r\n                                                    rf_center_hz=t.rf_center_hz,\r\n                                                    lo1_name=lo1.name,\r\n                                                    lo1_hz=lo1.f_out_hz,\r\n                                                    lo1_mode=lo1.mode,\r\n                                                    lo1_divider=lo1.divider,\r\n                                                    lo1_pad_db=lo1.pad_db,\r\n                                                    lo1_lock_ms=lo1.lock_time_ms,\r\n                                                    lo2_name=lo2.name,\r\n                                                    lo2_hz=lo2.f_out_hz,\r\n                                                    lo2_mode=lo2.mode,\r\n                                                    lo2_divider=lo2.divider,\r\n                                                    lo2_pad_db=lo2.pad_db,\r\n                                                    lo2_lock_ms=lo2.lock_time_ms,\r\n                                                    if2_center_hz=if2_use.center_hz,\r\n                                                    if2_bw_hz=if2_use.bw_hz,\r\n                                                    rf_bpf_id=rf_filter.id,\r\n                                                    spur_margin_db=score,\r\n                                                    brittleness_db_per_step=brittleness,\r\n                                                    desired_stage1_sign=inj1,\r\n                                                    desired_stage2_sign=s2,\r\n                                                )\r\n\r\n                                                if (best_row is None) or (score > best_score + 1e-9):\r\n                                                    # New best: reset alternatives\r\n                                                    best_row = row\r\n                                                    best_summary = summ\r\n                                                    best_score = score\r\n                                                    alternatives = []\r\n                                                    # capture ledger (bins) for the current best\r\n                                                    best_ledger = {\r\n                                                        \"rf_center_hz\": float(summ.desired_rf_band.center_hz),\r\n                                                        \"rf_bw_hz\": float(summ.desired_rf_band.bw_hz),\r\n                                                        \"bins\": [\r\n                                                            {\r\n                                                                \"f_rf_hz\": b.f_rf_hz,\r\n                                                                \"combined_level_dbc\": b.level_dbc,\r\n                                                                \"inband\": b.inband,\r\n                                                                \"limit_dbc\": b.info.get(\"limit_dbc\"),\r\n                                                                \"margin_db\": b.info.get(\"margin_db\"),\r\n                                                            }\r\n                                                            for b in summ.bins\r\n                                                        ],\r\n                                                    }\r\n                                                else:\r\n                                                    # Track alternatives within Δ dB of best\r\n                                                    if best_row is not None and (best_score - score) <= float(cfg.targets.alt_within_db + 1e-9):\r\n                                                        alternatives.append({\r\n                                                            \"delta_margin_db\": float(best_score - score),\r\n                                                            \"row\": asdict(row),\r\n                                                        })\r\n\r\n    if best_row is None:\r\n        return None\r\n\r\n    # Rank alternatives (smallest delta first)\r\n    alternatives.sort(key=lambda d: d.get(\"delta_margin_db\", 999.0))\r\n    # Attach rank\r\n    for i, a in enumerate(alternatives, 1):\r\n        a[\"rank\"] = i\r\n\r\n    return best_row, alternatives, best_ledger\r\n\r\n\r\n# ---- Retune/lock accounting with Δf and penalties ----------------------------\r\n\r\ndef _mode_lookup(lo_mdl: LOMdl, name: str) -> Optional[Mode]:\r\n    for m in lo_mdl.modes:\r\n        if m.name == name:\r\n            return m\r\n    return lo_mdl.modes[0] if lo_mdl.modes else None\r\n\r\n\r\ndef _lock_time_for_hop(prev_hz: float, prev_mode: str, prev_divider: str,\r\n                       curr_hz: float, curr_mode: str, curr_divider: str,\r\n                       lo_mdl: LOMdl) -> float:\r\n    mode = _mode_lookup(lo_mdl, curr_mode)\r\n    if mode is None:\r\n        return 0.0\r\n    base = float(mode.lock_time_model.base_ms)\r\n    slope = float(getattr(mode.lock_time_model, \"per_mhz_ms\", 0.0))\r\n    df_mhz = abs(curr_hz - prev_hz) / 1e6\r\n    t = base + slope * df_mhz\r\n    # crude penalties for mode/divider changes (if provided)\r\n    penalties = mode.lock_time_model.mode_penalties_ms or {}\r\n    if prev_mode != curr_mode:\r\n        t += float(penalties.get(\"mode_change\", penalties.get(\"int_to_frac\", 0.0)))\r\n    if prev_divider != curr_divider:\r\n        t += float(penalties.get(\"divider_change\", 0.0))\r\n    return t\r\n\r\n\r\ndef _retune_accounting(rows: List[PlanRow], lo_models_by_name: Dict[str, LOMdl]) -> dict:\r\n    \"\"\"\r\n    Uniform traversal retune/lock accounting using hop size and penalties.\r\n    Works even if the LO type changes between rows by using the *destination* row model.\r\n    \"\"\"\r\n    if not rows:\r\n        return {\"total_lock_ms\": 0.0, \"retunes\": 0, \"avg_lock_ms_per_hop\": 0.0}\r\n\r\n    total_lock = 0.0\r\n    retunes = 0\r\n    hops = 0\r\n\r\n    prev = rows[0]\r\n    for r in rows[1:]:\r\n        hops += 1\r\n        changed = False\r\n        # LO1 hop\r\n        if abs(r.lo1_hz - prev.lo1_hz) > 0.5 or (r.lo1_mode != prev.lo1_mode) or (r.lo1_divider != prev.lo1_divider) or (r.lo1_name != prev.lo1_name):\r\n            mdl = lo_models_by_name.get(r.lo1_name)\r\n            if mdl is not None:\r\n                total_lock += _lock_time_for_hop(prev.lo1_hz, prev.lo1_mode, prev.lo1_divider,\r\n                                                 r.lo1_hz, r.lo1_mode, r.lo1_divider, mdl)\r\n            changed = True\r\n        # LO2 hop\r\n        if abs(r.lo2_hz - prev.lo2_hz) > 0.5 or (r.lo2_mode != prev.lo2_mode) or (r.lo2_divider != prev.lo2_divider) or (r.lo2_name != prev.lo2_name):\r\n            mdl = lo_models_by_name.get(r.lo2_name)\r\n            if mdl is not None:\r\n                total_lock += _lock_time_for_hop(prev.lo2_hz, prev.lo2_mode, prev.lo2_divider,\r\n                                                 r.lo2_hz, r.lo2_mode, r.lo2_divider, mdl)\r\n            changed = True\r\n        if changed:\r\n            retunes += 1\r\n        prev = r\r\n\r\n    avg = total_lock / max(1, hops)\r\n    return {\"total_lock_ms\": float(total_lock), \"retunes\": int(retunes), \"avg_lock_ms_per_hop\": float(avg)}\r\n\r\n\r\n# ---- Merge/smoothing (spans) -------------------------------------------------\r\n\r\ndef _same_settings(a: PlanRow, b: PlanRow, eps_hz=500.0) -> bool:\r\n    return (\r\n        a.lo1_name == b.lo1_name and\r\n        a.lo2_name == b.lo2_name and\r\n        abs(a.lo1_hz - b.lo1_hz) < eps_hz and\r\n        abs(a.lo2_hz - b.lo2_hz) < eps_hz and\r\n        a.lo1_mode == b.lo1_mode and\r\n        a.lo2_mode == b.lo2_mode and\r\n        a.lo1_divider == b.lo1_divider and\r\n        a.lo2_divider == b.lo2_divider and\r\n        abs(a.if2_center_hz - b.if2_center_hz) < 1e3 and\r\n        abs(a.if2_bw_hz - b.if2_bw_hz) < 1e3 and\r\n        a.rf_bpf_id == b.rf_bpf_id and\r\n        a.desired_stage1_sign == b.desired_stage1_sign and\r\n        a.desired_stage2_sign == b.desired_stage2_sign\r\n    )\r\n\r\ndef _merge_adjacent(rows: list[PlanRow]) -> list[PlanRow]:\r\n    \"\"\"\r\n    Simple pass: along the sorted tile order, merge consecutive rows with identical settings\r\n    by keeping the one with better margin (acts as a coalescer rather than producing spans).\r\n    \"\"\"\r\n    if not rows:\r\n        return rows\r\n    merged = [rows[0]]\r\n    for r in rows[1:]:\r\n        if _same_settings(merged[-1], r):\r\n            if r.spur_margin_db > merged[-1].spur_margin_db:\r\n                merged[-1] = r\r\n        else:\r\n            merged.append(r)\r\n    return merged\r\n\r\ndef _emit_spans(rows: list[PlanRow]) -> list[dict]:\r\n    \"\"\"\r\n    Produce RF spans for each IF1/BW where settings are identical across consecutive RF tiles.\r\n    This is a 1D run-length merge along RF for each IF1 center; rectangular spans across IF1\r\n    are left for later sophistication.\r\n    \"\"\"\r\n    spans: list[dict] = []\r\n    if not rows:\r\n        return spans\r\n    # Group by (if1_center, bw)\r\n    from collections import defaultdict\r\n    groups: dict[tuple[float,float], list[PlanRow]] = defaultdict(list)\r\n    for r in rows:\r\n        groups[(r.if1_center_hz, r.bw_hz)].append(r)\r\n    for (if1c, bw), gr in groups.items():\r\n        gr_sorted = sorted(gr, key=lambda x: x.rf_center_hz)\r\n        start = gr_sorted[0]\r\n        last = gr_sorted[0]\r\n        for r in gr_sorted[1:]:\r\n            if _same_settings(last, r):\r\n                # continue span\r\n                last = r\r\n            else:\r\n                spans.append({\r\n                    \"if1_center_hz\": float(if1c),\r\n                    \"bw_hz\": float(bw),\r\n                    \"rf_from_hz\": float(start.rf_center_hz),\r\n                    \"rf_to_hz\": float(last.rf_center_hz),\r\n                    \"settings\": {\r\n                        \"lo1_name\": start.lo1_name, \"lo1_hz\": start.lo1_hz, \"lo1_mode\": start.lo1_mode, \"lo1_divider\": start.lo1_divider, \"lo1_pad_db\": start.lo1_pad_db,\r\n                        \"lo2_name\": start.lo2_name, \"lo2_hz\": start.lo2_hz, \"lo2_mode\": start.lo2_mode, \"lo2_divider\": start.lo2_divider, \"lo2_pad_db\": start.lo2_pad_db,\r\n                        \"if2_center_hz\": start.if2_center_hz, \"if2_bw_hz\": start.if2_bw_hz, \"rf_bpf_id\": start.rf_bpf_id,\r\n                        \"desired_stage1_sign\": start.desired_stage1_sign, \"desired_stage2_sign\": start.desired_stage2_sign\r\n                    }\r\n                })\r\n                start = r; last = r\r\n        # flush last span\r\n        spans.append({\r\n            \"if1_center_hz\": float(if1c),\r\n            \"bw_hz\": float(bw),\r\n            \"rf_from_hz\": float(start.rf_center_hz),\r\n            \"rf_to_hz\": float(last.rf_center_hz),\r\n            \"settings\": {\r\n                \"lo1_name\": start.lo1_name, \"lo1_hz\": start.lo1_hz, \"lo1_mode\": start.lo1_mode, \"lo1_divider\": start.lo1_divider, \"lo1_pad_db\": start.lo1_pad_db,\r\n                \"lo2_name\": start.lo2_name, \"lo2_hz\": start.lo2_hz, \"lo2_mode\": start.lo2_mode, \"lo2_divider\": start.lo2_divider, \"lo2_pad_db\": start.lo2_pad_db,\r\n                \"if2_center_hz\": start.if2_center_hz, \"if2_bw_hz\": start.if2_bw_hz, \"rf_bpf_id\": start.rf_bpf_id,\r\n                \"desired_stage1_sign\": start.desired_stage1_sign, \"desired_stage2_sign\": start.desired_stage2_sign\r\n            }\r\n        })\r\n    return spans\r\n\r\n\r\n# ---- Driver ------------------------------------------------------------------\r\n\r\ndef optimize(cfg: Config, models_dir: str, input_files: list[str] | None = None,\r\n             progress_cb: Optional[Callable[[int], None]] = None) -> Dict:\r\n    \"\"\"\r\n    Optimize policy across all tiles in parallel.\r\n    Adds: alternatives-within-ΔdB, robustness perturbations, multi-device search,\r\n    RF passband edge checks, retune accounting with Δf and penalties.\r\n    Export spur ledgers for best per-tile and coverage gaps; broaden LO search windows (P2);\r\n    generate RF spans per IF1/BW (P2); include file hashes and package versions (P1).\r\n    **NEW**: policy-level second-pass selection using retune/lock-time as a tie-breaker among per-tile alternatives.\r\n    \"\"\"\r\n    # Deterministic tiles\r\n    tiles = make_tiles(\r\n        cfg.bands.if1_hz.min,\r\n        cfg.bands.if1_hz.max,\r\n        cfg.bands.rf_hz.min,\r\n        cfg.bands.rf_hz.max,\r\n        cfg.grids.bw_grid_hz,\r\n        cfg.grids.if1_center_step_hz,\r\n        cfg.grids.rf_center_step_hz,\r\n    )\r\n\r\n    # Parallel evaluation\r\n    tasks = [(t, cfg.model_dump(), models_dir) for t in tiles]\r\n    rows: List[PlanRow] = []\r\n    alts_by_tile: dict[int, list[dict]] = {}\r\n    ledgers_by_tile: dict[int, dict] = {}\r\n    gaps: list[dict] = []\r\n\r\n    with ProcessPoolExecutor(max_workers=os.cpu_count()) as ex:\r\n        futs = [ex.submit(_eval_tile, args) for args in tasks]\r\n        for f in as_completed(futs):\r\n            try:\r\n                res = f.result()\r\n                if res is not None:\r\n                    best_row, alts, ledger = res\r\n                    rows.append(best_row)\r\n                    if alts:\r\n                        alts_by_tile[best_row.tile_id] = alts\r\n                    if ledger:\r\n                        ledgers_by_tile[best_row.tile_id] = ledger\r\n                else:\r\n                    # No legal candidate for this tile\r\n                    pass\r\n            finally:\r\n                if progress_cb is not None:\r\n                    try:\r\n                        progress_cb(1)\r\n                    except Exception:\r\n                        pass\r\n\r\n    rows.sort(key=lambda r: r.tile_id)\r\n\r\n    # Identify missing tiles (coverage gaps) and tiles below target margin\r\n    present_ids = {r.tile_id for r in rows}\r\n    all_ids = {t.id for t in tiles}\r\n    missing = sorted(all_ids - present_ids)\r\n    for tid in missing:\r\n        # Recover basic tile info\r\n        t = next(tt for tt in tiles if tt.id == tid)\r\n        gaps.append({\r\n            \"tile_id\": tid,\r\n            \"if1_center_hz\": float(t.if1_center_hz),\r\n            \"bw_hz\": float(t.bw_hz),\r\n            \"rf_center_hz\": float(t.rf_center_hz),\r\n            \"reason\": \"no_legal_candidate\"\r\n        })\r\n    # Low margin\r\n    for r in rows:\r\n        if r.spur_margin_db < float(cfg.targets.min_margin_db):\r\n            gaps.append({\r\n                \"tile_id\": int(r.tile_id),\r\n                \"if1_center_hz\": float(r.if1_center_hz),\r\n                \"bw_hz\": float(r.bw_hz),\r\n                \"rf_center_hz\": float(r.rf_center_hz),\r\n                \"reason\": \"margin_below_target\",\r\n                \"margin_db\": float(r.spur_margin_db),\r\n                \"target_db\": float(cfg.targets.min_margin_db)\r\n            })\r\n\r\n    # ---- NEW: second-pass policy-level selection (tie-break by retune/lock) ----\r\n    # Build LO model lookup by name for hop computations (also used later for accounting)\r\n    lo_models_by_name: Dict[str, LOMdl] = {}\r\n    for path in (cfg.search.lo1_candidates + cfg.search.lo2_candidates):\r\n        mdl = LOMdl(**_load_yaml(models_dir, path))\r\n        lo_models_by_name[mdl.name] = mdl\r\n\r\n    # Create candidate set per tile: best + alternatives (within Δ dB)\r\n    from collections import defaultdict\r\n    candidates_by_tile: dict[int, list[PlanRow]] = defaultdict(list)\r\n    for r in rows:\r\n        candidates_by_tile[r.tile_id].append(r)\r\n    for tid, alts in (alts_by_tile or {}).items():\r\n        for a in alts:\r\n            try:\r\n                candidates_by_tile[int(tid)].append(PlanRow(**a[\"row\"]))\r\n            except Exception:\r\n                # Ignore malformed alternative rows\r\n                pass\r\n\r\n    # Greedy sweep in tile order minimizing cost = -(margin) + λ * hop_lock_ms\r\n    # λ tuned by lock_time_penalty_weight; scale: ~0.1 → 10ms ≈ 1 dB\r\n    lam = max(0.0, float(cfg.runtime_policy.lock_time_penalty_weight))\r\n    lam_scale = 0.1  # ms-to-dB scale\r\n    chosen: list[PlanRow] = []\r\n    prev: PlanRow | None = None\r\n    for t in sorted(candidates_by_tile.keys()):\r\n        candset = candidates_by_tile[t]\r\n        # Stable order: highest margin first as tiebreaker base\r\n        candset.sort(key=lambda c: (-float(c.spur_margin_db), c.lo1_name, c.lo2_name, c.if2_center_hz, c.if2_bw_hz))\r\n        best_c = None\r\n        best_score = -1e18\r\n        for c in candset:\r\n            hop_ms = 0.0\r\n            if prev is not None:\r\n                # LO1 hop cost\r\n                mdl1 = lo_models_by_name.get(c.lo1_name)\r\n                if mdl1 is not None:\r\n                    hop_ms += _lock_time_for_hop(prev.lo1_hz, prev.lo1_mode, prev.lo1_divider,\r\n                                                 c.lo1_hz, c.lo1_mode, c.lo1_divider, mdl1)\r\n                # LO2 hop cost\r\n                mdl2 = lo_models_by_name.get(c.lo2_name)\r\n                if mdl2 is not None:\r\n                    hop_ms += _lock_time_for_hop(prev.lo2_hz, prev.lo2_mode, prev.lo2_divider,\r\n                                                 c.lo2_hz, c.lo2_mode, c.lo2_divider, mdl2)\r\n            score = float(c.spur_margin_db) - lam_scale * lam * hop_ms\r\n            if score > best_score + 1e-12:\r\n                best_score = score\r\n                best_c = c\r\n        if best_c is None:\r\n            # Fallback to the original per-tile best if something went wrong\r\n            best_c = candset[0]\r\n        chosen.append(best_c)\r\n        prev = best_c\r\n\r\n    # Light merge/smoothing (keeps determinism)\r\n    rows = _merge_adjacent(sorted(chosen, key=lambda r: r.tile_id))\r\n\r\n    # Retune/lock-time accounting (uniform traversal) with Δf and penalties\r\n    retune_meta = _retune_accounting(rows, lo_models_by_name)\r\n\r\n    # RF spans (per IF1/BW, along RF)\r\n    spans = _emit_spans(rows)\r\n\r\n    # Hashes and versions\r\n    file_hashes = {}\r\n    for p in (input_files or []):\r\n        try:\r\n            file_hashes[p] = _file_hash(p)\r\n        except Exception:\r\n            file_hashes[p] = \"unavailable\"\r\n    pkg_list = [\"numpy\", \"pandas\", \"scipy\", \"pydantic\", \"pyyaml\", \"jinja2\"]\r\n    versions = {}\r\n    for pkg in pkg_list:\r\n        try:\r\n            versions[pkg] = importlib.metadata.version(pkg)\r\n        except Exception:\r\n            versions[pkg] = \"n/a\"\r\n\r\n    policy = {\r\n        \"project\": cfg.project.model_dump(),\r\n        \"grids\": cfg.grids.model_dump(),\r\n        \"orders\": cfg.orders.model_dump(),\r\n        \"targets\": cfg.targets.model_dump(),\r\n        \"rows\": [asdict(r) for r in rows],\r\n        \"alternatives\": {int(k): v for k, v in alts_by_tile.items() if v},\r\n        \"ledgers\": ledgers_by_tile,  # per-tile best spur bins\r\n        \"spans\": spans,\r\n        \"coverage_gaps\": gaps,\r\n        \"meta\": {\r\n            \"deterministic_seed\": cfg.project.seed,\r\n            \"retune_accounting\": retune_meta,\r\n            \"guard_margin_db\": cfg.constraints.guard_margin_db,\r\n            \"file_hashes\": file_hashes,\r\n            \"package_versions\": versions,\r\n        },\r\n    }\r\n    return policy",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "spur.py",
              "path": "src\\bucso\\spur.py",
              "size": 12240,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Optional\r\nimport numpy as np\r\nfrom .utils import Band, coalesce_bins\r\nfrom .filters import IF2Parametric, RFBPF\r\nfrom .mixer import Mixer\r\nfrom .synth import LOSolution, LOCarrier\r\n\r\n\r\n@dataclass\r\nclass BinEntry:\r\n    __slots__ = (\"f_rf_hz\", \"level_dbc\", \"inband\", \"info\")\r\n    f_rf_hz: float\r\n    level_dbc: float\r\n    inband: bool\r\n    info: dict\r\n\r\n\r\n@dataclass\r\nclass TileSummary:\r\n    worst_margin_db: float\r\n    bins: List[BinEntry]\r\n    desired_rf_band: Band\r\n\r\n\r\ndef rbw_width(cfg_rb, bw_hz: float, freq_hz: float) -> float:\r\n    return max(cfg_rb.rbw_hz, cfg_rb.rbw_frac_of_bw * bw_hz, cfg_rb.rbw_ppm_of_freq * freq_hz * 1e-6)\r\n\r\n\r\ndef desired_paths(tile_if1: Band, lo1: float, lo2: float, inj1: int, s2_sign: int) -> tuple[Band, Band]:\r\n    \"\"\"\r\n    Desired path with explicit signs:\r\n      Stage-1 desired: IF2 = | inj1*LO1  -  IF1 |\r\n      Stage-2 desired:  RF  = | s2_sign*LO2  +  IF2 |\r\n    Centers are magnitudes.\r\n    \"\"\"\r\n    if2_center = abs(inj1 * lo1 - tile_if1.center_hz)\r\n    if2 = Band(center_hz=if2_center, bw_hz=tile_if1.bw_hz)\r\n    rf_center = abs(s2_sign * lo2 + if2.center_hz)\r\n    rf = Band(center_hz=rf_center, bw_hz=if2.bw_hz)\r\n    return if2, rf\r\n\r\n\r\ndef _in_if2_passband(f_hz: float, if2: IF2Parametric) -> bool:\r\n    return abs(f_hz - if2.center_hz) <= (if2.bw_hz / 2.0)\r\n\r\n\r\ndef _interp_mask_flat_or_table(default_dbc: float, table, x: np.ndarray, *, is_oob_abs_freq: bool) -> np.ndarray:\r\n    \"\"\"\r\n    Returns a vector of limits starting from default_dbc, optionally overridden by a table.\r\n    For in-band: x is offset-from-edge (>=0). For OOB: x is absolute frequency.\r\n    IMPORTANT: np.interp left/right must be scalars, not arrays.\r\n    \"\"\"\r\n    limits = np.full_like(x, float(default_dbc), dtype=float)\r\n    if not table:\r\n        return limits\r\n    try:\r\n        axis = np.array([e.offset_hz for e in table], float)\r\n        vals = np.array([e.limit_dbc for e in table], float)\r\n    except Exception:\r\n        # tolerate dict-like entries\r\n        axis = np.array([e.get(\"offset_hz\") for e in table], float)\r\n        vals = np.array([e.get(\"limit_dbc\") for e in table], float)\r\n    if axis.size and vals.size:\r\n        left = float(vals[0])\r\n        right = float(vals[-1])\r\n        lim = np.interp(x, axis, vals, left=left, right=right)\r\n        return lim\r\n    return limits\r\n\r\n\r\ndef enumerate_spurs(\r\n    tile_if1: Band,\r\n    lo1_sol: LOSolution,\r\n    lo2_sol: LOSolution,\r\n    if2win: IF2Parametric,\r\n    rf_filter: RFBPF,\r\n    mix1: Mixer,\r\n    mix2: Mixer,\r\n    cfg,\r\n    inj1_sign: int,\r\n    s2_sign: int,\r\n    carriers_lo1: List[LOCarrier],\r\n    carriers_lo2: List[LOCarrier],\r\n    *,\r\n    rf_center_override_hz: Optional[float] = None,\r\n    rf_bw_override_hz: Optional[float] = None,\r\n) -> TileSummary:\r\n    \"\"\"\r\n    Main spur enumeration with band-affine widths:\r\n      - LO family carriers + order-aware family scaling (both stages)\r\n      - Stage-1 specials (LO1 feedthrough, IF1 leakage) propagated through Stage-2\r\n      - LO2 feedthroughs (fundamental + harmonics) at RF\r\n      - Skips the *desired* mechanism from being counted as a spur\r\n      - Supports flat/tabled masks\r\n      - Correct ± signs on IF terms in both stages\r\n      - Optional rf_center/bw override to assess robustness to RF-request perturbations\r\n      - OOB evaluation uses cfg RF band (S21 extrapolation allowed)\r\n      - **Band-affine ΔA**: uses worst-of-edges attenuation deltas for conservative scoring\r\n    \"\"\"\r\n    # Desired bands\r\n    if2_des, rf_des_nom = desired_paths(tile_if1, lo1_sol.f_out_hz, lo2_sol.f_out_hz, inj1_sign, s2_sign)\r\n\r\n    # Optional override for mask/inband reference (robustness sweeps)\r\n    rf_des = rf_des_nom\r\n    if rf_center_override_hz is not None:\r\n        rf_des = Band(center_hz=float(rf_center_override_hz), bw_hz=rf_bw_override_hz or rf_des_nom.bw_hz)\r\n\r\n    # RBW bin width\r\n    bin_w = rbw_width(cfg.rbw_binning, rf_des.bw_hz, rf_des.center_hz)\r\n\r\n    # Bind hot callables\r\n    rf_attn = rf_filter.attn_at\r\n    if2_attn = if2win.attn_at\r\n    rej1 = mix1.rejection_dbc\r\n    der1 = mix1.drive_derate_db\r\n    rej2 = mix2.rejection_dbc\r\n    der2 = mix2.drive_derate_db\r\n    fam1 = mix1.family_scale_db\r\n    fam2 = mix2.family_scale_db\r\n\r\n    rf_attn_des = float(rf_attn(rf_des.center_hz))\r\n    if2_attn_des = float(if2_attn(if2_des.center_hz))\r\n\r\n    # RF span guard (use config RF band; S21 extrapolates beyond file)\r\n    rf_lo = float(cfg.bands.rf_hz.min)\r\n    rf_hi = float(cfg.bands.rf_hz.max)\r\n\r\n    freq_list: list[float] = []\r\n    level_list: list[float] = []\r\n\r\n    def worst_delta(attn_func, center: float, half_width: float, des_attn: float) -> float:\r\n        \"\"\"\r\n        Conservative ΔA: worst (largest) attenuation at the two band edges minus desired attenuation.\r\n        \"\"\"\r\n        if half_width <= 0:\r\n            return float(attn_func(abs(center))) - des_attn\r\n        a_lo = float(attn_func(abs(center - half_width)))\r\n        a_hi = float(attn_func(abs(center + half_width)))\r\n        return max(a_lo, a_hi) - des_attn\r\n\r\n    # Stage-1 spur indices (exclude n1=0 per model; treat images via signs)\r\n    m1s = [m for m in range(-cfg.orders.m1n1_max_abs, cfg.orders.m1n1_max_abs + 1) if m != 0]\r\n    n1s = range(1, cfg.orders.m1n1_max_abs + 1)\r\n\r\n    for m1 in m1s:\r\n        for n1 in n1s:\r\n            base_L1 = rej1(m1, n1, lo1_sol.f_out_hz, tile_if1.center_hz) + der1(lo1_sol.delivered_dbm)\r\n            for c1 in carriers_lo1:\r\n                for sgn1 in (+1, -1):  # include ± on IF1 term\r\n                    # Stage-1 band parameters\r\n                    f_if2_c_raw = m1 * c1.freq_hz + sgn1 * n1 * tile_if1.center_hz\r\n                    f_if2_c = abs(f_if2_c_raw)\r\n                    w_if2 = abs(n1) * (tile_if1.bw_hz * 0.5)\r\n\r\n                    # ΔA at IF2: worst of the edges minus desired\r\n                    dA_if2 = float(worst_delta(if2_attn, f_if2_c_raw, w_if2, if2_attn_des))\r\n                    # Family scaling (order-aware, capped)\r\n                    L1 = base_L1 + fam1(abs(m1), c1.rel_dBc)\r\n\r\n                    for m2 in range(-cfg.orders.m2n2_max_abs, cfg.orders.m2n2_max_abs + 1):\r\n                        if m2 == 0:\r\n                            continue\r\n                        for n2 in range(1, cfg.orders.m2n2_max_abs + 1):\r\n                            if abs(m1) + abs(n1) + abs(m2) + abs(n2) > cfg.orders.cross_stage_sum_max:\r\n                                continue\r\n\r\n                            base_L2 = rej2(m2, n2, lo2_sol.f_out_hz, f_if2_c) + der2(lo2_sol.delivered_dbm)\r\n                            for c2 in carriers_lo2:\r\n                                for sgn2 in (+1, -1):  # include ± on IF2 term for stage-2\r\n                                    L2 = base_L2 + fam2(abs(m2), c2.rel_dBc)\r\n                                    # Stage-2 band parameters\r\n                                    f_rf_c_raw = m2 * c2.freq_hz + sgn2 * n2 * f_if2_c_raw\r\n                                    f_rf_c = abs(f_rf_c_raw)\r\n                                    w_rf = abs(n2) * w_if2\r\n\r\n                                    # Skip outside a padded RF span for speed\r\n                                    if (f_rf_c < rf_lo - 2 * bin_w) or (f_rf_c > rf_hi + 2 * bin_w):\r\n                                        continue\r\n\r\n                                    # *** Skip the exact desired mechanism counted as spur ***\r\n                                    if (\r\n                                        (m1 == inj1_sign)\r\n                                        and (n1 == 1)\r\n                                        and (c1.tag == \"main\")\r\n                                        and (m2 == s2_sign)\r\n                                        and (n2 == 1)\r\n                                        and (c2.tag == \"main\")\r\n                                        and (abs(f_rf_c - rf_des_nom.center_hz) <= bin_w * 0.5)\r\n                                    ):\r\n                                        continue\r\n\r\n                                    # ΔA at RF: worst-of-edges minus desired\r\n                                    dA_rf = float(worst_delta(rf_attn, f_rf_c_raw, w_rf, rf_attn_des))\r\n\r\n                                    freq_list.append(f_rf_c)\r\n                                    level_list.append(L1 + dA_if2 + L2 + dA_rf)\r\n\r\n    # Stage-1 specials at IF2 output → propagate through Stage-2\r\n    # LO1 feedthrough at IF2 out (treat as a tone; no band)\r\n    f_lo1 = lo1_sol.f_out_hz\r\n    L_lo1_if2 = mix1.mdl.isolation.lo_to_rf_db + (float(if2_attn(f_lo1)) - if2_attn_des)\r\n    for m2 in range(-cfg.orders.m2n2_max_abs, cfg.orders.m2n2_max_abs + 1):\r\n        if m2 == 0:\r\n            continue\r\n        for n2 in range(1, cfg.orders.m2n2_max_abs + 1):\r\n            if abs(m2) + n2 > cfg.orders.cross_stage_sum_max:\r\n                continue\r\n            base_L2 = rej2(m2, n2, lo2_sol.f_out_hz, f_lo1) + der2(lo2_sol.delivered_dbm)\r\n            for c2 in carriers_lo2:\r\n                for sgn2 in (+1, -1):\r\n                    L2 = base_L2 + fam2(abs(m2), c2.rel_dBc)\r\n                    f_rf = abs(m2 * c2.freq_hz + sgn2 * n2 * (+f_lo1))\r\n                    if (f_rf < rf_lo - 2 * bin_w) or (f_rf > rf_hi + 2 * bin_w):\r\n                        continue\r\n                    dA_rf = float(rf_attn(f_rf) - rf_attn_des)\r\n                    freq_list.append(f_rf)\r\n                    level_list.append(L_lo1_if2 + L2 + dA_rf)\r\n\r\n    # IF1 leakage at IF2 out (center only)\r\n    f_if1 = tile_if1.center_hz\r\n    L_if1_if2 = mix1.mdl.isolation.if_to_rf_db + (float(if2_attn(f_if1)) - if2_attn_des)\r\n    for m2 in range(-cfg.orders.m2n2_max_abs, cfg.orders.m2n2_max_abs + 1):\r\n        if m2 == 0:\r\n            continue\r\n        for n2 in range(1, cfg.orders.m2n2_max_abs + 1):\r\n            if abs(m2) + n2 > cfg.orders.cross_stage_sum_max:\r\n                continue\r\n            base_L2 = rej2(m2, n2, lo2_sol.f_out_hz, f_if1) + der2(lo2_sol.delivered_dbm)\r\n            for c2 in carriers_lo2:\r\n                for sgn2 in (+1, -1):\r\n                    L2 = base_L2 + fam2(abs(m2), c2.rel_dBc)\r\n                    f_rf = abs(m2 * c2.freq_hz + sgn2 * n2 * (+f_if1))\r\n                    if (f_rf < rf_lo - 2 * bin_w) or (f_rf > rf_hi + 2 * bin_w):\r\n                        continue\r\n                    dA_rf = float(rf_attn(f_rf) - rf_attn_des)\r\n                    freq_list.append(f_rf)\r\n                    level_list.append(L_if1_if2 + L2 + dA_rf)\r\n\r\n    # LO2 feedthroughs at RF: include main + harmonics (use isolation plus carrier rel_dBc)\r\n    for c2 in carriers_lo2:\r\n        f = c2.freq_hz\r\n        if (rf_lo - 2 * bin_w) <= f <= (rf_hi + 2 * bin_w):\r\n            L = mix2.mdl.isolation.lo_to_rf_db + c2.rel_dBc + (float(rf_attn(f)) - rf_attn_des)\r\n            freq_list.append(f)\r\n            level_list.append(L)\r\n\r\n    # Coalesce by RBW window\r\n    freqs = np.asarray(freq_list, dtype=float)\r\n    levs = np.asarray(level_list, dtype=float)\r\n    cf, cL = coalesce_bins(freqs, levs, bin_w)\r\n\r\n    # Margins vs masks (flat or offset-dependent)\r\n    inband_mask = np.abs(cf - rf_des.center_hz) <= (rf_des.bw_hz / 2.0 + bin_w / 2.0)\r\n\r\n    # In-band limits: default or table vs offset-from-edge (>=0 inside band is 0)\r\n    edge = rf_des.bw_hz / 2.0\r\n    offsets_edge = np.clip(np.abs(cf - rf_des.center_hz) - edge, 0.0, None)\r\n    lim_in = _interp_mask_flat_or_table(\r\n        cfg.masks.inband.default_dbc, cfg.masks.inband.table, offsets_edge, is_oob_abs_freq=False\r\n    )\r\n\r\n    # Out-of-band limits: default or table vs absolute frequency\r\n    lim_oob = _interp_mask_flat_or_table(\r\n        cfg.masks.outofband.default_dbc, cfg.masks.outofband.table, cf, is_oob_abs_freq=True\r\n    )\r\n\r\n    limits = np.where(inband_mask, lim_in, lim_oob).astype(float)\r\n    margins = limits - cL - cfg.constraints.guard_margin_db\r\n    worst = float(np.min(margins)) if margins.size else -999.0\r\n\r\n    final_bins: list[BinEntry] = [\r\n        BinEntry(float(f), float(L), bool(inb), {\"limit_dbc\": float(lim), \"margin_db\": float(mar)})\r\n        for f, L, inb, lim, mar in zip(cf, cL, inband_mask, limits, margins)\r\n    ]\r\n\r\n    return TileSummary(worst_margin_db=worst, bins=final_bins, desired_rf_band=rf_des)\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "synth.py",
              "path": "src\\bucso\\synth.py",
              "size": 9372,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Dict, Iterable, Tuple, Optional\r\nimport numpy as np\r\nfrom .models import LOMdl, Mode\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass LOCarrier:\r\n    freq_hz: float\r\n    rel_dBc: float  # relative to main tone at mixer input\r\n    tag: str        # \"main\", \"harm2\", \"pfd_k1\", ...\r\n\r\n\r\n@dataclass\r\nclass LOSolution:\r\n    name: str\r\n    mode: str\r\n    f_out_hz: float\r\n    divider: str\r\n    delivered_dbm: float\r\n    lock_time_ms: float\r\n    pad_db: float  # which pad choice produced delivered_dbm (for legality)\r\n    # PFD info (P2): derived from ref and pfd_divider legality\r\n    pfd_hz: float\r\n    pfd_divider: int\r\n\r\n\r\nclass Synth:\r\n    def __init__(self, mdl: LOMdl):\r\n        self.mdl = mdl\r\n\r\n    def output_power_dbm(self, f_out_hz: float, divider: str) -> float:\r\n        t = self.mdl.output_power_model.table\r\n        fv = np.array(t[\"freq_hz\"], float)\r\n        pv = np.array(t[\"p_out_dbm\"], float)\r\n        p = float(np.interp(f_out_hz, fv, pv))\r\n        p += self.mdl.output_power_model.divider_adjust_db.get(divider, 0.0)\r\n        return p\r\n\r\n    def delivered_drive_dbm(self, f_out_hz: float, divider: str, path: str, pad_db: float) -> float:\r\n        p = self.output_power_dbm(f_out_hz, divider)\r\n        loss = self.mdl.distribution.path_losses_db.get(path, 0.0)\r\n        return p - loss - pad_db\r\n\r\n    def equivalent_carriers(\r\n        self,\r\n        f_out_hz: float,\r\n        mode: Mode,\r\n        divider: str,\r\n        pfd_hz: float | None = None,\r\n    ) -> List[LOCarrier]:\r\n        \"\"\"\r\n        Build equivalent LO carriers at the *output* (post-divider) with relative levels.\r\n        Apply divider-spectrum harmonic deltas to harmonics.\r\n        \"\"\"\r\n        carriers: List[LOCarrier] = [LOCarrier(f_out_hz, 0.0, \"main\")]\r\n\r\n        harm_delta = self.mdl.divider_spectrum.get(divider, None)\r\n        harm_boost = 0.0 if harm_delta is None else float(harm_delta.harm_delta_dBc)\r\n\r\n        # Harmonics at output (datasheet gives relative at output already).\r\n        for h in (mode.harmonics_at_output or []):\r\n            # Apply divider-spectrum delta to reflect folding behavior\r\n            rel = float(h.rel_dBc) + harm_boost\r\n            carriers.append(LOCarrier(h.k * f_out_hz, rel, f\"harm{h.k}\"))\r\n\r\n        # Basic PFD families, if present.\r\n        fams = None\r\n        if isinstance(mode.pfd_spurs_at_output, dict):\r\n            fams = mode.pfd_spurs_at_output.get(\"families\", [])\r\n        if fams and pfd_hz and pfd_hz > 0:\r\n            for fam in fams:\r\n                for comp in fam.components:\r\n                    for sgn in (+1, -1):\r\n                        f = f_out_hz + sgn * comp.k * float(pfd_hz)\r\n                        carriers.append(LOCarrier(f, float(comp.base_rel_dBc), f\"pfd{comp.k}\"))\r\n\r\n        # Optional fractional-N boundary spur envelope (crude envelope)\r\n        env = getattr(mode, \"frac_boundary_spurs\", None)\r\n        if isinstance(env, dict) and env.get(\"enabled\", False) and pfd_hz and pfd_hz > 0:\r\n            amp = float(env.get(\"amplitude_at_eps0p5_rel_dBc\", -58))\r\n            for sgn in (+1, -1):\r\n                carriers.append(LOCarrier(f_out_hz + sgn * 0.5 * float(pfd_hz), amp, \"frac_boundary\"))\r\n\r\n        return carriers\r\n\r\n    def _best_pad_within_drive(\r\n        self,\r\n        f_out_hz: float,\r\n        divider: str,\r\n        path: str,\r\n        min_dbm: float,\r\n        max_dbm: float,\r\n    ) -> Optional[Tuple[float, float]]:\r\n        \"\"\"\r\n        Return (pad_db, delivered_dbm) choosing a pad that keeps delivered drive within [min,max].\r\n        If not possible, return None.\r\n        \"\"\"\r\n        best: Optional[Tuple[float, float]] = None\r\n        for pad in self.mdl.distribution.pad_options_db:\r\n            delivered = self.delivered_drive_dbm(f_out_hz, divider, path, pad)\r\n            if (delivered >= min_dbm) and (delivered <= max_dbm):\r\n                # Choose the *largest* pad that still meets min (to keep headroom)\r\n                if (best is None) or (pad > best[0]):\r\n                    best = (float(pad), float(delivered))\r\n        return best\r\n\r\n    def _choose_pfd(self, mode: Mode) -> tuple[float, int] | None:\r\n        \"\"\"Pick a legal PFD given ref constraints and mode pfd_dividers and range (choose largest PFD within range).\"\"\"\r\n        refs = list(self.mdl.ref_constraints.get(\"allowed_refs_hz\", []) or [])\r\n        if not refs:\r\n            return None\r\n        # Highest PFD within range is often better (fewer frac spurs)\r\n        best: tuple[float, int] | None = None\r\n        for ref in refs:\r\n            for div in (mode.pfd_dividers or []):\r\n                f_pfd = float(ref) / float(div)\r\n                lo, hi = float(mode.pfd_hz_range[0]), float(mode.pfd_hz_range[1])\r\n                if lo <= f_pfd <= hi:\r\n                    if (best is None) or (f_pfd > best[0]):\r\n                        best = (f_pfd, int(div))\r\n        return best\r\n\r\n    def legal_settings(\r\n        self, *, name_filter: Iterable[str] | None, f_min: float, f_max: float, path: str,\r\n        drive_min_dbm: float | None = None, drive_max_dbm: float | None = None\r\n    ) -> List[LOSolution]:\r\n        \"\"\"Enumerate legal LO grid points (post-divider) with available VCO dividers from mode.vco_dividers.\r\n        Enforce PFD legality vs allowed refs and mode pfd_hz_range.\r\n        \"\"\"\r\n        out: List[LOSolution] = []\r\n        step = float(self.mdl.step_hz)\r\n        f0 = max(self.mdl.freq_range_hz[0], f_min)\r\n        f1 = min(self.mdl.freq_range_hz[1], f_max)\r\n        if f0 > f1:\r\n            return out\r\n\r\n        for mode in self.mdl.modes:\r\n            if not mode.enabled:\r\n                continue\r\n\r\n            pfd_sel = self._choose_pfd(mode)\r\n            if pfd_sel is None:\r\n                continue\r\n            f_pfd, pfd_divider = pfd_sel\r\n\r\n            vco_divs = mode.vco_dividers or [1]\r\n            for vdiv in vco_divs:\r\n                divider = f\"/{int(vdiv)}\"\r\n                f = float(np.ceil(f0 / step) * step)\r\n                while f <= f1 + 1e-9:\r\n                    if (drive_min_dbm is not None) and (drive_max_dbm is not None):\r\n                        pad_sel = self._best_pad_within_drive(f, divider, path, drive_min_dbm, drive_max_dbm)\r\n                        if pad_sel is None:\r\n                            f += step\r\n                            continue\r\n                        pad_db, delivered = pad_sel\r\n                    else:\r\n                        # fall back: pick pad giving maximum delivered\r\n                        pad_db = max(self.mdl.distribution.pad_options_db or [0.0])\r\n                        delivered = self.delivered_drive_dbm(f, divider, path, pad_db)\r\n                    out.append(LOSolution(\r\n                        name=self.mdl.name, mode=mode.name, f_out_hz=f,\r\n                        divider=divider, delivered_dbm=float(delivered),\r\n                        lock_time_ms=float(mode.lock_time_model.base_ms),\r\n                        pad_db=float(pad_db),\r\n                        pfd_hz=float(f_pfd), pfd_divider=int(pfd_divider)\r\n                    ))\r\n                    f += step\r\n        return out\r\n\r\n    def snap_to_legal(\r\n        self, f_target: float, path: str, window_steps: int = 2,\r\n        drive_min_dbm: float | None = None, drive_max_dbm: float | None = None\r\n    ) -> LOSolution | None:\r\n        \"\"\"Snap a target to nearest legal grid ±window_steps over all modes/dividers, enforcing PFD legality.\"\"\"\r\n        step = float(self.mdl.step_hz)\r\n        if step <= 0:\r\n            return None\r\n        grid = [round(f_target / step) * step + k * step for k in range(-window_steps, window_steps + 1)]\r\n\r\n        best: Optional[LOSolution] = None\r\n        best_del = -1e9\r\n\r\n        for mode in self.mdl.modes:\r\n            if not mode.enabled:\r\n                continue\r\n            pfd_sel = self._choose_pfd(mode)\r\n            if pfd_sel is None:\r\n                continue\r\n            f_pfd, pfd_divider = pfd_sel\r\n\r\n            vco_divs = mode.vco_dividers or [1]\r\n            for vdiv in vco_divs:\r\n                divider = f\"/{int(vdiv)}\"\r\n                for f in grid:\r\n                    if not (self.mdl.freq_range_hz[0] <= f <= self.mdl.freq_range_hz[1]):\r\n                        continue\r\n                    if (drive_min_dbm is not None) and (drive_max_dbm is not None):\r\n                        pad_sel = self._best_pad_within_drive(f, divider, path, drive_min_dbm, drive_max_dbm)\r\n                        if pad_sel is None:\r\n                            continue\r\n                        pad_db, delivered = pad_sel\r\n                    else:\r\n                        pad_db = max(self.mdl.distribution.pad_options_db or [0.0])\r\n                        delivered = self.delivered_drive_dbm(f, divider, path, pad_db)\r\n\r\n                    if delivered > best_del:\r\n                        best_del = delivered\r\n                        best = LOSolution(\r\n                            name=self.mdl.name, mode=mode.name, f_out_hz=float(f),\r\n                            divider=divider, delivered_dbm=float(delivered),\r\n                            lock_time_ms=float(mode.lock_time_model.base_ms),\r\n                            pad_db=float(pad_db),\r\n                            pfd_hz=float(f_pfd), pfd_divider=int(pfd_divider)\r\n                        )\r\n        return best\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "tiling.py",
              "path": "src\\bucso\\tiling.py",
              "size": 884,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import Iterable, List\r\nimport numpy as np\r\nfrom .utils import Band\r\n\r\n@dataclass(frozen=True)\r\nclass Tile:\r\n    id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n\r\ndef make_tiles(if1_min, if1_max, rf_min, rf_max, bw_list, if1_step, rf_step) -> List[Tile]:\r\n    tiles: List[Tile] = []\r\n    tid = 0\r\n    for bw in bw_list:\r\n        cmin = if1_min + bw/2\r\n        cmax = if1_max - bw/2\r\n        if cmin > cmax:\r\n            continue\r\n        if1_cs = np.arange(cmin, cmax + 0.5*if1_step, if1_step)\r\n        rf_cs = np.arange(rf_min, rf_max + 0.5*rf_step, rf_step)\r\n        for ic in if1_cs:\r\n            for rc in rf_cs:\r\n                tiles.append(Tile(id=tid, if1_center_hz=float(ic), bw_hz=float(bw), rf_center_hz=float(rc)))\r\n                tid += 1\r\n    return tiles\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "utils.py",
              "path": "src\\bucso\\utils.py",
              "size": 1671,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import Iterable, Tuple\r\nimport numpy as np\r\n\r\n\r\ndef db_to_lin(db: float) -> float:\r\n    return 10 ** (db / 10.0)\r\n\r\n\r\ndef lin_to_db(lin: float) -> float:\r\n    if lin <= 0:\r\n        return -300.0\r\n    return 10.0 * np.log10(lin)\r\n\r\n\r\ndef clamp(x: float, lo: float, hi: float) -> float:\r\n    return max(lo, min(hi, x))\r\n\r\n\r\ndef power_sum_db(levels_db: Iterable[float]) -> float:\r\n    return lin_to_db(sum(db_to_lin(v) for v in levels_db if v is not None))\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass Band:\r\n    center_hz: float\r\n    bw_hz: float\r\n\r\n    @property\r\n    def f_lo(self) -> float:\r\n        return self.center_hz - self.bw_hz / 2\r\n\r\n    @property\r\n    def f_hi(self) -> float:\r\n        return self.center_hz + self.bw_hz / 2\r\n\r\n    def contains(self, f: float) -> bool:\r\n        return self.f_lo <= f <= self.f_hi\r\n\r\n\r\ndef coalesce_bins(freqs: np.ndarray, levels_db: np.ndarray, bin_width_hz: float):\r\n    \"\"\"Return (bin_centers, summed_levels_db) with simple sliding coalescing.\"\"\"\r\n    if freqs is None or levels_db is None or len(freqs) == 0:\r\n        return np.array([]), np.array([])\r\n    order = np.argsort(freqs)\r\n    freqs = freqs[order]\r\n    levels_db = levels_db[order]\r\n    bins_f = [freqs[0]]\r\n    bins_lin = [db_to_lin(levels_db[0])]\r\n    last_f = freqs[0]\r\n    for f, L in zip(freqs[1:], levels_db[1:]):\r\n        if abs(f - last_f) <= bin_width_hz:\r\n            bins_lin[-1] += db_to_lin(L)\r\n        else:\r\n            bins_f.append(f)\r\n            bins_lin.append(db_to_lin(L))\r\n        last_f = f\r\n    return np.array(bins_f), np.array([lin_to_db(v) for v in bins_lin])\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            }
          ]
        }
      ]
    },
    {
      "type": "file",
      "name": ".gitignore",
      "path": ".gitignore",
      "size": 109,
      "content_truncated": false,
      "contents": "# Python-generated files\n__pycache__/\n*.py[oc]\nbuild/\ndist/\nwheels/\n*.egg-info\n\n# Virtual environments\n.venv\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": ".python-version",
      "path": ".python-version",
      "size": 5,
      "content_truncated": false,
      "contents": "3.13\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "pyproject.toml",
      "path": "pyproject.toml",
      "size": 483,
      "content_truncated": false,
      "contents": "[project]\nname = \"bucso\"\nversion = \"0.1.0\"\ndescription = \"Dual-conversion BUC spur optimization tool\"\nreadme = \"README.md\"\nrequires-python = \">=3.13\"\n\ndependencies = [\n  \"pydantic>=2.9\",\n  \"pydantic-settings>=2.5\",\n  \"pyyaml>=6.0.2\",\n  \"typer>=0.12\",\n  \"rich>=13.8\",\n  \"numpy>=2.1\",\n  \"pandas>=2.2\",\n  \"scipy>=1.14\",\n  \"jinja2>=3.1\",\n  \"pytest>=8.4.2\",\n]\n\n[project.scripts]\nbucso = \"bucso.cli:app\"\n\n[tool.pytest.ini_options]\naddopts = \"-q\"\npythonpath = [\"src\"]\ntestpaths = [\"tests\"]\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "README.md",
      "path": "README.md",
      "size": 327,
      "content_truncated": false,
      "contents": "# bucso — Dual-Conversion BUC Spur Optimization\r\n\r\nPython 3.13 + uv.\r\n\r\n## Quick start\r\n\r\n```bash\r\nuv venv && source .venv/bin/activate\r\nuv pip install -e .\r\nbucso init-stubs examples/\r\nbucso validate examples/config.yaml\r\nbucso optimize examples/config.yaml --out out/\r\nbucso report out/policy.yaml --html out/summary.html\r\n",
      "encoding": "utf-8",
      "encoding_error": false
    }
  ]
}

---

uv run project_tree.py . --uv-default-excludes --with-contents --pretty -o project_tree_out.json