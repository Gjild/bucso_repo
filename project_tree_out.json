{
  "type": "directory",
  "name": "bucso_repo",
  "path": ".",
  "children": [
    {
      "type": "directory",
      "name": "src",
      "path": "src",
      "children": [
        {
          "type": "directory",
          "name": "bucso",
          "path": "src\\bucso",
          "children": [
            {
              "type": "file",
              "name": "__init__.py",
              "path": "src\\bucso\\__init__.py",
              "size": 0,
              "content_truncated": false,
              "contents": "",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "cli.py",
              "path": "src\\bucso\\cli.py",
              "size": 15302,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nimport os, sys, json, yaml, hashlib\r\nfrom pathlib import Path\r\nimport typer\r\nfrom rich import print\r\nfrom rich.table import Table\r\nfrom rich.progress import Progress, BarColumn, TimeElapsedColumn, TimeRemainingColumn, MofNCompleteColumn, SpinnerColumn\r\n\r\nfrom .models import Config\r\nfrom .policy import optimize as optimize_policy\r\nfrom .tiling import make_tiles\r\n\r\napp = typer.Typer(no_args_is_help=True)\r\n\r\n@app.command()\r\ndef init_stubs(dst: str = \"examples\"):\r\n    \"\"\"Write example YAML/CSV stubs.\"\"\"\r\n    p = Path(dst)\r\n    p.mkdir(parents=True, exist_ok=True)\r\n    (p/\"config.yaml\").write_text(EXAMPLE_CONFIG)\r\n    (p/\"MXR1.yaml\").write_text(EXAMPLE_MIXER)\r\n    (p/\"MXR2.yaml\").write_text(EXAMPLE_MIXER2)\r\n    (p/\"LMX2595_A.yaml\").write_text(EXAMPLE_LO)\r\n    (p/\"LMX2592_A.yaml\").write_text(EXAMPLE_LO2)\r\n    (p/\"IF2_Model_01.yaml\").write_text(EXAMPLE_IF2)\r\n    (p/\"RF_S21_28to31GHz.csv\").write_text(EXAMPLE_RF_CSV)\r\n    print(f\"[green]Stub inputs written to {p}[/green]\")\r\n\r\ndef _resolve_model_paths(cfg: Config, cfg_path: str) -> list[str]:\r\n    \"\"\"Collect absolute file paths for hashing/metadata.\"\"\"\r\n    base = Path(cfg_path).parent.resolve()\r\n    files: list[str] = [str(Path(cfg_path).resolve())]\r\n\r\n    def _abspath(p):\r\n        return str((p if os.path.isabs(p) else base / p).resolve())\r\n\r\n    files.extend(_abspath(p) for p in cfg.search.mixer1_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.mixer2_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.lo1_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.lo2_candidates)\r\n    files.extend(_abspath(p) for p in cfg.search.rf_bpf_choices)\r\n    files.append(_abspath(cfg.search.if2_filter_model))\r\n    # de-dup and keep deterministic order\r\n    files = sorted(set(files))\r\n    return files\r\n\r\ndef _write_runtime_selector(dst_py: Path, hysteresis_hz: float):\r\n    \"\"\"Emit a simple runtime selector π that loads policy.csv and applies hysteresis.\"\"\"\r\n    code = f'''# Auto-generated runtime selector (π)\r\nfrom __future__ import annotations\r\nimport csv\r\nfrom dataclasses import dataclass\r\nfrom pathlib import Path\r\n\r\nHYSTERESIS_HZ = {hysteresis_hz:.1f}\r\n\r\n@dataclass(frozen=True)\r\nclass Row:\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n    lo1_name: str\r\n    lo1_hz: float\r\n    lo1_mode: str\r\n    lo1_divider: str\r\n    lo1_pad_db: float\r\n    lo2_name: str\r\n    lo2_hz: float\r\n    lo2_mode: str\r\n    lo2_divider: str\r\n    lo2_pad_db: float\r\n    if2_center_hz: float\r\n    if2_bw_hz: float\r\n    rf_bpf_id: str\r\n    spur_margin_db: float\r\n    desired_stage1_sign: int\r\n    desired_stage2_sign: int\r\n\r\ndef load_policy_csv(path: str | Path) -> list[Row]:\r\n    rows: list[Row] = []\r\n    with open(path, \"r\", newline=\"\") as f:\r\n        for r in csv.DictReader(f):\r\n            rows.append(Row(\r\n                if1_center_hz=float(r[\"if1_center_hz\"]),\r\n                bw_hz=float(r[\"bw_hz\"]),\r\n                rf_center_hz=float(r[\"rf_center_hz\"]),\r\n                lo1_name=r[\"lo1_name\"],\r\n                lo1_hz=float(r[\"lo1_hz\"]),\r\n                lo1_mode=r[\"lo1_mode\"],\r\n                lo1_divider=r[\"lo1_divider\"],\r\n                lo1_pad_db=float(r[\"lo1_pad_db\"]),\r\n                lo2_name=r[\"lo2_name\"],\r\n                lo2_hz=float(r[\"lo2_hz\"]),\r\n                lo2_mode=r[\"lo2_mode\"],\r\n                lo2_divider=r[\"lo2_divider\"],\r\n                lo2_pad_db=float(r[\"lo2_pad_db\"]),\r\n                if2_center_hz=float(r[\"if2_center_hz\"]),\r\n                if2_bw_hz=float(r[\"if2_bw_hz\"]),\r\n                rf_bpf_id=r[\"rf_bpf_id\"],\r\n                spur_margin_db=float(r[\"spur_margin_db\"]),\r\n                desired_stage1_sign=int(r.get(\"desired_stage1_sign\",\"1\")),\r\n                desired_stage2_sign=int(r.get(\"desired_stage2_sign\",\"1\")),\r\n            ))\r\n    return rows\r\n\r\ndef select_settings(rows: list[Row], if1_center_hz: float, bw_hz: float, rf_center_hz: float, last: Row | None = None) -> Row:\r\n    # Hysteresis: if last exists and requested RF is within ±HYSTERESIS_HZ, keep last\r\n    if last and abs(rf_center_hz - last.rf_center_hz) <= HYSTERESIS_HZ and abs(if1_center_hz - last.if1_center_hz) <= HYSTERESIS_HZ and abs(bw_hz - last.bw_hz) < 1:\r\n        return last\r\n    # Nearest neighbor on (if1_center, bw, rf_center)\r\n    best = None; best_d = 1e99\r\n    for r in rows:\r\n        if abs(r.bw_hz - bw_hz) > 1:  # require exact BW\r\n            continue\r\n        d = abs(r.if1_center_hz - if1_center_hz) + abs(r.rf_center_hz - rf_center_hz)\r\n        if d < best_d:\r\n            best, best_d = r, d\r\n    return best if best else rows[0]\r\n'''\r\n    dst_py.parent.mkdir(parents=True, exist_ok=True)\r\n    dst_py.write_text(code, encoding=\"utf-8\")\r\n\r\n@app.command()\r\ndef validate(cfg_path: str):\r\n    \"\"\"Validate config YAML loads and basic constraints.\"\"\"\r\n    cfg = Config(**yaml.safe_load(Path(cfg_path).read_text()))\r\n    assert cfg.bands.if1_hz.min < cfg.bands.if1_hz.max\r\n    assert cfg.bands.rf_hz.min < cfg.bands.rf_hz.max\r\n    print(\"[green]Config validated.[/green]\")\r\n\r\n@app.command()\r\ndef optimize(cfg_path: str, out: str = \"out\", models_dir: str | None = None):\r\n    \"\"\"Run optimization and write policy YAML/CSV + runtime selector. Shows a progress bar.\"\"\"\r\n    cfg = Config(**yaml.safe_load(Path(cfg_path).read_text()))\r\n    mdir = models_dir or str(Path(cfg_path).parent)\r\n\r\n    # Compute tiles up-front so we can size the progress bar deterministically\r\n    tiles = make_tiles(\r\n        cfg.bands.if1_hz.min, cfg.bands.if1_hz.max,\r\n        cfg.bands.rf_hz.min, cfg.bands.rf_hz.max,\r\n        cfg.grids.bw_grid_hz, cfg.grids.if1_center_step_hz, cfg.grids.rf_center_step_hz\r\n    )\r\n    total_tiles = len(tiles)\r\n\r\n    # Progress bar\r\n    progress_columns = (\r\n        SpinnerColumn(),\r\n        \"[bold]Optimizing[/bold]\",\r\n        BarColumn(bar_width=None),\r\n        MofNCompleteColumn(),\r\n        TimeElapsedColumn(),\r\n        TimeRemainingColumn(),\r\n    )\r\n\r\n    # File list (for hashes)\r\n    input_files = _resolve_model_paths(cfg, cfg_path)\r\n\r\n    with Progress(*progress_columns) as progress:\r\n        task_id = progress.add_task(\"Optimizing\", total=total_tiles)\r\n\r\n        def _progress_cb(done: int):\r\n            # called once per tile completion from the policy layer\r\n            progress.update(task_id, advance=done)\r\n\r\n        policy = optimize_policy(cfg, mdir, input_files=input_files, progress_cb=_progress_cb)\r\n\r\n    outp = Path(out); outp.mkdir(parents=True, exist_ok=True)\r\n    (outp/\"policy.yaml\").write_text(yaml.safe_dump(policy, sort_keys=False))\r\n    # Compact CSV\r\n    rows = policy[\"rows\"]\r\n    import pandas as pd\r\n    df = pd.DataFrame(rows)\r\n    df.to_csv(outp/\"policy.csv\", index=False)\r\n    print(f\"[green]Wrote {len(rows)} policy rows to {outp}[/green]\")\r\n\r\n    # Spur ledgers (optional, compact JSONL per tile)\r\n    ledgers = policy.get(\"ledgers\", {})\r\n    if ledgers:\r\n        (outp/\"ledgers.jsonl\").write_text(\r\n            \"\\n\".join(json.dumps({\"tile_id\": int(k), \"bins\": v}, ensure_ascii=False) for k, v in ledgers.items()),\r\n            encoding=\"utf-8\"\r\n        )\r\n\r\n    # Spans & coverage gaps\r\n    if policy.get(\"spans\"):\r\n        (outp/\"spans.yaml\").write_text(yaml.safe_dump(policy[\"spans\"], sort_keys=False), encoding=\"utf-8\")\r\n    if policy.get(\"coverage_gaps\"):\r\n        (outp/\"coverage_gaps.yaml\").write_text(yaml.safe_dump(policy[\"coverage_gaps\"], sort_keys=False), encoding=\"utf-8\")\r\n\r\n    # NEW: IF2 windows export\r\n    if policy.get(\"if2_windows\"):\r\n        (outp/\"if2_windows.yaml\").write_text(yaml.safe_dump(policy[\"if2_windows\"], sort_keys=False), encoding=\"utf-8\")\r\n        print(f\"[green]Wrote unique IF2 windows to {outp/'if2_windows.yaml'}[/green]\")\r\n\r\n    # Runtime selector (π)\r\n    _write_runtime_selector(outp/\"runtime_selector.py\", hysteresis_hz=cfg.runtime_policy.hysteresis_hz)\r\n\r\n    print(f\"[green]Wrote runtime selector to {outp/'runtime_selector.py'}[/green]\")\r\n\r\n@app.command()\r\ndef report(policy_yaml: str, html: str = \"out/summary.html\"):\r\n    \"\"\"Very light HTML summary.\"\"\"\r\n    policy = yaml.safe_load(Path(policy_yaml).read_text())\r\n    from jinja2 import Template\r\n    tpl = Template(\"\"\"\r\n    <html><head><meta charset=\"utf-8\"><title>BUCSO Summary</title>\r\n    <style>table {border-collapse: collapse} td,th{border:1px solid #ccc;padding:4px}</style>\r\n    </head><body>\r\n    <h1>{{proj.name}}</h1>\r\n    <p>Rows: {{rows|length}} | Seed: {{meta.deterministic_seed}}</p>\r\n    <p>Total lock: {{meta.retune_accounting.total_lock_ms}} ms | Retunes: {{meta.retune_accounting.retunes}} | Avg/step: {{meta.retune_accounting.avg_lock_ms_per_hop}} ms</p>\r\n    <p><strong>Note:</strong> IF2 search now uses local + global anchors; RF S21 supports CSV or YAML; S21 lookups are robust near DC.</p>\r\n    <p>Unique IF2 windows: {{ (policy.if2_windows or []) | length }}</p>\r\n    <p>Input hashes:</p>\r\n    <pre style=\"font-size:12px\">{{ meta.file_hashes | tojson(indent=2) }}</pre>\r\n    <table>\r\n      <tr>\r\n        <th>tile</th><th>IF1c</th><th>BW</th><th>RFc</th>\r\n        <th>LO1</th><th>LO2</th><th>IF2c</th><th>IF2BW</th><th>RF BPF</th><th>Margin (dB)</th><th>Brittleness</th>\r\n      </tr>\r\n      {% for r in rows %}\r\n      <tr>\r\n        <td>{{r.tile_id}}</td>\r\n        <td>{{\"%.3f\"%(r.if1_center_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.0f\"%(r.bw_hz/1e6)}} MHz</td>\r\n        <td>{{\"%.3f\"%(r.rf_center_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.3f\"%(r.lo1_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.3f\"%(r.lo2_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.3f\"%(r.if2_center_hz/1e9)}} GHz</td>\r\n        <td>{{\"%.0f\"%(r.if2_bw_hz/1e6)}} MHz</td>\r\n        <td>{{r.rf_bpf_id}}</td>\r\n        <td>{{\"%.1f\"%r.spur_margin_db}}</td>\r\n        <td>{{\"%.2f\"%r.brittleness_db_per_step}}</td>\r\n      </tr>\r\n      {% endfor %}\r\n    </table>\r\n    </body></html>\"\"\")\r\n    html_text = tpl.render(proj=policy[\"project\"], rows=policy[\"rows\"], meta=policy[\"meta\"], policy=policy)\r\n    Path(html).parent.mkdir(parents=True, exist_ok=True)\r\n    Path(html).write_text(html_text, encoding=\"utf-8\")\r\n    print(f\"[green]Wrote {html}[/green]\")\r\n\r\n# --- Example stubs embedded so `init-stubs` needs no downloads ---\r\n\r\nEXAMPLE_CONFIG = \"\"\"\\\r\nproject:\r\n  name: \"KaBUC-SpurPlan\"\r\n  seed: 42\r\n  reference_10mhz_hz: 10000000\r\n\r\nbands:\r\n  if1_hz: {min: 950e6, max: 2150e6}\r\n  rf_hz: {min: 27.5e9, max: 31.0e9}\r\n  required_bandwidths_hz: [400e6]\r\n\r\ngrids:\r\n  if1_center_step_hz: 100e6\r\n  rf_center_step_hz: 250e6\r\n  bw_grid_hz: [400e6]\r\n  snap_if1_rf_to_grid: true\r\n\r\nmasks:\r\n  inband: {default_dbc: -60, table: []}\r\n  outofband: {default_dbc: -60, table: []}\r\n\r\nrbw_binning:\r\n  rbw_hz: 10e3\r\n  rbw_frac_of_bw: 0.0025\r\n  rbw_ppm_of_freq: 0\r\n  # NOTE: The tool computes the coalescing window as max(rbw_hz, rbw_frac_of_bw*BW, rbw_ppm_of_freq*freq).\r\n  #       A string expression knob (coalesce_window) from the design doc is not implemented on purpose.\r\n\r\nsearch:\r\n  lo1_candidates: [\"LMX2595_A.yaml\"]\r\n  lo2_candidates: [\"LMX2592_A.yaml\"]\r\n  mixer1_candidates: [\"MXR1.yaml\"]\r\n  mixer2_candidates: [\"MXR2.yaml\"]\r\n  rf_bpf_choices: [\"RF_S21_28to31GHz.csv\"]\r\n  if2_filter_model: \"IF2_Model_01.yaml\"\r\n\r\norders:\r\n  m1n1_max_abs: 7\r\n  m2n2_max_abs: 7\r\n  cross_stage_sum_max: 12\r\n\r\nconstraints:\r\n  enforce_desired_mn11_only: true\r\n  guard_margin_db: 2.0\r\n  desired_stage1_sign: +1\r\n  desired_stage2_sign: +1\r\n\r\nearly_reject:\r\n  image_in_if2_passband: true\r\n  loft_in_if2_or_rf_passbands: true\r\n  rf_first_order_image_in_passband: true\r\n\r\nruntime_policy:\r\n  hysteresis_hz: 10e6\r\n  prefer_fewer_retunes: true\r\n  lock_time_penalty_weight: 1.0\r\n  markov_transition_matrix_csv: null\r\n\r\ntargets:\r\n  min_margin_db: 0\r\n  alt_within_db: 3.0\r\n\"\"\"\r\n\r\nEXAMPLE_MIXER = \"\"\"\\\r\nname: \"MXR1\"\r\ntype: \"double-balanced\"\r\nif_range_hz: [50e6, 8e9]\r\nlo_range_hz: [100e6, 18e9]\r\nrf_range_hz: [50e6, 18e9]\r\n\r\nrequired_lo_drive_dbm: {min: 11, max: 17}\r\ndrive_derate: {nominal_dbm: 13, slope_db_per_db: 1.0, max_derate_db: 6}\r\n\r\nspur_table:\r\n  entries:\r\n    - {m: 1, n: 1, rej_dbc: -35}\r\n    - {m: 1, n: 2, rej_dbc: -45}\r\n    - {m: 2, n: 1, rej_dbc: -40}\r\n  grids:\r\n    lo_hz: [500e6, 2e9, 6e9, 12e9]\r\n    if_hz: [100e6, 500e6, 1e9]\r\n    rej_dbc: [[-32,-34,-36], [-33,-35,-37], [-35,-37,-40], [-36,-38,-42]]\r\n\r\nisolation:\r\n  lo_to_rf_db: -40\r\n  if_to_rf_db: -60\r\n\r\nlo_family_scaling:\r\n  default_slope_db_per_db: 1.0\r\n  cap_db: 12\r\n\"\"\"\r\n\r\nEXAMPLE_MIXER2 = \"\"\"\\\r\nname: \"MXR2\"\r\ntype: \"double-balanced\"\r\nif_range_hz: [50e6, 12e9]\r\nlo_range_hz: [100e6, 26e9]\r\nrf_range_hz: [50e6, 32e9]\r\n\r\nrequired_lo_drive_dbm: {min: 11, max: 17}\r\ndrive_derate: {nominal_dbm: 13, slope_db_per_db: 1.0, max_derate_db: 6}\r\n\r\nspur_table:\r\n  entries:\r\n    - {m: 1, n: 1, rej_dbc: -30}\r\n    - {m: 1, n: 2, rej_dbc: -38}\r\n    - {m: 2, n: 1, rej_dbc: -36}\r\n  grids:\r\n    lo_hz: [2e9, 10e9, 20e9, 26e9]\r\n    if_hz: [100e6, 2e9, 6e9]\r\n    rej_dbc: [[-28,-30,-32], [-29,-31,-33], [-31,-33,-35], [-32,-34,-36]]\r\n\r\nisolation:\r\n  lo_to_rf_db: -38\r\n  if_to_rf_db: -55\r\n\r\nlo_family_scaling:\r\n  default_slope_db_per_db: 1.0\r\n  cap_db: 12\r\n\"\"\"\r\n\r\nEXAMPLE_LO = \"\"\"\\\r\nname: \"LMX2595_A\"\r\nref_constraints:\r\n  allowed_refs_hz: [10e6]\r\n\r\nfreq_range_hz: [10e6, 20e9]\r\nstep_hz: 1e6\r\n\r\noutput_power_model:\r\n  table:\r\n    freq_hz: [5e9, 10e9, 15e9, 20e9]\r\n    p_out_dbm: [19, 19, 19, 19]\r\n  divider_adjust_db:\r\n    \"/1\": 0\r\n    \"/2\": -1\r\n    \"/4\": -2\r\n    \"/8\": -3\r\n\r\ndistribution:\r\n  path_losses_db: {lo1: 3.0}\r\n  pad_options_db: [0, 3, 6]\r\n\r\nmodes:\r\n  - name: \"fracN\"\r\n    enabled: true\r\n    pfd_hz_range: [10e6, 200e6]\r\n    pfd_dividers: [1,2,4,8]\r\n    vco_dividers: [1,2,4,8,16]\r\n    lock_time_model:\r\n      base_ms: 0.40\r\n      per_mhz_ms: 0.002\r\n      mode_penalties_ms: {int_to_frac: 0.30, frac_to_int: 0.20}\r\n    harmonics_at_output:\r\n      - {k: 2, rel_dBc: -25}\r\n      - {k: 3, rel_dBc: -35}\r\n    pfd_spurs_at_output:\r\n      families: []\r\n\r\ndivider_spectrum:\r\n  \"/1\": { harm_delta_dBc: 0 }\r\n  \"/2\": { harm_delta_dBc: 6 }\r\n  \"/4\": { harm_delta_dBc: 12 }\r\n  \"/8\": { harm_delta_dBc: 18 }\r\n\"\"\"\r\n\r\nEXAMPLE_LO2 = \"\"\"\\\r\nname: \"LMX2592_A\"\r\nref_constraints:\r\n  allowed_refs_hz: [10e6]\r\n\r\nfreq_range_hz: [10e6, 26e9]\r\nstep_hz: 1e6\r\n\r\noutput_power_model:\r\n  table:\r\n    freq_hz: [5e9, 10e9, 20e9, 26e9]\r\n    p_out_dbm: [15, 15, 15, 15]\r\n  divider_adjust_db:\r\n    \"/1\": 0\r\n\r\ndistribution:\r\n  path_losses_db: {lo2: 4.0}\r\n  pad_options_db: [0, 3, 6]\r\n\r\nmodes:\r\n  - name: \"fracN\"\r\n    enabled: true\r\n    pfd_hz_range: [10e6, 200e6]\r\n    pfd_dividers: [1,2,4,8]\r\n    vco_dividers: [1,2,4,8,16]\r\n    lock_time_model:\r\n      base_ms: 0.50\r\n      per_mhz_ms: 0.002\r\n      mode_penalties_ms: {int_to_frac: 0.30, frac_to_int: 0.20}\r\n    harmonics_at_output:\r\n      - {k: 2, rel_dBc: -25}\r\n    pfd_spurs_at_output:\r\n      families: []\r\n\r\ndivider_spectrum:\r\n  \"/1\": { harm_delta_dBc: 0 }\r\n\"\"\"\r\n\r\nEXAMPLE_IF2 = \"\"\"\\\r\nname: \"IF2_Model_01\"\r\ntype: \"symmetric_powerlaw\"\r\npassband_il_db: 1.0\r\nstop_floor_db: -80.0\r\nrolloff_db_per_dec: 40.0\r\nmin_bw_hz: 500e6\r\nmax_bw_hz: 6000e6\r\ncenter_range_hz: [500e6, 9000e6]\r\nsearch:\r\n  # seeds_per_tile CONTROLS IF2 SEARCH DENSITY deterministically (both center and BW seeds).\r\n  # Larger = broader exploration; keep modest to bound runtime.\r\n  seeds_per_tile: 8\r\n  local_refinement: \"coordinate_descent\"\r\n  max_refine_iters: 12\r\n  bounds_guard_hz: 0.0\r\n\"\"\"\r\n\r\nEXAMPLE_RF_CSV = \"\"\"\\\r\nfreq_hz,s21_db\r\n2.60e10,-30\r\n2.75e10,-5\r\n2.90e10,-1\r\n3.10e10,-1\r\n3.25e10,-10\r\n\"\"\"",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "filters.py",
              "path": "src\\bucso\\filters.py",
              "size": 4182,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass, field\r\nfrom typing import Callable\r\nimport numpy as np\r\nimport pandas as pd\r\nimport yaml\r\nfrom scipy.interpolate import interp1d\r\n\r\n\r\n@dataclass\r\nclass RFBPF:\r\n    freq_hz: np.ndarray\r\n    s21_db: np.ndarray\r\n    id: str\r\n\r\n    # cached members (not shown in repr)\r\n    _x: np.ndarray = field(init=False, repr=False)\r\n    _y: np.ndarray = field(init=False, repr=False)\r\n    _interp: Callable[[np.ndarray], np.ndarray] = field(init=False, repr=False)\r\n\r\n    @classmethod\r\n    def _from_arrays(cls, freq_hz: np.ndarray, s21_db: np.ndarray, ident: str) -> \"RFBPF\":\r\n        # Ensure sorted by frequency for deterministic, correct interpolation\r\n        order = np.argsort(freq_hz, kind=\"mergesort\")\r\n        f = np.asarray(freq_hz, dtype=float)[order]\r\n        s = np.asarray(s21_db, dtype=float)[order]\r\n        obj = cls(freq_hz=f, s21_db=s, id=ident)\r\n        # Build interpolator once (log-frequency, linear dB) with extrapolation\r\n        # Guard log10(0) via clamp inside attn_at()\r\n        obj._x = np.log10(np.maximum(obj.freq_hz, 1.0))\r\n        obj._y = obj.s21_db\r\n        obj._interp = interp1d(\r\n            obj._x, obj._y,\r\n            kind=\"linear\",\r\n            fill_value=\"extrapolate\",\r\n            assume_sorted=True,\r\n        )\r\n        return obj\r\n\r\n    @classmethod\r\n    def from_csv(cls, path: str) -> \"RFBPF\":\r\n        df = pd.read_csv(path)\r\n        f = df[\"freq_hz\"].to_numpy(dtype=float)\r\n        s = df[\"s21_db\"].to_numpy(dtype=float)\r\n        return cls._from_arrays(f, s, ident=path)\r\n\r\n    @classmethod\r\n    def from_yaml(cls, path: str) -> \"RFBPF\":\r\n        y = yaml.safe_load(open(path, \"r\"))\r\n        # Support either dict with lists or list of {freq_hz, s21_db}\r\n        if isinstance(y, dict) and \"freq_hz\" in y and \"s21_db\" in y:\r\n            f = np.array(y[\"freq_hz\"], dtype=float)\r\n            s = np.array(y[\"s21_db\"], dtype=float)\r\n        elif isinstance(y, list):\r\n            f = np.array([row[\"freq_hz\"] for row in y], dtype=float)\r\n            s = np.array([row[\"s21_db\"] for row in y], dtype=float)\r\n        else:\r\n            raise ValueError(f\"Unsupported RF BPF YAML format in {path!r}\")\r\n        return cls._from_arrays(f, s, ident=path)\r\n\r\n    @classmethod\r\n    def from_path(cls, path: str) -> \"RFBPF\":\r\n        p = str(path).lower()\r\n        if p.endswith(\".csv\"):\r\n            return cls.from_csv(path)\r\n        if p.endswith(\".yaml\") or p.endswith(\".yml\"):\r\n            return cls.from_yaml(path)\r\n        # Best effort: try CSV first, then YAML\r\n        try:\r\n            return cls.from_csv(path)\r\n        except Exception:\r\n            return cls.from_yaml(path)\r\n\r\n    def attn_at(self, f_hz):\r\n        \"\"\"\r\n        Return attenuation at f_hz (Hz). Accepts scalar or ndarray.\r\n        Always returns an ndarray of dtype float (shape follows input).\r\n\r\n        Robust to f_hz <= 0 by clamping to 1 Hz before log10().\r\n        \"\"\"\r\n        fx = np.asarray(f_hz, dtype=float)\r\n        # Avoid log10(0) / negatives by clamping to >= 1 Hz\r\n        fx = np.maximum(fx, 1.0)\r\n        fx = np.log10(fx)\r\n        return np.asarray(self._interp(fx), dtype=float)\r\n\r\n\r\n@dataclass\r\nclass IF2Parametric:\r\n    center_hz: float\r\n    bw_hz: float\r\n    passband_il_db: float\r\n    stop_floor_db: float\r\n    rolloff_db_per_dec: float  # positive number (magnitude)\r\n    # symmetric_powerlaw\r\n\r\n    def attn_at(self, f_hz: float) -> float:\r\n        \"\"\"\r\n        Flat IL inside passband; outside, slope to floor (negative).\r\n        (Scalar implementation — cheap and fine for current call sites.)\r\n        \"\"\"\r\n        edge = self.bw_hz / 2.0\r\n        df = abs(f_hz - self.center_hz)\r\n        if df <= edge:\r\n            return -abs(self.passband_il_db)\r\n        # decades beyond edge\r\n        decades = np.log10(max(df / edge, 1e-9))\r\n        attn = -abs(self.passband_il_db) - self.rolloff_db_per_dec * decades\r\n        return max(attn, self.stop_floor_db)\r\n\r\n    def contains_desired(self, center: float, bw: float) -> bool:\r\n        # require desired band fully inside passband rectangle\r\n        return (abs(center - self.center_hz) + bw / 2.0) <= (self.bw_hz / 2.0)\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "mixer.py",
              "path": "src\\bucso\\mixer.py",
              "size": 5280,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom typing import Dict\r\nfrom functools import lru_cache\r\nimport numpy as np\r\nfrom .models import MixerModel\r\nfrom .utils import clamp\r\n\r\n\r\ndef _bilinear_clamped(z: np.ndarray, x_axis: np.ndarray, y_axis: np.ndarray, x: float, y: float) -> float:\r\n    \"\"\"\r\n    Bilinear interpolation over a rect grid with clamp-at-edges behavior.\r\n    z shape must be (len(x_axis), len(y_axis)) in the same orientation used in the YAML.\r\n    \"\"\"\r\n    # Validate shape early to avoid silent mis-indexing\r\n    if z.shape != (len(x_axis), len(y_axis)):\r\n        raise ValueError(\r\n            f\"Mixer spur grid shape {z.shape} does not match axes \"\r\n            f\"({len(x_axis)}, {len(y_axis)}). Check YAML grids.\"\r\n        )\r\n    # map value->index space (scalar)\r\n    xi = np.interp(x, x_axis, np.arange(len(x_axis)))\r\n    yi = np.interp(y, y_axis, np.arange(len(y_axis)))\r\n    i0 = int(clamp(np.floor(xi + 1e-9), 0, len(x_axis) - 2))\r\n    j0 = int(clamp(np.floor(yi + 1e-9), 0, len(y_axis) - 2))\r\n    tx = xi - i0\r\n    ty = yi - j0\r\n    return float(\r\n        z[i0, j0] * (1 - tx) * (1 - ty)\r\n        + z[i0 + 1, j0] * (tx) * (1 - ty)\r\n        + z[i0, j0 + 1] * (1 - tx) * (ty)\r\n        + z[i0 + 1, j0 + 1] * (tx) * (ty)\r\n    )\r\n\r\n\r\nclass Mixer:\r\n    \"\"\"\r\n    Mixer rejection lookup with:\r\n      - scalar entries for specific (m,n)\r\n      - optional per-(m,n) grids (grids_by_order: {\"m,n\": {lo_hz, if_hz, rej_dbc}})\r\n      - optional legacy single grid assumed to be (1,1)\r\n      - configurable fallback for unknown orders\r\n    Also provides simple drive-derate and order-aware LO family scaling.\r\n    \"\"\"\r\n\r\n    def __init__(self, mdl: MixerModel):\r\n        self.mdl = mdl\r\n\r\n        st: Dict[str, object] = mdl.spur_table or {}\r\n\r\n        # New: per-(m,n) grids\r\n        self._grids_by_order: Dict[str, Dict[str, np.ndarray]] = {}\r\n        if \"grids_by_order\" in st and isinstance(st[\"grids_by_order\"], dict):\r\n            for key, g in st[\"grids_by_order\"].items():\r\n                lo = np.array((g.get(\"lo_hz\") or []), float)\r\n                ifv = np.array((g.get(\"if_hz\") or []), float)\r\n                rej = np.array((g.get(\"rej_dbc\") or []), float)\r\n                if rej.ndim != 2:\r\n                    raise ValueError(f\"Mixer '{mdl.name}' per-order grid rej_dbc must be 2D; got shape {rej.shape}.\")\r\n                # shape validation will be re-checked in _bilinear_clamped\r\n                self._grids_by_order[str(key)] = {\"lo\": lo, \"if\": ifv, \"rej\": rej}\r\n\r\n        # Legacy: a single grid interpreted as the (1,1) grid.\r\n        self._grid_default = None\r\n        if \"grids\" in st and isinstance(st[\"grids\"], dict):\r\n            g = st[\"grids\"]\r\n            lo = np.array((g.get(\"lo_hz\") or []), float)\r\n            ifv = np.array((g.get(\"if_hz\") or []), float)\r\n            rej = np.array((g.get(\"rej_dbc\") or []), float)\r\n            if rej.size and (rej.ndim != 2):\r\n                raise ValueError(f\"Mixer '{mdl.name}' legacy grid rej_dbc must be 2D; got shape {rej.shape}.\")\r\n            self._grid_default = {\"lo\": lo, \"if\": ifv, \"rej\": rej}\r\n\r\n        # Scalar entries\r\n        self._entries = st.get(\"entries\", []) or []\r\n\r\n        # Quantization for cache keys (Hz)\r\n        self._q_hz = 1e6\r\n\r\n    def set_cache_quantum_hz(self, q_hz: float):\r\n        self._q_hz = float(q_hz)\r\n        self._rej_cached.cache_clear()\r\n\r\n    def clear_cache(self):\r\n        self._rej_cached.cache_clear()\r\n\r\n    @lru_cache(maxsize=262144)\r\n    def _rej_cached(self, m: int, n: int, lo_q: float, if_q: float) -> float:\r\n        # 1) Exact scalar entry wins\r\n        for e in self._entries:\r\n            if e.get(\"m\") == m and e.get(\"n\") == n:\r\n                return float(e[\"rej_dbc\"])\r\n\r\n        # 2) Per-(m,n) grid if present\r\n        key = f\"{int(m)},{int(n)}\"\r\n        grid = self._grids_by_order.get(key)\r\n        if grid and grid[\"rej\"].size and grid[\"lo\"].size and grid[\"if\"].size:\r\n            return _bilinear_clamped(grid[\"rej\"], grid[\"lo\"], grid[\"if\"], lo_q, if_q)\r\n\r\n        # 3) Legacy default grid only for (1,1)\r\n        if (m == 1 and n == 1) and (self._grid_default is not None):\r\n            gd = self._grid_default\r\n            if gd[\"rej\"].size and gd[\"lo\"].size and gd[\"if\"].size:\r\n                return _bilinear_clamped(gd[\"rej\"], gd[\"lo\"], gd[\"if\"], lo_q, if_q)\r\n\r\n        # 4) Conservative fallback\r\n        return float(self.mdl.fallback_rej_dbc)\r\n\r\n    def rejection_dbc(self, m: int, n: int, lo_hz: float, if_hz: float) -> float:\r\n        q = self._q_hz\r\n        return self._rej_cached(m, n, round(lo_hz / q) * q, round(if_hz / q) * q)\r\n\r\n    def drive_derate_db(self, delivered_dbm: float) -> float:\r\n        reqmin = self.mdl.required_lo_drive_dbm[\"min\"]\r\n        if delivered_dbm >= reqmin:\r\n            return 0.0\r\n        delta = reqmin - delivered_dbm\r\n        slope = self.mdl.drive_derate.slope_db_per_db\r\n        cap = self.mdl.drive_derate.max_derate_db\r\n        return min(cap, slope * delta)\r\n\r\n    def family_scale_db(self, order_abs: int, lo_rel_dBc: float) -> float:\r\n        slope = self.mdl.lo_family_scaling.get(\"default_slope_db_per_db\", 1.0)\r\n        cap = self.mdl.lo_family_scaling.get(\"cap_db\", 12.0)\r\n        val = slope * abs(order_abs) * lo_rel_dBc\r\n        return max(-cap, min(cap, val))\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "models.py",
              "path": "src\\bucso\\models.py",
              "size": 6410,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom typing import List, Optional, Dict, Tuple\r\nfrom pydantic import BaseModel, Field\r\nimport numpy as np\r\n\r\nHz = float\r\ndB = float\r\n\r\n\r\nclass Project(BaseModel):\r\n    name: str = \"KaBUC-SpurPlan\"\r\n    seed: int = 42\r\n    reference_10mhz_hz: Hz = 10_000_000.0\r\n\r\n\r\nclass BandLimits(BaseModel):\r\n    min: Hz\r\n    max: Hz\r\n\r\n\r\nclass Bands(BaseModel):\r\n    if1_hz: BandLimits\r\n    rf_hz: BandLimits\r\n    required_bandwidths_hz: List[Hz] = [400e6]\r\n\r\n\r\nclass Grids(BaseModel):\r\n    if1_center_step_hz: Hz = 25e6\r\n    rf_center_step_hz: Hz = 25e6\r\n    bw_grid_hz: List[Hz] = [400e6]\r\n    snap_if1_rf_to_grid: bool = True\r\n\r\n\r\nclass MaskTableEntry(BaseModel):\r\n    offset_hz: Hz\r\n    limit_dbc: dB\r\n\r\n\r\nclass MaskSpec(BaseModel):\r\n    default_dbc: dB = -60.0\r\n    # safer than a bare [] default\r\n    table: List[MaskTableEntry] = Field(default_factory=list)\r\n    # NEW: how to interpret table for OOB: \"absolute\" (abs freq) or \"edge_relative\" (offset from RF-band edge)\r\n    # For inband masks this field is ignored.\r\n    mode: str = \"absolute\"\r\n\r\n\r\nclass Masks(BaseModel):\r\n    inband: MaskSpec = MaskSpec()\r\n    outofband: MaskSpec = MaskSpec()\r\n\r\n\r\nclass RBWBinning(BaseModel):\r\n    rbw_hz: Hz = 10e3\r\n    rbw_frac_of_bw: float = 0.0025\r\n    rbw_ppm_of_freq: float = 0.0\r\n\r\n\r\nclass Orders(BaseModel):\r\n    m1n1_max_abs: int = 7\r\n    m2n2_max_abs: int = 7\r\n    cross_stage_sum_max: int = 12\r\n\r\n\r\nclass Constraints(BaseModel):\r\n    enforce_desired_mn11_only: bool = True\r\n    guard_margin_db: dB = 2.0\r\n    # Optional sign locks for the desired mechanism:\r\n    # +1 = \"sum / high-side\", -1 = \"difference / low-side\"\r\n    desired_stage1_sign: int | None = None\r\n    desired_stage2_sign: int | None = None\r\n\r\n\r\nclass EarlyReject(BaseModel):\r\n    image_in_if2_passband: bool = True\r\n    loft_in_if2_or_rf_passbands: bool = True\r\n    rf_first_order_image_in_passband: bool = True\r\n\r\n\r\nclass RuntimePolicy(BaseModel):\r\n    hysteresis_hz: Hz = 10e6\r\n    prefer_fewer_retunes: bool = True\r\n    lock_time_penalty_weight: float = 1.0\r\n    markov_transition_matrix_csv: Optional[str] = None\r\n\r\n\r\nclass Targets(BaseModel):\r\n    min_margin_db: dB = 0.0\r\n    alt_within_db: dB = 3.0\r\n\r\n\r\nclass Search(BaseModel):\r\n    lo1_candidates: List[str]\r\n    lo2_candidates: List[str]\r\n    mixer1_candidates: List[str]\r\n    mixer2_candidates: List[str]\r\n    rf_bpf_choices: List[str]\r\n    if2_filter_model: str\r\n\r\n    # -------- NEW (fast snapped LO search) --------\r\n    # Defaults preserve current behavior but enable the fast path out of the box.\r\n    enable_snapped_lo_search: bool = True             # set False to force legacy wide sweeps\r\n    lo_snap_window_steps: int = 2                     # initial ±N around snap\r\n    lo_snap_expand_schedule: List[int] = [2, 4, 8]    # widening schedule if empty\r\n    lo_snap_max_window_steps: int = 8                 # hard cap for widening\r\n    include_lo2_alt_form: bool = False                # also try s2*(-RFc - IF2c)\r\n\r\n    # Optional: cheaper search (winner is re-scored at full orders for parity)\r\n    search_orders_mn_abs: int | None = None           # e.g., 3 or 4\r\n    search_cross_sum_max: int | None = None           # e.g., 8..10\r\n\r\n    # Optional: cap per-LO candidate list before Cartesian pairing\r\n    per_lo_candidate_cap: int | None = 128\r\n\r\n\r\nclass Config(BaseModel):\r\n    project: Project\r\n    bands: Bands\r\n    grids: Grids\r\n    masks: Masks = Masks()\r\n    rbw_binning: RBWBinning = RBWBinning()\r\n    search: Search\r\n    orders: Orders = Orders()\r\n    constraints: Constraints = Constraints()\r\n    early_reject: EarlyReject = EarlyReject()\r\n    runtime_policy: RuntimePolicy = RuntimePolicy()\r\n    targets: Targets = Targets()\r\n\r\n\r\n# Mixer & LO YAML models (simplified for starter)\r\nclass MixerSpurEntry(BaseModel):\r\n    m: int\r\n    n: int\r\n    rej_dbc: dB\r\n\r\n\r\nclass MixerIsolation(BaseModel):\r\n    lo_to_rf_db: dB = -40.0\r\n    if_to_rf_db: dB = -60.0\r\n\r\n\r\nclass MixerDriveDerate(BaseModel):\r\n    nominal_dbm: float = 13.0\r\n    slope_db_per_db: float = 1.0\r\n    max_derate_db: float = 6.0\r\n\r\n\r\nclass MixerModel(BaseModel):\r\n    name: str\r\n    type: str = \"double-balanced\"\r\n    if_range_hz: Tuple[Hz, Hz]\r\n    lo_range_hz: Tuple[Hz, Hz]\r\n    rf_range_hz: Tuple[Hz, Hz]\r\n    required_lo_drive_dbm: Dict[str, float] = {\"min\": 11.0, \"max\": 17.0}\r\n    drive_derate: MixerDriveDerate = MixerDriveDerate()\r\n    # spur_table supports:\r\n    #   - entries: [ {m,n,rej_dbc}, ... ]\r\n    #   - grids_by_order: {\"m,n\": {lo_hz, if_hz, rej_dbc}}\r\n    #   - (legacy) grids: {lo_hz, if_hz, rej_dbc} interpreted as (1,1)\r\n    spur_table: Dict[str, object]\r\n    isolation: MixerIsolation = MixerIsolation()\r\n    lo_family_scaling: Dict[str, float] = {\"default_slope_db_per_db\": 1.0, \"cap_db\": 12.0}\r\n    notes: Optional[str] = None\r\n    # configurable fallback for missing table entries (keep but consider tightening in config)\r\n    fallback_rej_dbc: dB = -20.0\r\n\r\n\r\nclass Harmonic(BaseModel):\r\n    k: int\r\n    rel_dBc: dB\r\n\r\n\r\nclass PfdComponent(BaseModel):\r\n    k: int\r\n    base_rel_dBc: dB\r\n    rolloff_dB_per_dec: float\r\n    # NEW: optional corner to express roll-off vs (k*fPFD / corner_hz)\r\n    corner_hz: Optional[Hz] = None\r\n\r\n\r\nclass PfdFamily(BaseModel):\r\n    name: str\r\n    components: List[PfdComponent]\r\n\r\n\r\nclass LockTimeModel(BaseModel):\r\n    base_ms: float = 0.4\r\n    per_mhz_ms: float = 0.002\r\n    mode_penalties_ms: Dict[str, float] = {}\r\n\r\n\r\nclass Mode(BaseModel):\r\n    name: str\r\n    enabled: bool = True\r\n    pfd_hz_range: Tuple[Hz, Hz]\r\n    pfd_dividers: List[int]\r\n    vco_dividers: List[int]\r\n    lock_time_model: LockTimeModel\r\n    harmonics_at_output: List[Harmonic] = []\r\n    pfd_spurs_at_output: Dict[str, List[PfdFamily]] | Dict[str, object] | None = None\r\n    frac_boundary_spurs: Dict[str, object] | None = None\r\n\r\n\r\nclass DividerSpectrum(BaseModel):\r\n    harm_delta_dBc: dB = 0.0\r\n\r\n\r\nclass OutputPowerTable(BaseModel):\r\n    table: Dict[str, List[float]]\r\n    divider_adjust_db: Dict[str, float] = {}\r\n\r\n\r\nclass Distribution(BaseModel):\r\n    path_losses_db: Dict[str, float]\r\n    pad_options_db: List[float] = [0.0, 3.0, 6.0]\r\n\r\n\r\nclass LOMdl(BaseModel):\r\n    name: str\r\n    ref_constraints: Dict[str, List[Hz]]\r\n    freq_range_hz: Tuple[Hz, Hz]\r\n    step_hz: Hz = 1e3\r\n    output_power_model: OutputPowerTable\r\n    distribution: Distribution\r\n    modes: List[Mode]\r\n    divider_spectrum: Dict[str, DividerSpectrum]\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "policy.py",
              "path": "src\\bucso\\policy.py",
              "size": 56435,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass, asdict\r\nfrom typing import List, Dict, Callable, Optional, Tuple\r\nimport os, yaml, math, hashlib, importlib.metadata\r\nfrom contextlib import contextmanager\r\nimport numpy as np\r\nfrom concurrent.futures import ProcessPoolExecutor, as_completed\r\n\r\nfrom .models import Config, MixerModel, LOMdl, Mode\r\nfrom .filters import IF2Parametric, RFBPF\r\nfrom .mixer import Mixer\r\nfrom .synth import Synth\r\nfrom .tiling import make_tiles\r\nfrom .spur import enumerate_spurs, desired_paths\r\nfrom .utils import Band\r\n\r\n# ------------------- process-global model cache -------------------\r\n_MODELS: dict | None = None  # set by _init_models_once()\r\n\r\n\r\ndef _file_hash(path: str) -> str:\r\n    h = hashlib.sha256()\r\n    with open(path, \"rb\") as f:\r\n        for chunk in iter(lambda: f.read(1 << 20), b\"\"):\r\n            h.update(chunk)\r\n    return h.hexdigest()\r\n\r\n\r\ndef _load_yaml(root: str, name_or_path: str):\r\n    path = name_or_path if os.path.isabs(name_or_path) else os.path.join(root, name_or_path)\r\n    with open(path, \"r\") as f:\r\n        return yaml.safe_load(f)\r\n\r\n\r\ndef _init_models_once(models_dir: str, cfg_dict: dict):\r\n    \"\"\"\r\n    Process initializer: load heavy models only once per process and stash\r\n    them in module globals to avoid per-tile I/O/parse overhead.\r\n    Also sets mixer cache quantization for better hit rate.\r\n    \"\"\"\r\n    global _MODELS\r\n    if _MODELS is not None:\r\n        return\r\n\r\n    cfg = Config(**cfg_dict)\r\n\r\n    # Load mixer models (construct Mixer objects)\r\n    mixer1 = [Mixer(MixerModel(**_load_yaml(models_dir, p))) for p in cfg.search.mixer1_candidates]\r\n    mixer2 = [Mixer(MixerModel(**_load_yaml(models_dir, p))) for p in cfg.search.mixer2_candidates]\r\n    # Improve cache reuse (quantize lookups more coarsely, clear LRUs)\r\n    for m in (mixer1 + mixer2):\r\n        m.set_cache_quantum_hz(5e6)  # ~5 MHz; good vs 25–250 MHz grids\r\n        m.clear_cache()\r\n\r\n    # Load synthesizers\r\n    lo1s = [Synth(LOMdl(**_load_yaml(models_dir, p))) for p in cfg.search.lo1_candidates]\r\n    lo2s = [Synth(LOMdl(**_load_yaml(models_dir, p))) for p in cfg.search.lo2_candidates]\r\n\r\n    # RF filters (CSV/YAML auto)\r\n    rfs = []\r\n    for rp in cfg.search.rf_bpf_choices:\r\n        path = rp if os.path.isabs(rp) else os.path.join(models_dir, rp)\r\n        rfs.append(RFBPF.from_path(path))\r\n\r\n    # IF2 parametric YAML (constants)\r\n    if2yaml = _load_yaml(models_dir, cfg.search.if2_filter_model)\r\n\r\n    _MODELS = dict(\r\n        cfg_dict=cfg_dict,\r\n        mixer1=mixer1,\r\n        mixer2=mixer2,\r\n        lo1s=lo1s,\r\n        lo2s=lo2s,\r\n        rfs=rfs,\r\n        if2yaml=if2yaml,\r\n        models_dir=models_dir,\r\n    )\r\n\r\n\r\n@contextmanager\r\ndef _progress_ctx(total: int, desc: str, provided_cb: Optional[Callable[[int], None]]):\r\n    \"\"\"\r\n    Yield a callable `update(n)` that advances progress by n.\r\n    If `provided_cb` is given, we just yield that.\r\n    Otherwise, we enable a Rich progress bar when BUCSO_PROGRESS is truthy.\r\n    Fallback to a no-op if Rich isn't available or progress is disabled.\r\n    \"\"\"\r\n    if provided_cb is not None:\r\n        # External progress handler (e.g., CLI) – just forward updates\r\n        yield provided_cb\r\n        return\r\n\r\n    use_env = os.getenv(\"BUCSO_PROGRESS\", \"\").strip().lower()\r\n    enabled = use_env in (\"1\", \"true\", \"yes\", \"on\", \"y\", \"t\")\r\n\r\n    if not enabled:\r\n        # No progress – return a no-op updater\r\n        def _noop(_n: int) -> None:\r\n            pass\r\n        yield _noop\r\n        return\r\n\r\n    try:\r\n        from rich.progress import (\r\n            Progress, BarColumn, TimeElapsedColumn, TimeRemainingColumn,\r\n            MofNCompleteColumn, SpinnerColumn\r\n        )\r\n        columns = (\r\n            SpinnerColumn(),\r\n            f\"[bold]{desc}[/bold]\",\r\n            BarColumn(bar_width=None),\r\n            MofNCompleteColumn(),\r\n            TimeElapsedColumn(),\r\n            TimeRemainingColumn(),\r\n        )\r\n        with Progress(*columns) as progress:\r\n            task_id = progress.add_task(desc, total=total)\r\n\r\n            def _update(n: int) -> None:\r\n                if n:\r\n                    progress.update(task_id, advance=int(n))\r\n\r\n            yield _update\r\n    except Exception:\r\n        # Graceful fallback\r\n        def _noop(_n: int) -> None:\r\n            pass\r\n        yield _noop\r\n\r\n\r\n@dataclass\r\nclass PlanRow:\r\n    tile_id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n    lo1_name: str\r\n    lo1_hz: float\r\n    lo1_mode: str\r\n    lo1_divider: str\r\n    lo1_pad_db: float\r\n    lo1_lock_ms: float\r\n    lo2_name: str\r\n    lo2_hz: float\r\n    lo2_mode: str\r\n    lo2_divider: str\r\n    lo2_pad_db: float\r\n    lo2_lock_ms: float\r\n    if2_center_hz: float\r\n    if2_bw_hz: float\r\n    rf_bpf_id: str\r\n    spur_margin_db: float\r\n    brittleness_db_per_step: float\r\n    # Traceability: desired signs used\r\n    desired_stage1_sign: int\r\n    desired_stage2_sign: int\r\n\r\n\r\ndef _overlap_1d(a_center: float, a_bw: float, b_center: float, b_bw: float) -> bool:\r\n    a_lo = a_center - a_bw / 2.0\r\n    a_hi = a_center + a_bw / 2.0\r\n    b_lo = b_center - b_bw / 2.0\r\n    b_hi = b_center + b_bw / 2.0\r\n    return not (a_hi < b_lo or b_hi < a_lo)\r\n\r\n\r\ndef _early_reject_gate(\r\n    tile_if1: Band,\r\n    lo1_hz: float,\r\n    lo2_hz: float,\r\n    inj1: int,\r\n    s2: int,\r\n    if2: IF2Parametric,\r\n    rf_bpf: RFBPF,\r\n    cfg: Config,\r\n) -> bool:\r\n    \"\"\"\r\n    Stronger early rejects with band-overlap checks.\r\n    Returns True if candidate should be rejected.\r\n    \"\"\"\r\n    if not (\r\n        cfg.early_reject.image_in_if2_passband\r\n        or cfg.early_reject.loft_in_if2_or_rf_passbands\r\n        or cfg.early_reject.rf_first_order_image_in_passband\r\n    ):\r\n        return False\r\n\r\n    # Desired bands for equivalence tests\r\n    if2_des, rf_des = desired_paths(tile_if1, lo1_hz, lo2_hz, inj1, s2)\r\n\r\n    # quick desired-IF2 containment precheck to avoid wasting work\r\n    if not if2.contains_desired(if2_des.center_hz, if2_des.bw_hz):\r\n        return True\r\n\r\n    # Stage-1 images (sum & diff) against IF2 passband — don't reject if it's the desired path\r\n    if cfg.early_reject.image_in_if2_passband:\r\n        for sgn in (+1, -1):\r\n            img2_c = abs(lo1_hz + sgn * tile_if1.center_hz)\r\n            is_desired = abs(img2_c - if2_des.center_hz) <= 1e-6\r\n            if (not is_desired) and _overlap_1d(img2_c, tile_if1.bw_hz, if2.center_hz, if2.bw_hz):\r\n                return True\r\n\r\n    # LO1 feedthrough inside IF2 passband\r\n    if cfg.early_reject.loft_in_if2_or_rf_passbands:\r\n        if _overlap_1d(lo1_hz, 0.0, if2.center_hz, if2.bw_hz):\r\n            return True\r\n\r\n    # Stage-2 first-order images (±LO2 ± IF2) overlapping RF desired band\r\n    if cfg.early_reject.rf_first_order_image_in_passband:\r\n        for sgn1 in (+1, -1):\r\n            for sgn2 in (+1, -1):\r\n                f_c = abs(sgn1 * lo2_hz + sgn2 * if2_des.center_hz)\r\n                if _overlap_1d(f_c, if2_des.bw_hz, rf_des.center_hz, rf_des.bw_hz):\r\n                    is_desired = (sgn1 == s2) and (sgn2 == +1)\r\n                    is_desired_equiv = (sgn1 == -s2) and (sgn2 == -1)  # |·| symmetry\r\n                    # Reject only if a different first-order image overlaps\r\n                    if not (is_desired or is_desired_equiv):\r\n                        return True\r\n\r\n    # LO2 feedthrough / quick harmonics in RF passband (cheap reject)\r\n    if cfg.early_reject.loft_in_if2_or_rf_passbands:\r\n        # main tone\r\n        if _overlap_1d(lo2_hz, 0.0, rf_des.center_hz, rf_des.bw_hz):\r\n            return True\r\n        # quick harmonic screen — include k=2,3,4 (very cheap)\r\n        for k in (2, 3, 4):\r\n            f_h = k * lo2_hz\r\n            if _overlap_1d(f_h, 0.0, rf_des.center_hz, rf_des.bw_hz):\r\n                return True\r\n\r\n    return False\r\n\r\n\r\n# --- Helpers -------------------------------------------------------------\r\n\r\ndef _rf_band_ok(rf_filter: RFBPF, rf_band_center: float, rf_bw: float, max_il_db: float = 3.0) -> bool:\r\n    \"\"\"Require the desired RF band (center ± BW/2) to be inside the passband by IL >= -max_il_db.\r\n    Sample densely across the band to avoid optimistic passes.\"\"\"\r\n    half = rf_bw * 0.5\r\n    fs = np.linspace(rf_band_center - half, rf_band_center + half, 17)\r\n    attn = np.array([float(rf_filter.attn_at(f)) for f in fs], float)\r\n    return np.min(attn) >= -max_il_db\r\n\r\n\r\n# --- fast snapped LO neighborhoods ---------------------------------------\r\n\r\ndef _neighborhood_solutions(\r\n    synth: Synth, *,\r\n    f_targets: list[float],\r\n    path: str,\r\n    drive_min: float,\r\n    drive_max: float,\r\n    base_N: int,\r\n    expand_sched: list[int],\r\n    hard_max: int,\r\n    cap: int | None,\r\n    bw_hz_for_fallback: float,\r\n):\r\n    \"\"\"\r\n    For each analytic target:\r\n      1) snap to legal grid and probe ±N grid steps\r\n      2) widen using expand_sched up to hard_max if needed\r\n      3) final fallback: bounded legacy legal_settings() within ±3×BW\r\n    Returns deterministic, de-duplicated LOSolution entries sorted by proximity.\r\n    \"\"\"\r\n    step = float(synth.mdl.step_hz)\r\n\r\n    def _probe(N: int):\r\n        offsets = [0] + [off for k in range(1, max(0, N) + 1) for off in (k, -k)]\r\n        sols = []\r\n        for tgt in f_targets:\r\n            for off in offsets:\r\n                sol = synth.snap_to_legal(\r\n                    f_target=float(tgt + off * step),\r\n                    path=path,\r\n                    window_steps=0,\r\n                    drive_min_dbm=drive_min,\r\n                    drive_max_dbm=drive_max,\r\n                )\r\n                if sol is not None:\r\n                    sols.append(sol)\r\n\r\n        # Deterministic de-dup + sort by |f - nearest target|\r\n        def key(s): return (s.name, s.mode, s.divider, round(s.f_out_hz, 0))\r\n        dedup = {key(s): s for s in sols}\r\n        out = list(dedup.values())\r\n\r\n        def dist(s): return min(abs(s.f_out_hz - ft) for ft in f_targets)\r\n        out.sort(key=dist)\r\n\r\n        if cap is not None and len(out) > cap:\r\n            out = out[:cap]\r\n        return out\r\n\r\n    # Initial probe\r\n    sols = _probe(int(base_N))\r\n    if sols:\r\n        return sols\r\n\r\n    # Expand schedule\r\n    for N in (expand_sched or []):\r\n        N = int(min(max(0, N), hard_max))\r\n        sols = _probe(N)\r\n        if sols:\r\n            return sols\r\n\r\n    # Final bounded fallback (legacy semantics, but centered on targets)\r\n    sols = []\r\n    for tgt in f_targets:\r\n        fmin = max(1.0, float(tgt) - 3.0 * bw_hz_for_fallback)\r\n        fmax = float(tgt) + 3.0 * bw_hz_for_fallback\r\n        sols.extend(synth.legal_settings(\r\n            name_filter=None, f_min=fmin, f_max=fmax, path=path,\r\n            drive_min_dbm=drive_min, drive_max_dbm=drive_max,\r\n        ))\r\n\r\n    def key(s): return (s.name, s.mode, s.divider, round(s.f_out_hz, 0))\r\n    dedup = {key(s): s for s in sols}\r\n    out = list(dedup.values())\r\n\r\n    def dist(s): return min(abs(s.f_out_hz - ft) for ft in f_targets)\r\n    out.sort(key=dist)\r\n\r\n    if cap is not None and len(out) > cap:\r\n        out = out[:cap]\r\n    return out\r\n\r\n\r\n# --- IF2 refinement (deterministic coordinate descent + memo) ------------------------\r\n\r\ndef _coordinate_descent_if2(\r\n    if2_const: dict,\r\n    seed_center_hz: float,\r\n    seed_bw_hz: float,\r\n    tile_if1: Band,\r\n    lo1,\r\n    lo2,\r\n    rf_filter: RFBPF,\r\n    mixer1: Mixer,\r\n    mixer2: Mixer,\r\n    cfg: Config,\r\n    inj1: int,\r\n    s2: int,\r\n    carriers_lo1,\r\n    carriers_lo2,\r\n    max_iters: int,\r\n    step_frac_center: float,\r\n    step_frac_bw: float,\r\n    bw_limits: tuple[float, float],\r\n    center_limits: tuple[float, float],\r\n) -> IF2Parametric:\r\n    \"\"\"\r\n    Internal helper that actually runs the loop. if2_const has keys:\r\n      passband_il_db, stop_floor_db, rolloff_db_per_dec\r\n    Enhanced with memoization and an early-stop after two consecutive no-improve rounds.\r\n    \"\"\"\r\n    c = float(seed_center_hz)\r\n    b = float(seed_bw_hz)\r\n    best_win = IF2Parametric(\r\n        center_hz=c, bw_hz=b,\r\n        passband_il_db=if2_const[\"passband_il_db\"],\r\n        stop_floor_db=if2_const[\"stop_floor_db\"],\r\n        rolloff_db_per_dec=if2_const[\"rolloff_db_per_dec\"],\r\n    )\r\n\r\n    memo: dict[tuple[float, float], float] = {}\r\n\r\n    def score(win: IF2Parametric) -> float:\r\n        key = (round(win.center_hz, 1), round(win.bw_hz, 1))\r\n        if key in memo:\r\n            return memo[key]\r\n        if2_des_center = abs(inj1 * lo1.f_out_hz - tile_if1.center_hz)\r\n        if not win.contains_desired(center=if2_des_center, bw=tile_if1.bw_hz):\r\n            memo[key] = -1e9\r\n            return memo[key]\r\n        summ = enumerate_spurs(\r\n            tile_if1, lo1, lo2, win, rf_filter, mixer1, mixer2, cfg,\r\n            inj1_sign=inj1, s2_sign=s2, carriers_lo1=carriers_lo1, carriers_lo2=carriers_lo2\r\n        )\r\n        memo[key] = float(summ.worst_margin_db)\r\n        return memo[key]\r\n\r\n    best = score(best_win)\r\n    dc = max(1.0, step_frac_center) * (tile_if1.bw_hz * 0.5)  # start with half-BW scaled step\r\n    db = max(1.0, step_frac_bw) * (tile_if1.bw_hz * 0.3)\r\n\r\n    no_improve = 0\r\n    for _ in range(max_iters):\r\n        improved = False\r\n        # Try center +/- dc\r\n        for sign in (+1, -1):\r\n            c_try = float(np.clip(c + sign * dc, center_limits[0], center_limits[1]))\r\n            win = IF2Parametric(c_try, b, if2_const[\"passband_il_db\"], if2_const[\"stop_floor_db\"], if2_const[\"rolloff_db_per_dec\"])\r\n            s = score(win)\r\n            if s > best + 1e-6:\r\n                best, c, best_win = s, c_try, win\r\n                improved = True\r\n        # Try BW +/- db\r\n        for sign in (+1, -1):\r\n            b_try = float(np.clip(b + sign * db, bw_limits[0], bw_limits[1]))\r\n            win = IF2Parametric(c, b_try, if2_const[\"passband_il_db\"], if2_const[\"stop_floor_db\"], if2_const[\"rolloff_db_per_dec\"])\r\n            s = score(win)\r\n            if s > best + 1e-6:\r\n                best, b, best_win = s, b_try, win\r\n                improved = True\r\n\r\n        if improved:\r\n            no_improve = 0\r\n        else:\r\n            no_improve += 1\r\n            if no_improve >= 2:\r\n                break\r\n\r\n        # Shrink steps\r\n        dc *= 0.5\r\n        db *= 0.5\r\n\r\n    return best_win\r\n\r\n\r\ndef _robustness_score(\r\n    base_summary,\r\n    tile_if1: Band,\r\n    lo1, lo2,\r\n    if2_use: IF2Parametric,\r\n    rf_filter: RFBPF,\r\n    mixer1: Mixer,\r\n    mixer2: Mixer,\r\n    cfg: Config,\r\n    inj1: int,\r\n    s2: int,\r\n    carriers_lo1,\r\n    carriers_lo2,\r\n    rf_center_nominal: float,\r\n    if1_step: float,\r\n    rf_step: float,\r\n) -> Tuple[float, float]:\r\n    \"\"\"\r\n    Evaluate worst-case margin under ± half-step perturbations of IF1 and RF centers.\r\n    We keep the LO/IF2 settings fixed and only change the evaluation reference.\r\n    Returns (robust_min_margin, brittleness_db_per_step).\r\n    \"\"\"\r\n    margins = [float(base_summary.worst_margin_db)]\r\n\r\n    # IF1 ± half step (true recomputation, because IF2 desired depends on IF1)\r\n    for sign in (+1, -1):\r\n        if1_pert = Band(tile_if1.center_hz + sign * 0.5 * if1_step, tile_if1.bw_hz)\r\n        # Robustness guard: if desired IF2 drifts outside the IF2 passband, treat as hard fail\r\n        if2_des_center = abs(inj1 * lo1.f_out_hz - if1_pert.center_hz)\r\n        if not if2_use.contains_desired(center=if2_des_center, bw=if1_pert.bw_hz):\r\n            margins.append(-1e9)\r\n            continue\r\n        summ = enumerate_spurs(\r\n            if1_pert, lo1, lo2, if2_use, rf_filter, mixer1, mixer2, cfg,\r\n            inj1_sign=inj1, s2_sign=s2, carriers_lo1=carriers_lo1, carriers_lo2=carriers_lo2\r\n        )\r\n        margins.append(float(summ.worst_margin_db))\r\n\r\n    # RF ± half step (classification/limit reference moves; hardware fixed)\r\n    for sign in (+1, -1):\r\n        rf_ref = rf_center_nominal + sign * 0.5 * rf_step\r\n        summ = enumerate_spurs(\r\n            tile_if1, lo1, lo2, if2_use, rf_filter, mixer1, mixer2, cfg,\r\n            inj1_sign=inj1, s2_sign=s2, carriers_lo1=carriers_lo1, carriers_lo2=carriers_lo2,\r\n            rf_center_override_hz=rf_ref, rf_bw_override_hz=tile_if1.bw_hz,\r\n        )\r\n        margins.append(float(summ.worst_margin_db))\r\n\r\n    robust = float(min(margins))\r\n    drop = float(max(margins) - robust) if margins else 0.0\r\n    # Keep unit as \"drop in dB\"\r\n    brittleness = drop\r\n    return robust, brittleness\r\n\r\n\r\ndef _eval_tile(task_args) -> tuple[PlanRow | None, list[dict], dict] | None:\r\n    \"\"\"\r\n    Worker function: evaluate one tile with carriers, early rejects, RF-BPF choice,\r\n    robustness, and alternatives within Δ dB of best.\r\n    Returns (best_row, alternatives_list, ledger_for_best) or None if no candidate.\r\n    \"\"\"\r\n    t, cfg_dict, models_dir = task_args\r\n\r\n    # Use process-global cache (initializer populates this)\r\n    global _MODELS\r\n    if _MODELS is None:\r\n        _init_models_once(models_dir, cfg_dict)\r\n    cache = _MODELS\r\n\r\n    cfg = Config(**cache[\"cfg_dict\"])\r\n\r\n    # Load models from cache\r\n    mixer1_mdls: List[Mixer] = cache[\"mixer1\"]\r\n    mixer2_mdls: List[Mixer] = cache[\"mixer2\"]\r\n    lo1_synths: List[Synth] = cache[\"lo1s\"]\r\n    lo2_synths: List[Synth] = cache[\"lo2s\"]\r\n    rf_filters: List[RFBPF] = cache[\"rfs\"]\r\n    if2_yaml = cache[\"if2yaml\"]\r\n\r\n    # ---- Optional: \"search-order thinning\" (keep parity via re-score later) ----\r\n    orig_cfg = Config(**cfg_dict)  # exact original for parity/scoring\r\n    used_thin_orders = False\r\n    search_mn = getattr(cfg.search, \"search_orders_mn_abs\", None)\r\n    search_sum = getattr(cfg.search, \"search_cross_sum_max\", None)\r\n    if (search_mn is not None) or (search_sum is not None):\r\n        cfg = cfg.model_copy()\r\n        if search_mn is not None:\r\n            cfg.orders.m1n1_max_abs = int(search_mn)\r\n            cfg.orders.m2n2_max_abs = int(search_mn)\r\n            used_thin_orders = True\r\n        if search_sum is not None:\r\n            cfg.orders.cross_stage_sum_max = int(search_sum)\r\n            used_thin_orders = True\r\n\r\n    def _f(x, default=None):\r\n        if x is None:\r\n            return float(default) if default is not None else None\r\n        try:\r\n            return float(x)\r\n        except (TypeError, ValueError):\r\n            return float(str(x))\r\n\r\n    if2_pass_il = _f(if2_yaml.get(\"passband_il_db\", 1.0), 1.0)\r\n    if2_floor = _f(if2_yaml.get(\"stop_floor_db\", -80.0), -80.0)\r\n    if2_roll = _f(if2_yaml.get(\"rolloff_db_per_dec\", 40.0), 40.0)\r\n    if2_min_bw = _f(if2_yaml.get(\"min_bw_hz\", 500e6), 500e6)\r\n    if2_max_bw = _f(if2_yaml.get(\"max_bw_hz\", 6000e6), 6000e6)\r\n    _cr = if2_yaml.get(\"center_range_hz\", [500e6, 9000e6]) or [500e6, 9000e6]\r\n    if2_center_range = (_f(_cr[0], 500e6), _f(_cr[1], 9000e6))\r\n\r\n    # Search parameters (if present)\r\n    search_cfg = (if2_yaml.get(\"search\") or {})\r\n    # seeds_per_tile controls center/BW seed densities deterministically\r\n    seeds_per_tile = int(search_cfg.get(\"seeds_per_tile\", 8) or 8)\r\n    refine_kind = str(search_cfg.get(\"local_refinement\", \"coordinate_descent\"))\r\n    max_refine_iters = int(search_cfg.get(\"max_refine_iters\", 12) or 12)\r\n\r\n    tile_if1 = Band(t.if1_center_hz, t.bw_hz)\r\n    best_row: PlanRow | None = None\r\n    best_summary = None\r\n    best_score = -1e9\r\n    alternatives: list[dict] = []\r\n    best_ledger: dict = {}\r\n\r\n    # --- Derive IF2 seeds: local neighborhood + global anchors ---\r\n    num_c = max(3, int(seeds_per_tile))\r\n    center_lo_mul, center_hi_mul = 0.7, 1.3\r\n    local_center_seeds = [float(np.clip(m * t.if1_center_hz, if2_center_range[0], if2_center_range[1]))\r\n                          for m in np.linspace(center_lo_mul, center_hi_mul, num_c)]\r\n    # A few coarse global anchors spanning the allowed IF2 center range\r\n    global_anchors = list(np.linspace(if2_center_range[0], if2_center_range[1], 4))\r\n    if2_center_seeds = sorted(set(map(float, [*local_center_seeds, *global_anchors])))\r\n\r\n    # IF2 BW seeds around required BW\r\n    base_bw_low, base_bw_high = 1.05, 1.5\r\n    n_bw = int(max(2, min(5, math.ceil(seeds_per_tile / 3))))\r\n    if n_bw == 2:\r\n        bw_seed_muls = (base_bw_low, base_bw_high)\r\n    else:\r\n        bw_seed_muls = tuple(np.linspace(base_bw_low, base_bw_high, n_bw))\r\n    bw_seed_list = bw_seed_muls\r\n\r\n    # Fast/legacy toggle\r\n    use_fast = bool(getattr(cfg.search, \"enable_snapped_lo_search\", True))\r\n    base_N = int(getattr(cfg.search, \"lo_snap_window_steps\", 2))\r\n    expand_sched = list(getattr(cfg.search, \"lo_snap_expand_schedule\", [2, 4, 8]))\r\n    hard_max = int(getattr(cfg.search, \"lo_snap_max_window_steps\", 8))\r\n    cap_per_lo = getattr(cfg.search, \"per_lo_candidate_cap\", None)\r\n    include_lo2_alt = bool(getattr(cfg.search, \"include_lo2_alt_form\", False))\r\n\r\n    # respect optional desired sign locks (±1) for desired path\r\n    desired_s1 = getattr(cfg.constraints, \"desired_stage1_sign\", None)\r\n    desired_s2 = getattr(cfg.constraints, \"desired_stage2_sign\", None)\r\n    inj1_opts = ([int(desired_s1)] if desired_s1 in (-1, 1) else (+1, -1))\r\n    s2_opts = ([int(desired_s2)] if desired_s2 in (-1, 1) else (+1, -1))\r\n\r\n    for mixer1 in mixer1_mdls:\r\n        for mixer2 in mixer2_mdls:\r\n            for inj1 in inj1_opts:\r\n                for if2c_seed in if2_center_seeds:\r\n                    for bw_mul in bw_seed_list:\r\n                        if2_bw_seed = float(np.clip(bw_mul * t.bw_hz, if2_min_bw, if2_max_bw))\r\n                        if2_template = IF2Parametric(if2c_seed, if2_bw_seed, if2_pass_il, if2_floor, if2_roll)\r\n\r\n                        # Stage-1 target LO1s from seed center; include (IF2+IF1) and (IF2-IF1) if >0\r\n                        lo1_targets = [inj1 * (if2c_seed + t.if1_center_hz)]\r\n                        alt_t = inj1 * (if2c_seed - t.if1_center_hz)\r\n                        if alt_t > 0:\r\n                            lo1_targets.append(alt_t)\r\n\r\n                        # Enumerate LO1 candidates via snapped neighborhoods (or legacy)\r\n                        lo1_settings = []\r\n                        for lo1_synth in lo1_synths:\r\n                            if use_fast:\r\n                                lo1_settings.extend(_neighborhood_solutions(\r\n                                    synth=lo1_synth,\r\n                                    f_targets=lo1_targets,\r\n                                    path=\"lo1\",\r\n                                    drive_min=mixer1.mdl.required_lo_drive_dbm[\"min\"],\r\n                                    drive_max=mixer1.mdl.required_lo_drive_dbm[\"max\"],\r\n                                    base_N=base_N,\r\n                                    expand_sched=expand_sched,\r\n                                    hard_max=hard_max,\r\n                                    cap=cap_per_lo,\r\n                                    bw_hz_for_fallback=t.bw_hz,\r\n                                ))\r\n                            else:\r\n                                fmin1 = max(1.0, min(lo1_targets) - 3 * t.bw_hz)\r\n                                fmax1 = max(lo1_targets) + 3 * t.bw_hz\r\n                                lo1_settings.extend(lo1_synth.legal_settings(\r\n                                    name_filter=None,\r\n                                    f_min=fmin1,\r\n                                    f_max=fmax1,\r\n                                    path=\"lo1\",\r\n                                    drive_min_dbm=mixer1.mdl.required_lo_drive_dbm[\"min\"],\r\n                                    drive_max_dbm=mixer1.mdl.required_lo_drive_dbm[\"max\"],\r\n                                ))\r\n                        if not lo1_settings:\r\n                            continue\r\n\r\n                        for lo1 in lo1_settings:\r\n                            # Require desired IF2 band to be inside the IF2 passband\r\n                            if2_des_center = abs(inj1 * lo1.f_out_hz - t.if1_center_hz)\r\n                            if not if2_template.contains_desired(if2_des_center, t.bw_hz):\r\n                                continue\r\n\r\n                            for s2 in s2_opts:\r\n                                # Stage-2 targets\r\n                                cand2 = [s2 * (t.rf_center_hz - if2c_seed)]\r\n                                if include_lo2_alt:\r\n                                    cand2.append(s2 * (-t.rf_center_hz - if2c_seed))\r\n\r\n                                lo2_settings = []\r\n                                for lo2_synth in lo2_synths:\r\n                                    if use_fast:\r\n                                        lo2_settings.extend(_neighborhood_solutions(\r\n                                            synth=lo2_synth,\r\n                                            f_targets=cand2,\r\n                                            path=\"lo2\",\r\n                                            drive_min=mixer2.mdl.required_lo_drive_dbm[\"min\"],\r\n                                            drive_max=mixer2.mdl.required_lo_drive_dbm[\"max\"],\r\n                                            base_N=base_N,\r\n                                            expand_sched=expand_sched,\r\n                                            hard_max=hard_max,\r\n                                            cap=cap_per_lo,\r\n                                            bw_hz_for_fallback=t.bw_hz,\r\n                                        ))\r\n                                    else:\r\n                                        fmin2 = min(cand2) - 3 * t.bw_hz\r\n                                        fmax2 = max(cand2) + 3 * t.bw_hz\r\n                                        lo2_settings.extend(lo2_synth.legal_settings(\r\n                                            name_filter=None,\r\n                                            f_min=max(1.0, fmin2),\r\n                                            f_max=fmax2,\r\n                                            path=\"lo2\",\r\n                                            drive_min_dbm=mixer2.mdl.required_lo_drive_dbm[\"min\"],\r\n                                            drive_max_dbm=mixer2.mdl.required_lo_drive_dbm[\"max\"],\r\n                                        ))\r\n                                if not lo2_settings:\r\n                                    continue\r\n\r\n                                for lo2 in lo2_settings:\r\n                                    # Verify desired RF placement under these LOs\r\n                                    _, rf_des_chk = desired_paths(tile_if1, lo1.f_out_hz, lo2.f_out_hz, inj1, s2)\r\n                                    if abs(rf_des_chk.center_hz - t.rf_center_hz) > (cfg.grids.rf_center_step_hz * 0.5 + 1e3):\r\n                                        continue\r\n\r\n                                    # Build equivalent carriers (with divider-spectrum behavior) using chosen PFD\r\n                                    mode1 = next((m for m in lo1_synths[0].mdl.modes if m.name == lo1.mode), None)\r\n                                    if mode1 is None:\r\n                                        # fetch from the specific synth used to create lo1\r\n                                        for s in lo1_synths:\r\n                                            if s.mdl.name == lo1.name:\r\n                                                mode1 = next((m for m in s.mdl.modes if m.name == lo1.mode), s.mdl.modes[0])\r\n                                                break\r\n                                    mode2 = next((m for m in lo2_synths[0].mdl.modes if m.name == lo2.mode), None)\r\n                                    if mode2 is None:\r\n                                        for s in lo2_synths:\r\n                                            if s.mdl.name == lo2.name:\r\n                                                mode2 = next((m for m in s.mdl.modes if m.name == lo2.mode), s.mdl.modes[0])\r\n                                                break\r\n                                    # use the synth that matches the LO name for carriers\r\n                                    s1_for_car = next((s for s in lo1_synths if s.mdl.name == lo1.name), lo1_synths[0])\r\n                                    s2_for_car = next((s for s in lo2_synths if s.mdl.name == lo2.name), lo2_synths[0])\r\n                                    C1 = s1_for_car.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n                                    C2 = s2_for_car.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n\r\n                                    # Desired RF band must be inside RF BPF passband\r\n                                    for rf_filter in rf_filters:\r\n                                        if not _rf_band_ok(rf_filter, rf_des_chk.center_hz, t.bw_hz, max_il_db=3.0):\r\n                                            continue\r\n\r\n                                        # Early reject gates\r\n                                        if _early_reject_gate(tile_if1, lo1.f_out_hz, lo2.f_out_hz, inj1, s2, if2_template, rf_filter, cfg):\r\n                                            continue\r\n\r\n                                        # --- IF2 refinement (coordinate descent + memo) ---\r\n                                        if refine_kind == \"coordinate_descent\" and max_refine_iters > 0:\r\n                                            if2_const = {\r\n                                                \"passband_il_db\": if2_pass_il,\r\n                                                \"stop_floor_db\": if2_floor,\r\n                                                \"rolloff_db_per_dec\": if2_roll,\r\n                                            }\r\n                                            if2_use = _coordinate_descent_if2(\r\n                                                if2_const=if2_const,\r\n                                                seed_center_hz=if2c_seed,\r\n                                                seed_bw_hz=if2_bw_seed,\r\n                                                tile_if1=tile_if1,\r\n                                                lo1=lo1,\r\n                                                lo2=lo2,\r\n                                                rf_filter=rf_filter,\r\n                                                mixer1=mixer1,\r\n                                                mixer2=mixer2,\r\n                                                cfg=cfg,\r\n                                                inj1=inj1,\r\n                                                s2=s2,\r\n                                                carriers_lo1=C1,\r\n                                                carriers_lo2=C2,\r\n                                                max_iters=max_refine_iters,\r\n                                                step_frac_center=0.1,\r\n                                                step_frac_bw=0.15,\r\n                                                bw_limits=(if2_min_bw, if2_max_bw),\r\n                                                center_limits=if2_center_range,\r\n                                            )\r\n                                        else:\r\n                                            if2_use = if2_template\r\n\r\n                                        # Base evaluation (possibly under thinned orders)\r\n                                        summ = enumerate_spurs(\r\n                                            tile_if1,\r\n                                            lo1,\r\n                                            lo2,\r\n                                            if2_use,\r\n                                            rf_filter,\r\n                                            mixer1,\r\n                                            mixer2,\r\n                                            cfg,\r\n                                            inj1_sign=inj1,\r\n                                            s2_sign=s2,\r\n                                            carriers_lo1=C1,\r\n                                            carriers_lo2=C2,\r\n                                        )\r\n\r\n                                        # Robustness evaluation (± half-steps) with IF2 containment guard\r\n                                        robust_margin, brittleness = _robustness_score(\r\n                                            base_summary=summ,\r\n                                            tile_if1=tile_if1,\r\n                                            lo1=lo1,\r\n                                            lo2=lo2,\r\n                                            if2_use=if2_use,\r\n                                            rf_filter=rf_filter,\r\n                                            mixer1=mixer1,\r\n                                            mixer2=mixer2,\r\n                                            cfg=cfg,\r\n                                            inj1=inj1,\r\n                                            s2=s2,\r\n                                            carriers_lo1=C1,\r\n                                            carriers_lo2=C2,\r\n                                            rf_center_nominal=t.rf_center_hz,\r\n                                            if1_step=cfg.grids.if1_center_step_hz,\r\n                                            rf_step=cfg.grids.rf_center_step_hz,\r\n                                        )\r\n\r\n                                        score = robust_margin\r\n\r\n                                        # Construct row for this candidate\r\n                                        row = PlanRow(\r\n                                            tile_id=t.id,\r\n                                            if1_center_hz=t.if1_center_hz,\r\n                                            bw_hz=t.bw_hz,\r\n                                            rf_center_hz=t.rf_center_hz,\r\n                                            lo1_name=lo1.name,\r\n                                            lo1_hz=lo1.f_out_hz,\r\n                                            lo1_mode=lo1.mode,\r\n                                            lo1_divider=lo1.divider,\r\n                                            lo1_pad_db=lo1.pad_db,\r\n                                            lo1_lock_ms=lo1.lock_time_ms,\r\n                                            lo2_name=lo2.name,\r\n                                            lo2_hz=lo2.f_out_hz,\r\n                                            lo2_mode=lo2.mode,\r\n                                            lo2_divider=lo2.divider,\r\n                                            lo2_pad_db=lo2.pad_db,\r\n                                            lo2_lock_ms=lo2.lock_time_ms,\r\n                                            if2_center_hz=if2_use.center_hz,\r\n                                            if2_bw_hz=if2_use.bw_hz,\r\n                                            rf_bpf_id=rf_filter.id,\r\n                                            spur_margin_db=score,\r\n                                            brittleness_db_per_step=brittleness,\r\n                                            desired_stage1_sign=inj1,\r\n                                            desired_stage2_sign=s2,\r\n                                        )\r\n\r\n                                        if (best_row is None) or (score > best_score + 1e-9):\r\n                                            # New best: reset alternatives\r\n                                            best_row = row\r\n                                            best_summary = summ\r\n                                            best_score = score\r\n                                            alternatives = []\r\n                                            # capture ledger (bins) for the current best\r\n                                            best_ledger = {\r\n                                                \"rf_center_hz\": float(summ.desired_rf_band.center_hz),\r\n                                                \"rf_bw_hz\": float(summ.desired_rf_band.bw_hz),\r\n                                                \"bins\": [\r\n                                                    {\r\n                                                        \"f_rf_hz\": b.f_rf_hz,\r\n                                                        \"combined_level_dbc\": b.level_dbc,\r\n                                                        \"inband\": b.inband,\r\n                                                        \"limit_dbc\": b.info.get(\"limit_dbc\"),\r\n                                                        \"margin_db\": b.info.get(\"margin_db\"),\r\n                                                    }\r\n                                                    for b in summ.bins\r\n                                                ],\r\n                                            }\r\n                                        else:\r\n                                            # Track alternatives within Δ dB of best\r\n                                            if best_row is not None and (best_score - score) <= float(cfg.targets.alt_within_db + 1e-9):\r\n                                                alternatives.append({\r\n                                                    \"delta_margin_db\": float(best_score - score),\r\n                                                    \"row\": asdict(row),\r\n                                                })\r\n\r\n    if best_row is None:\r\n        return None\r\n\r\n    # If we used thinned orders for speed, re-score the selected BEST at full/original orders for parity.\r\n    if used_thin_orders and best_summary is not None:\r\n        full_cfg = orig_cfg\r\n        # Recompute carriers (same synths) for the chosen LOs\r\n        lo1_synth = next((s for s in lo1_synths if s.mdl.name == best_row.lo1_name), lo1_synths[0])\r\n        lo2_synth = next((s for s in lo2_synths if s.mdl.name == best_row.lo2_name), lo2_synths[0])\r\n        mode1 = next((m for m in lo1_synth.mdl.modes if m.name == best_row.lo1_mode), lo1_synth.mdl.modes[0])\r\n        mode2 = next((m for m in lo2_synth.mdl.modes if m.name == best_row.lo2_mode), lo2_synth.mdl.modes[0])\r\n        # Minimal LOSolution-like shims using best_row fields\r\n        class _Shim:\r\n            def __init__(self, name, mode, f_out_hz, divider, delivered_dbm, lock_time_ms, pad_db, pfd_hz):\r\n                self.name=name; self.mode=mode; self.f_out_hz=f_out_hz; self.divider=divider\r\n                self.delivered_dbm=delivered_dbm; self.lock_time_ms=lock_time_ms; self.pad_db=pad_db; self.pfd_hz=pfd_hz\r\n        lo1 = _Shim(best_row.lo1_name, best_row.lo1_mode, best_row.lo1_hz, best_row.lo1_divider, 0.0, best_row.lo1_lock_ms, best_row.lo1_pad_db, 10e6)\r\n        lo2 = _Shim(best_row.lo2_name, best_row.lo2_mode, best_row.lo2_hz, best_row.lo2_divider, 0.0, best_row.lo2_lock_ms, best_row.lo2_pad_db, 10e6)\r\n        C1 = lo1_synth.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n        C2 = lo2_synth.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n        rf_filter = next((rf for rf in rf_filters if rf.id == best_row.rf_bpf_id), rf_filters[0])\r\n        if2_use = IF2Parametric(best_row.if2_center_hz, best_row.if2_bw_hz,\r\n                                if2_pass_il, if2_floor, if2_roll)\r\n        mixer1 = mixer1_mdls[0] if mixer1_mdls else None\r\n        mixer2 = mixer2_mdls[0] if mixer2_mdls else None\r\n        if mixer1 and mixer2:\r\n            summ_full = enumerate_spurs(\r\n                Band(best_row.if1_center_hz, best_row.bw_hz),\r\n                lo1, lo2, if2_use, rf_filter, mixer1, mixer2, full_cfg,\r\n                inj1_sign=best_row.desired_stage1_sign,\r\n                s2_sign=best_row.desired_stage2_sign,\r\n                carriers_lo1=C1, carriers_lo2=C2\r\n            )\r\n            # overwrite margin (and ledger) with full-order result\r\n            best_row.spur_margin_db = float(summ_full.worst_margin_db)\r\n            best_ledger = {\r\n                \"rf_center_hz\": float(summ_full.desired_rf_band.center_hz),\r\n                \"rf_bw_hz\": float(summ_full.desired_rf_band.bw_hz),\r\n                \"bins\": [\r\n                    {\r\n                        \"f_rf_hz\": b.f_rf_hz,\r\n                        \"combined_level_dbc\": b.level_dbc,\r\n                        \"inband\": b.inband,\r\n                        \"limit_dbc\": b.info.get(\"limit_dbc\"),\r\n                        \"margin_db\": b.info.get(\"margin_db\"),\r\n                    }\r\n                    for b in summ_full.bins\r\n                ],\r\n            }\r\n\r\n    # Rank alternatives (smallest delta first)\r\n    alternatives.sort(key=lambda d: d.get(\"delta_margin_db\", 999.0))\r\n    # Attach rank\r\n    for i, a in enumerate(alternatives, 1):\r\n        a[\"rank\"] = i\r\n\r\n    return best_row, alternatives, best_ledger\r\n\r\n\r\n# ---- Retune/lock accounting with Δf and penalties ----------------------------\r\n\r\ndef _mode_lookup(lo_mdl: LOMdl, name: str) -> Optional[Mode]:\r\n    for m in lo_mdl.modes:\r\n        if m.name == name:\r\n            return m\r\n    return lo_mdl.modes[0] if lo_mdl.modes else None\r\n\r\n\r\ndef _lock_time_for_hop(prev_hz: float, prev_mode: str, prev_divider: str,\r\n                       curr_hz: float, curr_mode: str, curr_divider: str,\r\n                       lo_mdl: LOMdl) -> float:\r\n    mode = _mode_lookup(lo_mdl, curr_mode)\r\n    if mode is None:\r\n        return 0.0\r\n    base = float(mode.lock_time_model.base_ms)\r\n    slope = float(getattr(mode.lock_time_model, \"per_mhz_ms\", 0.0))\r\n    df_mhz = abs(curr_hz - prev_hz) / 1e6\r\n    t = base + slope * df_mhz\r\n    # crude penalties for mode/divider changes (if provided)\r\n    penalties = mode.lock_time_model.mode_penalties_ms or {}\r\n    if prev_mode != curr_mode:\r\n        t += float(penalties.get(\"mode_change\", penalties.get(\"int_to_frac\", 0.0)))\r\n    if prev_divider != curr_divider:\r\n        t += float(penalties.get(\"divider_change\", 0.0))\r\n    return t\r\n\r\n\r\ndef _retune_accounting(rows: List[PlanRow], lo_models_by_name: Dict[str, LOMdl]) -> dict:\r\n    \"\"\"\r\n    Uniform traversal retune/lock accounting using hop size and penalties.\r\n    Works even if the LO type changes between rows by using the *destination* row model.\r\n    \"\"\"\r\n    if not rows:\r\n        return {\"total_lock_ms\": 0.0, \"retunes\": 0, \"avg_lock_ms_per_hop\": 0.0}\r\n\r\n    total_lock = 0.0\r\n    retunes = 0\r\n    hops = 0\r\n\r\n    prev = rows[0]\r\n    for r in rows[1:]:\r\n        hops += 1\r\n        changed = False\r\n        # LO1 hop\r\n        if abs(r.lo1_hz - prev.lo1_hz) > 0.5 or (r.lo1_mode != prev.lo1_mode) or (r.lo1_divider != prev.lo1_divider) or (r.lo1_name != prev.lo1_name):\r\n            mdl = lo_models_by_name.get(r.lo1_name)\r\n            if mdl is not None:\r\n                total_lock += _lock_time_for_hop(prev.lo1_hz, prev.lo1_mode, prev.lo1_divider,\r\n                                                 r.lo1_hz, r.lo1_mode, r.lo1_divider, mdl)\r\n            changed = True\r\n        # LO2 hop\r\n        if abs(r.lo2_hz - prev.lo2_hz) > 0.5 or (r.lo2_mode != prev.lo2_mode) or (r.lo2_divider != prev.lo2_divider) or (r.lo2_name != prev.lo2_name):\r\n            mdl = lo_models_by_name.get(r.lo2_name)\r\n            if mdl is not None:\r\n                total_lock += _lock_time_for_hop(prev.lo2_hz, prev.lo2_mode, prev.lo2_divider,\r\n                                                 r.lo2_hz, r.lo2_mode, r.lo2_divider, mdl)\r\n            changed = True\r\n        if changed:\r\n            retunes += 1\r\n        prev = r\r\n\r\n    avg = total_lock / max(1, hops)\r\n    return {\"total_lock_ms\": float(total_lock), \"retunes\": int(retunes), \"avg_lock_ms_per_hop\": float(avg)}\r\n\r\n\r\n# ---- Merge/smoothing (spans) -------------------------------------------------\r\n\r\ndef _same_settings(a: PlanRow, b: PlanRow, eps_hz=500.0) -> bool:\r\n    return (\r\n        a.lo1_name == b.lo1_name and\r\n        a.lo2_name == b.lo2_name and\r\n        abs(a.lo1_hz - b.lo1_hz) < eps_hz and\r\n        abs(a.lo2_hz - b.lo2_hz) < eps_hz and\r\n        a.lo1_mode == b.lo1_mode and\r\n        a.lo2_mode == b.lo2_mode and\r\n        a.lo1_divider == b.lo1_divider and\r\n        a.lo2_divider == b.lo2_divider and\r\n        abs(a.if2_center_hz - b.if2_center_hz) < 1e3 and\r\n        abs(a.if2_bw_hz - b.if2_bw_hz) < 1e3 and\r\n        a.rf_bpf_id == b.rf_bpf_id and\r\n        a.desired_stage1_sign == b.desired_stage1_sign and\r\n        a.desired_stage2_sign == b.desired_stage2_sign\r\n    )\r\n\r\ndef _merge_adjacent(rows: list[PlanRow]) -> list[PlanRow]:\r\n    \"\"\"\r\n    Simple pass: along the sorted tile order, merge consecutive rows with identical settings\r\n    by keeping the one with better margin (acts as a coalescer rather than producing spans).\r\n    \"\"\"\r\n    if not rows:\r\n        return rows\r\n    merged = [rows[0]]\r\n    for r in rows[1:]:\r\n        if _same_settings(merged[-1], r):\r\n            if r.spur_margin_db > merged[-1].spur_margin_db:\r\n                merged[-1] = r\r\n        else:\r\n            merged.append(r)\r\n    return merged\r\n\r\ndef _emit_spans(rows: list[PlanRow]) -> list[dict]:\r\n    \"\"\"\r\n    Produce RF spans for each IF1/BW where settings are identical across consecutive RF tiles.\r\n    This is a 1D run-length merge along RF for each IF1 center; rectangular spans across IF1\r\n    are left for later sophistication.\r\n    \"\"\"\r\n    spans: list[dict] = []\r\n    if not rows:\r\n        return spans\r\n    # Group by (if1_center, bw)\r\n    from collections import defaultdict\r\n    groups: dict[tuple[float,float], list[PlanRow]] = defaultdict(list)\r\n    for r in rows:\r\n        groups[(r.if1_center_hz, r.bw_hz)].append(r)\r\n    for (if1c, bw), gr in groups.items():\r\n        gr_sorted = sorted(gr, key=lambda x: x.rf_center_hz)\r\n        start = gr_sorted[0]\r\n        last = gr_sorted[0]\r\n        for r in gr_sorted[1:]:\r\n            if _same_settings(last, r):\r\n                # continue span\r\n                last = r\r\n            else:\r\n                spans.append({\r\n                    \"if1_center_hz\": float(if1c),\r\n                    \"bw_hz\": float(bw),\r\n                    \"rf_from_hz\": float(start.rf_center_hz),\r\n                    \"rf_to_hz\": float(last.rf_center_hz),\r\n                    \"settings\": {\r\n                        \"lo1_name\": start.lo1_name, \"lo1_hz\": start.lo1_hz, \"lo1_mode\": start.lo1_mode, \"lo1_divider\": start.lo1_divider, \"lo1_pad_db\": start.lo1_pad_db,\r\n                        \"lo2_name\": start.lo2_name, \"lo2_hz\": start.lo2_hz, \"lo2_mode\": start.lo2_mode, \"lo2_divider\": start.lo2_divider, \"lo2_pad_db\": start.lo2_pad_db,\r\n                        \"if2_center_hz\": start.if2_center_hz, \"if2_bw_hz\": start.if2_bw_hz, \"rf_bpf_id\": start.rf_bpf_id,\r\n                        \"desired_stage1_sign\": start.desired_stage1_sign, \"desired_stage2_sign\": start.desired_stage2_sign\r\n                    }\r\n                })\r\n                start = r; last = r\r\n        # flush last span\r\n        spans.append({\r\n            \"if1_center_hz\": float(if1c),\r\n            \"bw_hz\": float(bw),\r\n            \"rf_from_hz\": float(start.rf_center_hz),\r\n            \"rf_to_hz\": float(last.rf_center_hz),\r\n            \"settings\": {\r\n                \"lo1_name\": start.lo1_name, \"lo1_hz\": start.lo1_hz, \"lo1_mode\": start.lo1_mode, \"lo1_divider\": start.lo1_divider, \"lo1_pad_db\": start.lo1_pad_db,\r\n                \"lo2_name\": start.lo2_name, \"lo2_hz\": start.lo2_hz, \"lo2_mode\": start.lo2_mode, \"lo2_divider\": start.lo2_divider, \"lo2_pad_db\": start.lo2_pad_db,\r\n                \"if2_center_hz\": start.if2_center_hz, \"if2_bw_hz\": start.if2_bw_hz, \"rf_bpf_id\": start.rf_bpf_id,\r\n                \"desired_stage1_sign\": start.desired_stage1_sign, \"desired_stage2_sign\": start.desired_stage2_sign\r\n            }\r\n        })\r\n    return spans\r\n\r\n\r\n# ---- Driver ------------------------------------------------------------------\r\n\r\ndef optimize(cfg: Config, models_dir: str, input_files: list[str] | None = None,\r\n             progress_cb: Optional[Callable[[int], None]] = None) -> Dict:\r\n    \"\"\"\r\n    Optimize policy across all tiles in parallel.\r\n    Adds: alternatives-within-ΔdB, robustness perturbations, multi-device search,\r\n    RF passband edge checks, retune accounting with Δf and penalties.\r\n    Export spur ledgers for best per-tile and coverage gaps; broaden LO search windows (P2);\r\n    generate RF spans per IF1/BW (P2); include file hashes and package versions (P1).\r\n    **NEW**: process-global model cache; IF2 refinement memoization; wider LO2 harmonic quick-screen.\r\n    \"\"\"\r\n    # Deterministic tiles\r\n    tiles = make_tiles(\r\n        cfg.bands.if1_hz.min,\r\n        cfg.bands.if1_hz.max,\r\n        cfg.bands.rf_hz.min,\r\n        cfg.bands.rf_hz.max,\r\n        cfg.grids.bw_grid_hz,\r\n        cfg.grids.if1_center_step_hz,\r\n        cfg.grids.rf_center_step_hz,\r\n    )\r\n\r\n    # Parallel evaluation\r\n    tasks = [(t, cfg.model_dump(), models_dir) for t in tiles]\r\n    rows: List[PlanRow] = []\r\n    alts_by_tile: dict[int, list[dict]] = {}\r\n    ledgers_by_tile: dict[int, dict] = {}\r\n    gaps: list[dict] = []\r\n\r\n    # Wrap executor loop with an auto progress context when no callback was given\r\n    with _progress_ctx(total=len(tasks), desc=\"Tiles\", provided_cb=progress_cb) as _update:\r\n        with ProcessPoolExecutor(\r\n            max_workers=os.cpu_count(),\r\n            initializer=_init_models_once,\r\n            initargs=(models_dir, cfg.model_dump()),\r\n        ) as ex:\r\n            futs = [ex.submit(_eval_tile, args) for args in tasks]\r\n            for f in as_completed(futs):\r\n                try:\r\n                    res = f.result()\r\n                    if res is not None:\r\n                        best_row, alts, ledger = res\r\n                        rows.append(best_row)\r\n                        if alts:\r\n                            alts_by_tile[best_row.tile_id] = alts\r\n                        if ledger:\r\n                            ledgers_by_tile[best_row.tile_id] = ledger\r\n                    else:\r\n                        # No legal candidate for this tile\r\n                        pass\r\n                finally:\r\n                    try:\r\n                        _update(1)\r\n                    except Exception:\r\n                        pass\r\n\r\n    rows.sort(key=lambda r: r.tile_id)\r\n\r\n    # Identify missing tiles (coverage gaps) and tiles below target margin\r\n    present_ids = {r.tile_id for r in rows}\r\n    all_ids = {t.id for t in tiles}\r\n    missing = sorted(all_ids - present_ids)\r\n    for tid in missing:\r\n        # Recover basic tile info\r\n        t = next(tt for tt in tiles if tt.id == tid)\r\n        gaps.append({\r\n            \"tile_id\": tid,\r\n            \"if1_center_hz\": float(t.if1_center_hz),\r\n            \"bw_hz\": float(t.bw_hz),\r\n            \"rf_center_hz\": float(t.rf_center_hz),\r\n            \"reason\": \"no_legal_candidate\"\r\n        })\r\n    # Low margin\r\n    for r in rows:\r\n        if r.spur_margin_db < float(cfg.targets.min_margin_db):\r\n            gaps.append({\r\n                \"tile_id\": int(r.tile_id),\r\n                \"if1_center_hz\": float(r.if1_center_hz),\r\n                \"bw_hz\": float(r.bw_hz),\r\n                \"rf_center_hz\": float(r.rf_center_hz),\r\n                \"reason\": \"margin_below_target\",\r\n                \"margin_db\": float(r.spur_margin_db),\r\n                \"target_db\": float(cfg.targets.min_margin_db)\r\n            })\r\n\r\n    # ---- second-pass policy-level selection (tie-break by retune/lock and brittleness) ----\r\n    # Build LO model lookup by name for hop computations (also used later for accounting)\r\n    lo_models_by_name: Dict[str, LOMdl] = {}\r\n    for path in (cfg.search.lo1_candidates + cfg.search.lo2_candidates):\r\n        mdl = LOMdl(**_load_yaml(models_dir, path))\r\n        lo_models_by_name[mdl.name] = mdl\r\n\r\n    # Create candidate set per tile: best + alternatives (within Δ dB)\r\n    from collections import defaultdict\r\n    candidates_by_tile: dict[int, list[PlanRow]] = defaultdict(list)\r\n    for r in rows:\r\n        candidates_by_tile[r.tile_id].append(r)\r\n    for tid, alts in (alts_by_tile or {}).items():\r\n        for a in alts:\r\n            try:\r\n                candidates_by_tile[int(tid)].append(PlanRow(**a[\"row\"]))\r\n            except Exception:\r\n                # Ignore malformed alternative rows\r\n                pass\r\n\r\n    # Greedy sweep in tile order minimizing cost = -(margin) + λ * hop_lock_ms\r\n    # λ tuned by lock_time_penalty_weight; scale: ~0.1 → 10ms ≈ 1 dB\r\n    lam = max(0.0, float(cfg.runtime_policy.lock_time_penalty_weight))\r\n    lam_scale = 0.1  # ms-to-dB scale\r\n    chosen: list[PlanRow] = []\r\n    prev: PlanRow | None = None\r\n    for t in sorted(candidates_by_tile.keys()):\r\n        candset = candidates_by_tile[t]\r\n        # Stable order: highest margin first; on near ties prefer lower brittleness\r\n        candset.sort(key=lambda c: (-float(c.spur_margin_db), float(c.brittleness_db_per_step),\r\n                                    c.lo1_name, c.lo2_name, c.if2_center_hz, c.if2_bw_hz))\r\n        best_c = None\r\n        best_score = -1e18\r\n        for c in candset:\r\n            hop_ms = 0.0\r\n            if prev is not None:\r\n                # LO1 hop cost\r\n                mdl1 = lo_models_by_name.get(c.lo1_name)\r\n                if mdl1 is not None:\r\n                    hop_ms += _lock_time_for_hop(prev.lo1_hz, prev.lo1_mode, prev.lo1_divider,\r\n                                                 c.lo1_hz, c.lo1_mode, c.lo1_divider, mdl1)\r\n                # LO2 hop cost\r\n                mdl2 = lo_models_by_name.get(c.lo2_name)\r\n                if mdl2 is not None:\r\n                    hop_ms += _lock_time_for_hop(prev.lo2_hz, prev.lo2_mode, prev.lo2_divider,\r\n                                                 c.lo2_hz, c.lo2_mode, c.lo2_divider, mdl2)\r\n            score = float(c.spur_margin_db) - lam_scale * lam * hop_ms\r\n            # Soft preference for lower brittleness when score is effectively equal\r\n            if (score > best_score + 1e-12) or (abs(score - best_score) <= 1e-12 and best_c and\r\n                                                c.brittleness_db_per_step < best_c.brittleness_db_per_step):\r\n                best_score = score\r\n                best_c = c\r\n        if best_c is None:\r\n            # Fallback to the original per-tile best if something went wrong\r\n            best_c = candset[0]\r\n        chosen.append(best_c)\r\n        prev = best_c\r\n\r\n    # Light merge/smoothing (keeps determinism)\r\n    rows = _merge_adjacent(sorted(chosen, key=lambda r: r.tile_id))\r\n\r\n    # Retune/lock-time accounting (uniform traversal) with Δf and penalties\r\n    retune_meta = _retune_accounting(rows, lo_models_by_name)\r\n\r\n    # RF spans (per IF1/BW, along RF)\r\n    spans = _emit_spans(rows)\r\n\r\n    # Hashes and versions\r\n    file_hashes = {}\r\n    for p in (input_files or []):\r\n        try:\r\n            file_hashes[p] = _file_hash(p)\r\n        except Exception:\r\n            file_hashes[p] = \"unavailable\"\r\n    pkg_list = [\"numpy\", \"pandas\", \"scipy\", \"pydantic\", \"pyyaml\", \"jinja2\"]\r\n    versions = {}\r\n    for pkg in pkg_list:\r\n        try:\r\n            versions[pkg] = importlib.metadata.version(pkg)\r\n        except Exception:\r\n            versions[pkg] = \"n/a\"\r\n\r\n    # ---- IF2 window export (unique windows used in the chosen policy) ----\r\n    # We reload IF2 YAML to get constants; windows differ by center/BW here.\r\n    if2_yaml = _load_yaml(models_dir, cfg.search.if2_filter_model)\r\n    pass_il = float(if2_yaml.get(\"passband_il_db\", 1.0))\r\n    floor_db = float(if2_yaml.get(\"stop_floor_db\", -80.0))\r\n    roll_db_dec = float(if2_yaml.get(\"rolloff_db_per_dec\", 40.0))\r\n\r\n    from collections import Counter\r\n    # Round to 1 kHz for uniqueness (consistent with earlier eps used)\r\n    def q1k(x: float) -> float:\r\n        return round(float(x) / 1e3) * 1e3\r\n\r\n    counts = Counter((q1k(r.if2_center_hz), q1k(r.if2_bw_hz)) for r in rows)\r\n    if2_windows = [{\r\n        \"center_hz\": float(k[0]),\r\n        \"bw_hz\": float(k[1]),\r\n        \"passband_il_db\": pass_il,\r\n        \"stop_floor_db\": floor_db,\r\n        \"rolloff_db_per_dec\": roll_db_dec,\r\n        \"use_count\": int(v),\r\n    } for k, v in sorted(counts.items(), key=lambda kv: (kv[0][0], kv[0][1]))]\r\n\r\n    policy = {\r\n        \"project\": cfg.project.model_dump(),\r\n        \"grids\": cfg.grids.model_dump(),\r\n        \"orders\": cfg.orders.model_dump(),\r\n        \"targets\": cfg.targets.model_dump(),\r\n        \"rows\": [asdict(r) for r in rows],\r\n        \"alternatives\": {int(k): v for k, v in alts_by_tile.items() if v},\r\n        \"ledgers\": ledgers_by_tile,  # per-tile best spur bins\r\n        \"spans\": spans,\r\n        \"coverage_gaps\": gaps,\r\n        \"if2_windows\": if2_windows,\r\n        \"meta\": {\r\n            \"deterministic_seed\": cfg.project.seed,\r\n            \"retune_accounting\": retune_meta,\r\n            \"guard_margin_db\": cfg.constraints.guard_margin_db,\r\n            \"file_hashes\": file_hashes,\r\n            \"package_versions\": versions,\r\n        },\r\n    }\r\n    return policy",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "spur.py",
              "path": "src\\bucso\\spur.py",
              "size": 12307,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Optional\r\nimport numpy as np\r\nfrom .utils import Band, coalesce_bins\r\nfrom .filters import IF2Parametric, RFBPF\r\nfrom .mixer import Mixer\r\nfrom .synth import LOSolution, LOCarrier\r\n\r\n\r\n@dataclass\r\nclass BinEntry:\r\n    __slots__ = (\"f_rf_hz\", \"level_dbc\", \"inband\", \"info\")\r\n    f_rf_hz: float\r\n    level_dbc: float\r\n    inband: bool\r\n    info: dict\r\n\r\n\r\n@dataclass\r\nclass TileSummary:\r\n    worst_margin_db: float\r\n    bins: List[BinEntry]\r\n    desired_rf_band: Band\r\n\r\n\r\ndef rbw_width(cfg_rb, bw_hz: float, freq_hz: float) -> float:\r\n    return max(cfg_rb.rbw_hz, cfg_rb.rbw_frac_of_bw * bw_hz, cfg_rb.rbw_ppm_of_freq * freq_hz * 1e-6)\r\n\r\n\r\ndef desired_paths(tile_if1: Band, lo1: float, lo2: float, inj1: int, s2_sign: int) -> tuple[Band, Band]:\r\n    \"\"\"\r\n    Desired path with explicit signs:\r\n      Stage-1 desired: IF2 = | inj1*LO1  -  IF1 |\r\n      Stage-2 desired:  RF  = | s2_sign*LO2  +  IF2 |\r\n    Centers are magnitudes.\r\n    \"\"\"\r\n    if2_center = abs(inj1 * lo1 - tile_if1.center_hz)\r\n    if2 = Band(center_hz=if2_center, bw_hz=tile_if1.bw_hz)\r\n    rf_center = abs(s2_sign * lo2 + if2.center_hz)\r\n    rf = Band(center_hz=rf_center, bw_hz=if2.bw_hz)\r\n    return if2, rf\r\n\r\n\r\ndef _interp_mask_flat_or_table(default_dbc: float, table, x: np.ndarray) -> np.ndarray:\r\n    \"\"\"\r\n    Returns a vector of limits starting from default_dbc, optionally overridden by a table.\r\n    x can be absolute frequency OR offset-from-edge depending on caller.\r\n    IMPORTANT: np.interp left/right must be scalars, not arrays.\r\n    \"\"\"\r\n    limits = np.full_like(x, float(default_dbc), dtype=float)\r\n    if not table:\r\n        return limits\r\n    try:\r\n        axis = np.array([e.offset_hz for e in table], float)\r\n        vals = np.array([e.limit_dbc for e in table], float)\r\n    except Exception:\r\n        # tolerate dict-like entries\r\n        axis = np.array([e.get(\"offset_hz\") for e in table], float)\r\n        vals = np.array([e.get(\"limit_dbc\") for e in table], float)\r\n    if axis.size and vals.size:\r\n        left = float(vals[0])\r\n        right = float(vals[-1])\r\n        lim = np.interp(x, axis, vals, left=left, right=right)\r\n        return lim\r\n    return limits\r\n\r\n\r\ndef enumerate_spurs(\r\n    tile_if1: Band,\r\n    lo1_sol: LOSolution,\r\n    lo2_sol: LOSolution,\r\n    if2win: IF2Parametric,\r\n    rf_filter: RFBPF,\r\n    mix1: Mixer,\r\n    mix2: Mixer,\r\n    cfg,\r\n    inj1_sign: int,\r\n    s2_sign: int,\r\n    carriers_lo1: List[LOCarrier],\r\n    carriers_lo2: List[LOCarrier],\r\n    *,\r\n    rf_center_override_hz: Optional[float] = None,\r\n    rf_bw_override_hz: Optional[float] = None,\r\n) -> TileSummary:\r\n    \"\"\"\r\n    Main spur enumeration with band-affine widths:\r\n      - LO family carriers + order-aware family scaling (both stages)\r\n      - Stage-1 specials (LO1 feedthrough, IF1 leakage) propagated through Stage-2\r\n      - LO2 feedthroughs (fundamental + harmonics) at RF\r\n      - Skips the *desired* mechanism from being counted as a spur\r\n      - Supports flat/tabled masks\r\n      - Correct ± signs on IF terms in both stages\r\n      - Optional rf_center/bw override to assess robustness to RF-request perturbations\r\n      - OOB evaluation uses cfg RF band (S21 extrapolation allowed)\r\n      - **Band-affine ΔA**: uses worst-of-edges attenuation deltas for conservative scoring\r\n    \"\"\"\r\n    # Desired bands\r\n    if2_des, rf_des_nom = desired_paths(tile_if1, lo1_sol.f_out_hz, lo2_sol.f_out_hz, inj1_sign, s2_sign)\r\n\r\n    # Optional override for mask/inband reference (robustness sweeps)\r\n    rf_des = rf_des_nom\r\n    if rf_center_override_hz is not None:\r\n        rf_des = Band(center_hz=float(rf_center_override_hz), bw_hz=rf_bw_override_hz or rf_des_nom.bw_hz)\r\n\r\n    # RBW bin width\r\n    bin_w = rbw_width(cfg.rbw_binning, rf_des.bw_hz, rf_des.center_hz)\r\n\r\n    # Bind hot callables\r\n    rf_attn = rf_filter.attn_at\r\n    if2_attn = if2win.attn_at\r\n    rej1 = mix1.rejection_dbc\r\n    der1 = mix1.drive_derate_db\r\n    rej2 = mix2.rejection_dbc\r\n    der2 = mix2.drive_derate_db\r\n    fam1 = mix1.family_scale_db\r\n    fam2 = mix2.family_scale_db\r\n\r\n    rf_attn_des = float(rf_attn(rf_des.center_hz))\r\n    if2_attn_des = float(if2_attn(if2_des.center_hz))\r\n\r\n    # RF span guard (use config RF band; S21 extrapolates beyond file)\r\n    rf_lo = float(cfg.bands.rf_hz.min)\r\n    rf_hi = float(cfg.bands.rf_hz.max)\r\n\r\n    freq_list: list[float] = []\r\n    level_list: list[float] = []\r\n\r\n    def worst_delta(attn_func, center: float, half_width: float, des_attn: float) -> float:\r\n        \"\"\"\r\n        Conservative ΔA: worst (largest) attenuation at the two band edges minus desired attenuation.\r\n        \"\"\"\r\n        if half_width <= 0:\r\n            return float(attn_func(abs(center))) - des_attn\r\n        a_lo = float(attn_func(abs(center - half_width)))\r\n        a_hi = float(attn_func(abs(center + half_width)))\r\n        return max(a_lo, a_hi) - des_attn\r\n\r\n    # Stage-1 spur indices (exclude n1=0 per model; treat images via signs)\r\n    m1s = [m for m in range(-cfg.orders.m1n1_max_abs, cfg.orders.m1n1_max_abs + 1) if m != 0]\r\n    n1s = range(1, cfg.orders.m1n1_max_abs + 1)\r\n\r\n    for m1 in m1s:\r\n        for n1 in n1s:\r\n            base_L1 = rej1(m1, n1, lo1_sol.f_out_hz, tile_if1.center_hz) + der1(lo1_sol.delivered_dbm)\r\n            for c1 in carriers_lo1:\r\n                for sgn1 in (+1, -1):  # include ± on IF1 term\r\n                    # Stage-1 band parameters\r\n                    f_if2_c_raw = m1 * c1.freq_hz + sgn1 * n1 * tile_if1.center_hz\r\n                    f_if2_c = abs(f_if2_c_raw)\r\n                    w_if2 = abs(n1) * (tile_if1.bw_hz * 0.5)\r\n\r\n                    # ΔA at IF2: worst of the edges minus desired\r\n                    dA_if2 = float(worst_delta(if2_attn, f_if2_c_raw, w_if2, if2_attn_des))\r\n                    # Family scaling (order-aware, capped)\r\n                    L1 = base_L1 + fam1(abs(m1), c1.rel_dBc)\r\n\r\n                    for m2 in range(-cfg.orders.m2n2_max_abs, cfg.orders.m2n2_max_abs + 1):\r\n                        if m2 == 0:\r\n                            continue\r\n                        for n2 in range(1, cfg.orders.m2n2_max_abs + 1):\r\n                            if abs(m1) + abs(n1) + abs(m2) + abs(n2) > cfg.orders.cross_stage_sum_max:\r\n                                continue\r\n\r\n                            base_L2 = rej2(m2, n2, lo2_sol.f_out_hz, f_if2_c) + der2(lo2_sol.delivered_dbm)\r\n                            for c2 in carriers_lo2:\r\n                                for sgn2 in (+1, -1):  # include ± on IF2 term for stage-2\r\n                                    L2 = base_L2 + fam2(abs(m2), c2.rel_dBc)\r\n                                    # Stage-2 band parameters\r\n                                    f_rf_c_raw = m2 * c2.freq_hz + sgn2 * n2 * f_if2_c_raw\r\n                                    f_rf_c = abs(f_rf_c_raw)\r\n                                    w_rf = abs(n2) * w_if2\r\n\r\n                                    # Skip outside a padded RF span for speed\r\n                                    if (f_rf_c < rf_lo - 2 * bin_w) or (f_rf_c > rf_hi + 2 * bin_w):\r\n                                        continue\r\n\r\n                                    # *** Skip the exact desired mechanism counted as spur ***\r\n                                    if (\r\n                                        (m1 == inj1_sign)\r\n                                        and (n1 == 1)\r\n                                        and (c1.tag == \"main\")\r\n                                        and (m2 == s2_sign)\r\n                                        and (n2 == 1)\r\n                                        and (c2.tag == \"main\")\r\n                                        and (abs(f_rf_c - rf_des_nom.center_hz) <= bin_w * 0.5)\r\n                                    ):\r\n                                        continue\r\n\r\n                                    # ΔA at RF: worst-of-edges minus desired\r\n                                    dA_rf = float(worst_delta(rf_attn, f_rf_c_raw, w_rf, rf_attn_des))\r\n\r\n                                    freq_list.append(f_rf_c)\r\n                                    level_list.append(L1 + dA_if2 + L2 + dA_rf)\r\n\r\n    # Stage-1 specials at IF2 output → propagate through Stage-2\r\n    # LO1 feedthrough at IF2 out (treat as a tone; no band)\r\n    f_lo1 = lo1_sol.f_out_hz\r\n    L_lo1_if2 = mix1.mdl.isolation.lo_to_rf_db + (float(if2_attn(f_lo1)) - if2_attn_des)\r\n    for m2 in range(-cfg.orders.m2n2_max_abs, cfg.orders.m2n2_max_abs + 1):\r\n        if m2 == 0:\r\n            continue\r\n        for n2 in range(1, cfg.orders.m2n2_max_abs + 1):\r\n            if abs(m2) + n2 > cfg.orders.cross_stage_sum_max:\r\n                continue\r\n            base_L2 = rej2(m2, n2, lo2_sol.f_out_hz, f_lo1) + der2(lo2_sol.delivered_dbm)\r\n            for c2 in carriers_lo2:\r\n                for sgn2 in (+1, -1):\r\n                    L2 = base_L2 + fam2(abs(m2), c2.rel_dBc)\r\n                    f_rf = abs(m2 * c2.freq_hz + sgn2 * n2 * (+f_lo1))\r\n                    if (f_rf < rf_lo - 2 * bin_w) or (f_rf > rf_hi + 2 * bin_w):\r\n                        continue\r\n                    dA_rf = float(rf_attn(f_rf) - rf_attn_des)\r\n                    freq_list.append(f_rf)\r\n                    level_list.append(L_lo1_if2 + L2 + dA_rf)\r\n\r\n    # IF1 leakage at IF2 out (center only)\r\n    f_if1 = tile_if1.center_hz\r\n    L_if1_if2 = mix1.mdl.isolation.if_to_rf_db + (float(if2_attn(f_if1)) - if2_attn_des)\r\n    for m2 in range(-cfg.orders.m2n2_max_abs, cfg.orders.m2n2_max_abs + 1):\r\n        if m2 == 0:\r\n            continue\r\n        for n2 in range(1, cfg.orders.m2n2_max_abs + 1):\r\n            if abs(m2) + n2 > cfg.orders.cross_stage_sum_max:\r\n                continue\r\n            base_L2 = rej2(m2, n2, lo2_sol.f_out_hz, f_if1) + der2(lo2_sol.delivered_dbm)\r\n            for c2 in carriers_lo2:\r\n                for sgn2 in (+1, -1):\r\n                    L2 = base_L2 + fam2(abs(m2), c2.rel_dBc)\r\n                    f_rf = abs(m2 * c2.freq_hz + sgn2 * n2 * (+f_if1))\r\n                    if (f_rf < rf_lo - 2 * bin_w) or (f_rf > rf_hi + 2 * bin_w):\r\n                        continue\r\n                    dA_rf = float(rf_attn(f_rf) - rf_attn_des)\r\n                    freq_list.append(f_rf)\r\n                    level_list.append(L_if1_if2 + L2 + dA_rf)\r\n\r\n    # LO2 feedthroughs at RF: include main + harmonics (use isolation plus carrier rel_dBc)\r\n    for c2 in carriers_lo2:\r\n        f = c2.freq_hz\r\n        if (rf_lo - 2 * bin_w) <= f <= (rf_hi + 2 * bin_w):\r\n            L = mix2.mdl.isolation.lo_to_rf_db + c2.rel_dBc + (float(rf_attn(f)) - rf_attn_des)\r\n            freq_list.append(f)\r\n            level_list.append(L)\r\n\r\n    # Coalesce by RBW fixed bins\r\n    freqs = np.asarray(freq_list, dtype=float)\r\n    levs = np.asarray(level_list, dtype=float)\r\n    cf, cL = coalesce_bins(freqs, levs, bin_w)\r\n\r\n    # In-band classification & limits\r\n    inband_mask = np.abs(cf - rf_des.center_hz) <= (rf_des.bw_hz / 2.0 + bin_w / 2.0)\r\n\r\n    # Edge-relative offsets (>=0 inside band is 0); outside is distance to nearest edge\r\n    edge = rf_des.bw_hz / 2.0\r\n    dist_from_edge = np.clip(np.abs(cf - rf_des.center_hz) - edge, 0.0, None)\r\n\r\n    # In-band limits (flat or table vs offset-from-edge = 0 inside)\r\n    lim_in = _interp_mask_flat_or_table(\r\n        cfg.masks.inband.default_dbc, cfg.masks.inband.table, dist_from_edge\r\n    )\r\n\r\n    # Out-of-band limits: absolute or edge_relative, per config\r\n    if (getattr(cfg.masks.outofband, \"mode\", \"absolute\") == \"edge_relative\"):\r\n        oob_arg = dist_from_edge  # distance from band edge\r\n    else:\r\n        oob_arg = cf  # absolute frequency\r\n    lim_oob = _interp_mask_flat_or_table(\r\n        cfg.masks.outofband.default_dbc, cfg.masks.outofband.table, oob_arg\r\n    )\r\n\r\n    limits = np.where(inband_mask, lim_in, lim_oob).astype(float)\r\n    margins = limits - cL - cfg.constraints.guard_margin_db\r\n    worst = float(np.min(margins)) if margins.size else -999.0\r\n\r\n    final_bins: list[BinEntry] = [\r\n        BinEntry(float(f), float(L), bool(inb), {\"limit_dbc\": float(lim), \"margin_db\": float(mar)})\r\n        for f, L, inb, lim, mar in zip(cf, cL, inband_mask, limits, margins)\r\n    ]\r\n\r\n    return TileSummary(worst_margin_db=worst, bins=final_bins, desired_rf_band=rf_des)\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "synth.py",
              "path": "src\\bucso\\synth.py",
              "size": 11727,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import List, Dict, Iterable, Tuple, Optional\r\nfrom functools import lru_cache\r\nimport numpy as np\r\nfrom .models import LOMdl, Mode, PfdComponent\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass LOCarrier:\r\n    freq_hz: float\r\n    rel_dBc: float  # relative to main tone at mixer input\r\n    tag: str        # \"main\", \"harm2\", \"pfd_k1\", ...\r\n\r\n\r\n@dataclass\r\nclass LOSolution:\r\n    name: str\r\n    mode: str\r\n    f_out_hz: float\r\n    divider: str\r\n    delivered_dbm: float\r\n    lock_time_ms: float\r\n    pad_db: float  # which pad choice produced delivered_dbm (for legality)\r\n    # PFD info (P2): derived from ref and pfd_divider legality\r\n    pfd_hz: float\r\n    pfd_divider: int\r\n\r\n\r\nclass Synth:\r\n    def __init__(self, mdl: LOMdl):\r\n        self.mdl = mdl\r\n\r\n    def output_power_dbm(self, f_out_hz: float, divider: str) -> float:\r\n        t = self.mdl.output_power_model.table\r\n        fv = np.array(t[\"freq_hz\"], float)\r\n        pv = np.array(t[\"p_out_dbm\"], float)\r\n        p = float(np.interp(f_out_hz, fv, pv))\r\n        p += self.mdl.output_power_model.divider_adjust_db.get(divider, 0.0)\r\n        return p\r\n\r\n    def delivered_drive_dbm(self, f_out_hz: float, divider: str, path: str, pad_db: float) -> float:\r\n        p = self.output_power_dbm(f_out_hz, divider)\r\n        loss = self.mdl.distribution.path_losses_db.get(path, 0.0)\r\n        return p - loss - pad_db\r\n\r\n    @staticmethod\r\n    def _apply_pfd_rolloff(comp: PfdComponent, k: int, f_pfd: float) -> float:\r\n        \"\"\"\r\n        Roll-off model for PFD families:\r\n          rel_dBc = base_rel_dBc - rolloff_dB_per_dec * log10(max((k*f_pfd)/corner_hz, 1))\r\n        If corner_hz is not provided, roll off vs k: log10(max(k,1)).\r\n        \"\"\"\r\n        if comp.rolloff_dB_per_dec is None or comp.rolloff_dB_per_dec <= 0:\r\n            return float(comp.base_rel_dBc)\r\n        if comp.corner_hz and comp.corner_hz > 0:\r\n            ratio = max((k * f_pfd) / float(comp.corner_hz), 1.0)\r\n        else:\r\n            ratio = max(float(k), 1.0)\r\n        return float(comp.base_rel_dBc) - float(comp.rolloff_dB_per_dec) * np.log10(ratio)\r\n\r\n    # --------- cached carrier builder ---------\r\n\r\n    def _equivalent_carriers_no_cache(\r\n        self,\r\n        f_out_hz: float,\r\n        mode: Mode,\r\n        divider: str,\r\n        pfd_hz: float | None = None,\r\n    ) -> List[LOCarrier]:\r\n        carriers: List[LOCarrier] = [LOCarrier(f_out_hz, 0.0, \"main\")]\r\n\r\n        harm_delta = self.mdl.divider_spectrum.get(divider, None)\r\n        harm_boost = 0.0 if harm_delta is None else float(harm_delta.harm_delta_dBc)\r\n\r\n        # Harmonics at output (datasheet gives relative at output already).\r\n        for h in (mode.harmonics_at_output or []):\r\n            # Apply divider-spectrum delta to reflect folding behavior\r\n            rel = float(h.rel_dBc) + harm_boost\r\n            carriers.append(LOCarrier(h.k * f_out_hz, rel, f\"harm{h.k}\"))\r\n\r\n        # Basic PFD families, if present (with roll-off).\r\n        fams = None\r\n        if isinstance(mode.pfd_spurs_at_output, dict):\r\n            fams = mode.pfd_spurs_at_output.get(\"families\", [])\r\n        if fams and pfd_hz and pfd_hz > 0:\r\n            for fam in fams:\r\n                for comp in fam.components:\r\n                    k = int(comp.k)\r\n                    # Compute level with roll-off; place ±k*fPFD\r\n                    rel_k = self._apply_pfd_rolloff(comp, k, float(pfd_hz))\r\n                    for sgn in (+1, -1):\r\n                        f = f_out_hz + sgn * k * float(pfd_hz)\r\n                        carriers.append(LOCarrier(f, float(rel_k), f\"pfd{k}\"))\r\n\r\n        # Optional fractional-N boundary spur envelope (simple envelope)\r\n        env = getattr(mode, \"frac_boundary_spurs\", None)\r\n        if isinstance(env, dict) and env.get(\"enabled\", False) and pfd_hz and pfd_hz > 0:\r\n            amp = float(env.get(\"amplitude_at_eps0p5_rel_dBc\", -58))\r\n            slope = float(env.get(\"rolloff_slope_db_per_dec\", 0.0))\r\n            # Always place ±0.5*fPFD\r\n            for sgn in (+1, -1):\r\n                carriers.append(LOCarrier(f_out_hz + sgn * 0.5 * float(pfd_hz), amp, \"frac_boundary\"))\r\n            # Add a weaker inner pair at ±0.25*fPFD if slope provided, as a crude envelope fall-off\r\n            if slope > 0:\r\n                amp_025 = amp - slope * np.log10(2.0)  # one half-decade from 0.5 to 0.25\r\n                for sgn in (+1, -1):\r\n                    carriers.append(LOCarrier(f_out_hz + sgn * 0.25 * float(pfd_hz), float(amp_025), \"frac_env\"))\r\n\r\n        return carriers\r\n\r\n    @lru_cache(maxsize=16384)\r\n    def _equiv_carriers_cached(self, f_out_hz_q: float, mode_name: str, divider: str, pfd_hz_q: float) -> tuple[LOCarrier, ...]:\r\n        mode = next(m for m in self.mdl.modes if m.name == mode_name)\r\n        lst = self._equivalent_carriers_no_cache(f_out_hz_q, mode, divider, None if pfd_hz_q <= 0 else pfd_hz_q)\r\n        return tuple(lst)\r\n\r\n    def equivalent_carriers(\r\n        self,\r\n        f_out_hz: float,\r\n        mode: Mode,\r\n        divider: str,\r\n        pfd_hz: float | None = None,\r\n    ) -> List[LOCarrier]:\r\n        \"\"\"\r\n        Build equivalent LO carriers at the *output* (post-divider) with relative levels.\r\n        This variant uses an internal LRU cache keyed on (rounded f_out, mode, divider, rounded pfd_hz).\r\n        \"\"\"\r\n        q = 1e3  # 1 kHz quantization is plenty\r\n        f_q = round(float(f_out_hz) / q) * q\r\n        pfd_q = 0.0 if (pfd_hz is None or pfd_hz <= 0) else (round(float(pfd_hz) / q) * q)\r\n        return list(self._equiv_carriers_cached(f_q, mode.name, divider, pfd_q))\r\n\r\n    def _best_pad_within_drive(\r\n        self,\r\n        f_out_hz: float,\r\n        divider: str,\r\n        path: str,\r\n        min_dbm: float,\r\n        max_dbm: float,\r\n    ) -> Optional[Tuple[float, float]]:\r\n        \"\"\"\r\n        Return (pad_db, delivered_dbm) choosing a pad that keeps delivered drive within [min,max].\r\n        If not possible, return None.\r\n        \"\"\"\r\n        best: Optional[Tuple[float, float]] = None\r\n        for pad in self.mdl.distribution.pad_options_db:\r\n            delivered = self.delivered_drive_dbm(f_out_hz, divider, path, pad)\r\n            if (delivered >= min_dbm) and (delivered <= max_dbm):\r\n                # Choose the *largest* pad that still meets min (to keep headroom)\r\n                if (best is None) or (pad > best[0]):\r\n                    best = (float(pad), float(delivered))\r\n        return best\r\n\r\n    def _choose_pfd(self, mode: Mode) -> tuple[float, int] | None:\r\n        \"\"\"Pick a legal PFD given ref constraints and mode pfd_dividers and range (choose largest PFD within range).\"\"\"\r\n        refs = list(self.mdl.ref_constraints.get(\"allowed_refs_hz\", []) or [])\r\n        if not refs:\r\n            return None\r\n        # Highest PFD within range is often better (fewer frac spurs)\r\n        best: tuple[float, int] | None = None\r\n        for ref in refs:\r\n            for div in (mode.pfd_dividers or []):\r\n                f_pfd = float(ref) / float(div)\r\n                lo, hi = float(mode.pfd_hz_range[0]), float(mode.pfd_hz_range[1])\r\n                if lo <= f_pfd <= hi:\r\n                    if (best is None) or (f_pfd > best[0]):\r\n                        best = (f_pfd, int(div))\r\n        return best\r\n\r\n    def legal_settings(\r\n        self, *, name_filter: Iterable[str] | None, f_min: float, f_max: float, path: str,\r\n        drive_min_dbm: float | None = None, drive_max_dbm: float | None = None\r\n    ) -> List[LOSolution]:\r\n        \"\"\"Enumerate legal LO grid points (post-divider) with available VCO dividers from mode.vco_dividers.\r\n        Enforce PFD legality vs allowed refs and mode pfd_hz_range.\r\n        \"\"\"\r\n        out: List[LOSolution] = []\r\n        step = float(self.mdl.step_hz)\r\n        f0 = max(self.mdl.freq_range_hz[0], f_min)\r\n        f1 = min(self.mdl.freq_range_hz[1], f_max)\r\n        if f0 > f1:\r\n            return out\r\n\r\n        for mode in self.mdl.modes:\r\n            if not mode.enabled:\r\n                continue\r\n\r\n            pfd_sel = self._choose_pfd(mode)\r\n            if pfd_sel is None:\r\n                continue\r\n            f_pfd, pfd_divider = pfd_sel\r\n\r\n            vco_divs = mode.vco_dividers or [1]\r\n            for vdiv in vco_divs:\r\n                divider = f\"/{int(vdiv)}\"\r\n                f = float(np.ceil(f0 / step) * step)\r\n                while f <= f1 + 1e-9:\r\n                    if (drive_min_dbm is not None) and (drive_max_dbm is not None):\r\n                        pad_sel = self._best_pad_within_drive(f, divider, path, drive_min_dbm, drive_max_dbm)\r\n                        if pad_sel is None:\r\n                            f += step\r\n                            continue\r\n                        pad_db, delivered = pad_sel\r\n                    else:\r\n                        # fall back: pick pad giving maximum delivered\r\n                        pad_db = max(self.mdl.distribution.pad_options_db or [0.0])\r\n                        delivered = self.delivered_drive_dbm(f, divider, path, pad_db)\r\n                    out.append(LOSolution(\r\n                        name=self.mdl.name, mode=mode.name, f_out_hz=f,\r\n                        divider=divider, delivered_dbm=float(delivered),\r\n                        lock_time_ms=float(mode.lock_time_model.base_ms),\r\n                        pad_db=float(pad_db),\r\n                        pfd_hz=float(f_pfd), pfd_divider=int(pfd_divider)\r\n                    ))\r\n                    f += step\r\n        return out\r\n\r\n    def snap_to_legal(\r\n        self, f_target: float, path: str, window_steps: int = 2,\r\n        drive_min_dbm: float | None = None, drive_max_dbm: float | None = None\r\n    ) -> LOSolution | None:\r\n        \"\"\"Snap a target to nearest legal grid ±window_steps over all modes/dividers, enforcing PFD legality.\"\"\"\r\n        step = float(self.mdl.step_hz)\r\n        if step <= 0:\r\n            return None\r\n        grid = [round(f_target / step) * step + k * step for k in range(-window_steps, window_steps + 1)]\r\n\r\n        best: Optional[LOSolution] = None\r\n        best_del = -1e9\r\n\r\n        for mode in self.mdl.modes:\r\n            if not mode.enabled:\r\n                continue\r\n            pfd_sel = self._choose_pfd(mode)\r\n            if pfd_sel is None:\r\n                continue\r\n            f_pfd, pfd_divider = pfd_sel\r\n\r\n            vco_divs = mode.vco_dividers or [1]\r\n            for vdiv in vco_divs:\r\n                divider = f\"/{int(vdiv)}\"\r\n                for f in grid:\r\n                    if not (self.mdl.freq_range_hz[0] <= f <= self.mdl.freq_range_hz[1]):\r\n                        continue\r\n                    if (drive_min_dbm is not None) and (drive_max_dbm is not None):\r\n                        pad_sel = self._best_pad_within_drive(f, divider, path, drive_min_dbm, drive_max_dbm)\r\n                        if pad_sel is None:\r\n                            continue\r\n                        pad_db, delivered = pad_sel\r\n                    else:\r\n                        pad_db = max(self.mdl.distribution.pad_options_db or [0.0])\r\n                        delivered = self.delivered_drive_dbm(f, divider, path, pad_db)\r\n\r\n                    if delivered > best_del:\r\n                        best_del = delivered\r\n                        best = LOSolution(\r\n                            name=self.mdl.name, mode=mode.name, f_out_hz=float(f),\r\n                            divider=divider, delivered_dbm=float(delivered),\r\n                            lock_time_ms=float(mode.lock_time_model.base_ms),\r\n                            pad_db=float(pad_db),\r\n                            pfd_hz=float(f_pfd), pfd_divider=int(pfd_divider)\r\n                        )\r\n        return best\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "tiling.py",
              "path": "src\\bucso\\tiling.py",
              "size": 884,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import Iterable, List\r\nimport numpy as np\r\nfrom .utils import Band\r\n\r\n@dataclass(frozen=True)\r\nclass Tile:\r\n    id: int\r\n    if1_center_hz: float\r\n    bw_hz: float\r\n    rf_center_hz: float\r\n\r\ndef make_tiles(if1_min, if1_max, rf_min, rf_max, bw_list, if1_step, rf_step) -> List[Tile]:\r\n    tiles: List[Tile] = []\r\n    tid = 0\r\n    for bw in bw_list:\r\n        cmin = if1_min + bw/2\r\n        cmax = if1_max - bw/2\r\n        if cmin > cmax:\r\n            continue\r\n        if1_cs = np.arange(cmin, cmax + 0.5*if1_step, if1_step)\r\n        rf_cs = np.arange(rf_min, rf_max + 0.5*rf_step, rf_step)\r\n        for ic in if1_cs:\r\n            for rc in rf_cs:\r\n                tiles.append(Tile(id=tid, if1_center_hz=float(ic), bw_hz=float(bw), rf_center_hz=float(rc)))\r\n                tid += 1\r\n    return tiles\r\n",
              "encoding": "utf-8",
              "encoding_error": false
            },
            {
              "type": "file",
              "name": "utils.py",
              "path": "src\\bucso\\utils.py",
              "size": 2084,
              "content_truncated": false,
              "contents": "from __future__ import annotations\r\nfrom dataclasses import dataclass\r\nfrom typing import Iterable, Tuple\r\nimport numpy as np\r\n\r\n\r\ndef db_to_lin(db: float) -> float:\r\n    return 10 ** (db / 10.0)\r\n\r\n\r\ndef lin_to_db(lin: float) -> float:\r\n    if lin <= 0:\r\n        return -300.0\r\n    return 10.0 * np.log10(lin)\r\n\r\n\r\ndef clamp(x: float, lo: float, hi: float) -> float:\r\n    return max(lo, min(hi, x))\r\n\r\n\r\ndef power_sum_db(levels_db: Iterable[float]) -> float:\r\n    return lin_to_db(sum(db_to_lin(v) for v in levels_db if v is not None))\r\n\r\n\r\n@dataclass(frozen=True)\r\nclass Band:\r\n    center_hz: float\r\n    bw_hz: float\r\n\r\n    @property\r\n    def f_lo(self) -> float:\r\n        return self.center_hz - self.bw_hz / 2\r\n\r\n    @property\r\n    def f_hi(self) -> float:\r\n        return self.center_hz + self.bw_hz / 2\r\n\r\n    def contains(self, f: float) -> bool:\r\n        return self.f_lo <= f <= self.f_hi\r\n\r\n\r\ndef coalesce_bins(freqs: np.ndarray, levels_db: np.ndarray, bin_width_hz: float):\r\n    \"\"\"\r\n    Vectorized fixed-bin coalescing to avoid order-dependent clustering.\r\n    Each frequency is assigned to bin index = floor(f / bin_width_hz).\r\n    Returns (bin_representative_freqs, summed_levels_db).\r\n    Deterministic & stable (mergesort on bin ids).\r\n    \"\"\"\r\n    if freqs is None or levels_db is None:\r\n        return np.array([]), np.array([])\r\n    if len(freqs) == 0:\r\n        return np.array([]), np.array([])\r\n\r\n    freqs = np.asarray(freqs, float)\r\n    levels_db = np.asarray(levels_db, float)\r\n\r\n    bins = np.floor(freqs / bin_width_hz).astype(np.int64)\r\n    order = np.argsort(bins, kind=\"mergesort\")\r\n\r\n    bins_s = bins[order]\r\n    f_s = freqs[order]\r\n    Llin_s = 10.0 ** (levels_db[order] / 10.0)\r\n\r\n    # indices where a new bin starts\r\n    start = np.empty_like(bins_s, dtype=bool)\r\n    start[0] = True\r\n    start[1:] = bins_s[1:] != bins_s[:-1]\r\n    idx = np.flatnonzero(start)\r\n\r\n    sums = np.add.reduceat(Llin_s, idx)\r\n    # representative frequency per bin: lowest frequency within the bin (stable)\r\n    f_rep = f_s[idx]\r\n\r\n    return f_rep, 10.0 * np.log10(sums)",
              "encoding": "utf-8",
              "encoding_error": false
            }
          ]
        }
      ]
    },
    {
      "type": "directory",
      "name": "tests",
      "path": "tests",
      "children": [
        {
          "type": "file",
          "name": "conftest.py",
          "path": "tests\\conftest.py",
          "size": 7292,
          "content_truncated": false,
          "contents": "import math\r\nimport numpy as np\r\nimport pytest\r\n\r\nfrom bucso.models import (\r\n    Project, Bands, BandLimits, Grids, Masks, MaskSpec, RBWBinning,\r\n    Orders, Constraints, EarlyReject, RuntimePolicy, Targets,\r\n    Config, MixerModel, MixerIsolation, MixerDriveDerate, LOMdl,\r\n    Mode, LockTimeModel, OutputPowerTable, Distribution, DividerSpectrum,\r\n    Search,  # <-- added\r\n)\r\nfrom bucso.filters import RFBPF, IF2Parametric\r\nfrom bucso.mixer import Mixer\r\nfrom bucso.synth import Synth\r\nfrom bucso.utils import Band\r\n\r\n\r\n# ---------- generic small helpers ----------\r\n\r\n@pytest.fixture\r\ndef rf_filter_flat_pass():\r\n    # Very simple RF BPF: deep stop, flat-ish pass around 29–30 GHz\r\n    f = np.array([26.0e9, 27.5e9, 28.0e9, 29.0e9, 30.0e9, 31.0e9, 32.0e9])\r\n    s = np.array([-40, -15, -5, -1, -1, -5, -15], dtype=float)\r\n    return RFBPF._from_arrays(f, s, ident=\"TEST_RF\")\r\n\r\n\r\n@pytest.fixture\r\ndef if2_window():\r\n    # ~500 MHz window around 4.5 GHz, 1 dB IL, 40 dB/dec, -80 dB floor\r\n    return IF2Parametric(\r\n        center_hz=4.5e9, bw_hz=0.5e9,\r\n        passband_il_db=1.0, stop_floor_db=-80.0, rolloff_db_per_dec=40.0\r\n    )\r\n\r\n\r\n@pytest.fixture\r\ndef mixer1_model():\r\n    # Spur table with a few entries + legacy grid for (1,1)\r\n    return Mixer(MixerModel(\r\n        name=\"MX1\",\r\n        type=\"double-balanced\",\r\n        if_range_hz=(50e6, 8e9),\r\n        lo_range_hz=(100e6, 12e9),\r\n        rf_range_hz=(50e6, 12e9),\r\n        required_lo_drive_dbm={\"min\": 11.0, \"max\": 17.0},\r\n        drive_derate=MixerDriveDerate(nominal_dbm=13.0, slope_db_per_db=1.0, max_derate_db=6.0),\r\n        spur_table={\r\n            \"entries\": [\r\n                {\"m\": 1, \"n\": 1, \"rej_dbc\": -35},\r\n                {\"m\": 1, \"n\": 2, \"rej_dbc\": -45},\r\n                {\"m\": 2, \"n\": 1, \"rej_dbc\": -38},\r\n            ],\r\n            \"grids\": {\r\n                \"lo_hz\": [0.5e9, 2e9, 6e9],\r\n                \"if_hz\": [0.1e9, 0.5e9, 1.0e9],\r\n                \"rej_dbc\": [\r\n                    [-32, -34, -36],\r\n                    [-33, -35, -37],\r\n                    [-34, -36, -38],\r\n                ],\r\n            },\r\n        },\r\n        isolation=MixerIsolation(lo_to_rf_db=-40, if_to_rf_db=-60),\r\n        lo_family_scaling={\"default_slope_db_per_db\": 1.0, \"cap_db\": 12.0},\r\n        fallback_rej_dbc=-20.0,\r\n    ))\r\n\r\n\r\n@pytest.fixture\r\ndef mixer2_model():\r\n    return Mixer(MixerModel(\r\n        name=\"MX2\",\r\n        type=\"double-balanced\",\r\n        if_range_hz=(50e6, 12e9),\r\n        lo_range_hz=(100e6, 26e9),\r\n        rf_range_hz=(50e6, 32e9),\r\n        required_lo_drive_dbm={\"min\": 11.0, \"max\": 17.0},\r\n        drive_derate=MixerDriveDerate(nominal_dbm=13.0, slope_db_per_db=1.0, max_derate_db=6.0),\r\n        spur_table={\r\n            \"entries\": [\r\n                {\"m\": 1, \"n\": 1, \"rej_dbc\": -30},\r\n                {\"m\": 1, \"n\": 2, \"rej_dbc\": -38},\r\n                {\"m\": 2, \"n\": 1, \"rej_dbc\": -36},\r\n            ],\r\n        },\r\n        isolation=MixerIsolation(lo_to_rf_db=-38, if_to_rf_db=-55),\r\n        lo_family_scaling={\"default_slope_db_per_db\": 1.0, \"cap_db\": 12.0},\r\n        fallback_rej_dbc=-20.0,\r\n    ))\r\n\r\n\r\n@pytest.fixture\r\ndef lo1_synth():\r\n    # Simple LO with harmonics, divider spectrum, single mode\r\n    return Synth(LOMdl(\r\n        name=\"LO1\",\r\n        ref_constraints={\"allowed_refs_hz\": [10e6]},\r\n        freq_range_hz=(10e6, 20e9),\r\n        step_hz=1e6,\r\n        output_power_model=OutputPowerTable(\r\n            table={\"freq_hz\": [5e9, 10e9, 15e9, 20e9], \"p_out_dbm\": [18, 18, 18, 18]},\r\n            divider_adjust_db={\"/1\": 0, \"/2\": -1, \"/4\": -2},\r\n        ),\r\n        distribution=Distribution(path_losses_db={\"lo1\": 3.0}, pad_options_db=[0.0, 3.0, 6.0]),\r\n        modes=[\r\n            Mode(\r\n                name=\"fracN\", enabled=True,\r\n                pfd_hz_range=(10e6, 200e6),\r\n                pfd_dividers=[1, 2, 4, 8],\r\n                vco_dividers=[1, 2, 4],\r\n                lock_time_model=LockTimeModel(base_ms=0.4, per_mhz_ms=0.002, mode_penalties_ms={}),\r\n                harmonics_at_output=[{\"k\": 2, \"rel_dBc\": -25}, {\"k\": 3, \"rel_dBc\": -35}],\r\n                pfd_spurs_at_output={\"families\": []},\r\n                frac_boundary_spurs={\"enabled\": True, \"amplitude_at_eps0p5_rel_dBc\": -58, \"rolloff_slope_db_per_dec\": 10},\r\n            )\r\n        ],\r\n        divider_spectrum={\"/1\": DividerSpectrum(harm_delta_dBc=0), \"/4\": DividerSpectrum(harm_delta_dBc=12)},\r\n    ))\r\n\r\n\r\n@pytest.fixture\r\ndef lo2_synth():\r\n    return Synth(LOMdl(\r\n        name=\"LO2\",\r\n        ref_constraints={\"allowed_refs_hz\": [10e6]},\r\n        freq_range_hz=(10e6, 26e9),\r\n        step_hz=1e6,\r\n        output_power_model=OutputPowerTable(\r\n            table={\"freq_hz\": [5e9, 15e9, 26e9], \"p_out_dbm\": [15, 15, 15]},\r\n            divider_adjust_db={\"/1\": 0},\r\n        ),\r\n        distribution=Distribution(path_losses_db={\"lo2\": 4.0}, pad_options_db=[0.0, 3.0, 6.0]),\r\n        modes=[\r\n            Mode(\r\n                name=\"fracN\", enabled=True,\r\n                pfd_hz_range=(10e6, 200e6),\r\n                pfd_dividers=[1, 2, 4, 8],\r\n                vco_dividers=[1],\r\n                lock_time_model=LockTimeModel(base_ms=0.5, per_mhz_ms=0.002, mode_penalties_ms={}),\r\n                harmonics_at_output=[{\"k\": 2, \"rel_dBc\": -25}],\r\n                pfd_spurs_at_output={\"families\": []},\r\n            )\r\n        ],\r\n        divider_spectrum={\"/1\": DividerSpectrum(harm_delta_dBc=0)},\r\n    ))\r\n\r\n\r\n@pytest.fixture\r\ndef tiny_config():\r\n    # Provide a minimal but valid Search object (Config.search can't be None)\r\n    search = Search(\r\n        lo1_candidates=[],\r\n        lo2_candidates=[],\r\n        mixer1_candidates=[],\r\n        mixer2_candidates=[],\r\n        rf_bpf_choices=[],\r\n        if2_filter_model=\"\",\r\n    )\r\n\r\n    return Config(\r\n        project=Project(name=\"TestProj\", seed=123, reference_10mhz_hz=10_000_000.0),\r\n        bands=Bands(\r\n            if1_hz=BandLimits(min=950e6, max=2150e6),\r\n            rf_hz=BandLimits(min=27.5e9, max=31.0e9),\r\n            required_bandwidths_hz=[400e6],\r\n        ),\r\n        grids=Grids(\r\n            if1_center_step_hz=100e6,\r\n            rf_center_step_hz=250e6,\r\n            bw_grid_hz=[400e6],\r\n            snap_if1_rf_to_grid=True,\r\n        ),\r\n        masks=Masks(\r\n            inband=MaskSpec(default_dbc=-60.0, table=[]),\r\n            outofband=MaskSpec(default_dbc=-60.0, table=[], mode=\"absolute\"),\r\n        ),\r\n        rbw_binning=RBWBinning(rbw_hz=10e3, rbw_frac_of_bw=0.0025, rbw_ppm_of_freq=0.0),\r\n        search=search,  # <-- fixed (was None)\r\n        orders=Orders(m1n1_max_abs=3, m2n2_max_abs=3, cross_stage_sum_max=8),\r\n        constraints=Constraints(enforce_desired_mn11_only=True, guard_margin_db=2.0, desired_stage1_sign=+1, desired_stage2_sign=+1),\r\n        early_reject=EarlyReject(image_in_if2_passband=True, loft_in_if2_or_rf_passbands=True,\r\n                                 rf_first_order_image_in_passband=True),\r\n        runtime_policy=RuntimePolicy(hysteresis_hz=10e6, prefer_fewer_retunes=True,\r\n                                     lock_time_penalty_weight=1.0, markov_transition_matrix_csv=None),\r\n        targets=Targets(min_margin_db=0.0, alt_within_db=3.0),\r\n    )\r\n\r\n\r\n@pytest.fixture\r\ndef simple_tile_if1():\r\n    # IF1: 1.55 GHz, BW 400 MHz\r\n    return Band(center_hz=1.55e9, bw_hz=400e6)\r\n",
          "encoding": "utf-8",
          "encoding_error": false
        },
        {
          "type": "file",
          "name": "test_spur_enumeration.py",
          "path": "tests\\test_spur_enumeration.py",
          "size": 11655,
          "content_truncated": false,
          "contents": "# tests/test_spur_enumeration.py\r\nfrom __future__ import annotations\r\nimport math\r\nimport numpy as np\r\nimport pytest\r\n\r\nfrom bucso.spur import enumerate_spurs, rbw_width, desired_paths\r\nfrom bucso.utils import Band, coalesce_bins\r\nfrom bucso.filters import IF2Parametric\r\n\r\n\r\n# --------------------------\r\n# Helpers\r\n# --------------------------\r\n\r\ndef _pick_snap(synth, f_target, path, mxd_min=11.0, mxd_max=17.0):\r\n    \"\"\"Snap a synthesizer to a legal grid point near f_target.\"\"\"\r\n    sol = synth.snap_to_legal(\r\n        f_target=float(f_target),\r\n        path=path,\r\n        window_steps=2,\r\n        drive_min_dbm=mxd_min,\r\n        drive_max_dbm=mxd_max,\r\n    )\r\n    assert sol is not None, \"Failed to snap LO to legal grid near target\"\r\n    return sol\r\n\r\n\r\ndef _nearest_bin(bins, f0):\r\n    \"\"\"Return the bin from TileSummary.bins whose center is nearest f0.\"\"\"\r\n    return min(bins, key=lambda b: abs(b.f_rf_hz - float(f0)))\r\n\r\n\r\n# --------------------------\r\n# Core spur-enumeration tests\r\n# --------------------------\r\n\r\ndef test_desired_path_is_excluded_from_spur_bins(\r\n    tiny_config, simple_tile_if1, rf_filter_flat_pass, if2_window, mixer1_model, mixer2_model,\r\n    lo1_synth, lo2_synth\r\n):\r\n    \"\"\"\r\n    The desired mechanism must not be counted as a spur bin.\r\n    We verify no returned bin sits within 0.5*RBW of the desired RF center.\r\n    \"\"\"\r\n    inj1 = +1   # high-side IF2 = | +LO1 - IF1 |\r\n    s2   = +1   # stage-2 sum: RF = | +LO2 + IF2 |\r\n\r\n    # Choose an illustrative plan close to the design doc example\r\n    # IF1c=1.55 GHz, IF2c≈4.65 GHz -> LO1≈6.20 GHz; RFc=29.25 GHz -> LO2≈24.60 GHz\r\n    if1 = simple_tile_if1\r\n    if2 = if2_window\r\n    lo1 = _pick_snap(lo1_synth, f_target=6.20e9, path=\"lo1\",\r\n                     mxd_min=mixer1_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mxd_max=mixer1_model.mdl.required_lo_drive_dbm[\"max\"])\r\n    lo2 = _pick_snap(lo2_synth, f_target=24.60e9, path=\"lo2\",\r\n                     mxd_min=mixer2_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mxd_max=mixer2_model.mdl.required_lo_drive_dbm[\"max\"])\r\n\r\n    # Equivalent carriers (include harmonics but desired path uses \"main\")\r\n    mode1 = next(m for m in lo1_synth.mdl.modes if m.name == lo1.mode)\r\n    mode2 = next(m for m in lo2_synth.mdl.modes if m.name == lo2.mode)\r\n    C1 = lo1_synth.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n    C2 = lo2_synth.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n\r\n    # Run enumeration\r\n    summ = enumerate_spurs(\r\n        tile_if1=if1,\r\n        lo1_sol=lo1,\r\n        lo2_sol=lo2,\r\n        if2win=if2,\r\n        rf_filter=rf_filter_flat_pass,\r\n        mix1=mixer1_model,\r\n        mix2=mixer2_model,\r\n        cfg=tiny_config,\r\n        inj1_sign=inj1,\r\n        s2_sign=s2,\r\n        carriers_lo1=C1,\r\n        carriers_lo2=C2,\r\n    )\r\n\r\n    # Desired RF band (used for mask/in-band classification)\r\n    _, rf_des = desired_paths(if1, lo1.f_out_hz, lo2.f_out_hz, inj1, s2)\r\n    bin_w = rbw_width(tiny_config.rbw_binning, rf_des.bw_hz, rf_des.center_hz)\r\n\r\n    # Assert no spur bin falls within the RBW window around the desired center\r\n    assert all(abs(b.f_rf_hz - rf_des.center_hz) > 0.5 * bin_w for b in summ.bins), \\\r\n        \"Desired mechanism leaked into spur bin list\"\r\n\r\n\r\ndef test_lo2_feedthrough_is_present_and_level_matches_isolation_delta(\r\n    tiny_config, simple_tile_if1, rf_filter_flat_pass, if2_window, mixer1_model, mixer2_model,\r\n    lo1_synth, lo2_synth\r\n):\r\n    \"\"\"\r\n    LO2 feedthrough (fundamental and possibly harmonics) at RF should appear as spur bins.\r\n    For the fundamental, its level should be approx:\r\n        mix2.isolation.lo_to_rf_db + (A_RF(f_LO2) - A_RF(desired_RF_center))\r\n    ignoring small differences from bin coalescing.\r\n    \"\"\"\r\n    inj1, s2 = +1, +1\r\n    if1 = simple_tile_if1\r\n    if2 = if2_window\r\n\r\n    lo1 = _pick_snap(lo1_synth, 6.20e9, \"lo1\",\r\n                     mixer1_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mixer1_model.mdl.required_lo_drive_dbm[\"max\"])\r\n    lo2 = _pick_snap(lo2_synth, 24.60e9, \"lo2\",\r\n                     mixer2_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mixer2_model.mdl.required_lo_drive_dbm[\"max\"])\r\n\r\n    mode1 = next(m for m in lo1_synth.mdl.modes if m.name == lo1.mode)\r\n    mode2 = next(m for m in lo2_synth.mdl.modes if m.name == lo2.mode)\r\n    C1 = lo1_synth.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n    C2 = lo2_synth.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n\r\n    summ = enumerate_spurs(\r\n        if1, lo1, lo2, if2, rf_filter_flat_pass, mixer1_model, mixer2_model, tiny_config,\r\n        inj1_sign=inj1, s2_sign=s2, carriers_lo1=C1, carriers_lo2=C2\r\n    )\r\n\r\n    # Expected LO2 feedthrough level (relative to desired) at f = LO2\r\n    _, rf_des = desired_paths(if1, lo1.f_out_hz, lo2.f_out_hz, inj1, s2)\r\n    a_des = float(rf_filter_flat_pass.attn_at(rf_des.center_hz))\r\n    a_at_lo2 = float(rf_filter_flat_pass.attn_at(lo2.f_out_hz))\r\n    expected = mixer2_model.mdl.isolation.lo_to_rf_db + (a_at_lo2 - a_des)\r\n\r\n    # Find the nearest bin to LO2 frequency\r\n    b = _nearest_bin(summ.bins, lo2.f_out_hz)\r\n\r\n    # Within a couple dB tolerance to allow binning/summing with any neighbors\r\n    assert abs(b.f_rf_hz - lo2.f_out_hz) <= rbw_width(tiny_config.rbw_binning, rf_des.bw_hz, b.f_rf_hz)\r\n    assert pytest.approx(b.level_dbc, abs=2.0) == expected\r\n\r\n\r\ndef test_if2_window_tightening_improves_margin(\r\n    tiny_config, simple_tile_if1, rf_filter_flat_pass, mixer1_model, mixer2_model, lo1_synth, lo2_synth\r\n):\r\n    \"\"\"\r\n    If we make the IF2 window tighter (same center), spurs outside IF2 should see larger ΔA_IF2,\r\n    leading to *better* worst-case spur margin (or at least not worse).\r\n    \"\"\"\r\n    inj1, s2 = +1, +1\r\n    if1 = simple_tile_if1\r\n\r\n    # Choose a stable LO pair near the illustrative example\r\n    lo1 = _pick_snap(lo1_synth, 6.20e9, \"lo1\",\r\n                     mixer1_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mixer1_model.mdl.required_lo_drive_dbm[\"max\"])\r\n    lo2 = _pick_snap(lo2_synth, 24.60e9, \"lo2\",\r\n                     mixer2_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mixer2_model.mdl.required_lo_drive_dbm[\"max\"])\r\n\r\n    mode1 = next(m for m in lo1_synth.mdl.modes if m.name == lo1.mode)\r\n    mode2 = next(m for m in lo2_synth.mdl.modes if m.name == lo2.mode)\r\n    C1 = lo1_synth.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n    C2 = lo2_synth.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n\r\n    # Compute desired IF2 center to align windows\r\n    if2_des_c = abs(inj1 * lo1.f_out_hz - if1.center_hz)\r\n\r\n    # Wide IF2 (e.g., 700 MHz)\r\n    if2_wide = IF2Parametric(center_hz=if2_des_c, bw_hz=0.7e9,\r\n                             passband_il_db=1.0, stop_floor_db=-80.0, rolloff_db_per_dec=40.0)\r\n    # Tight IF2 (e.g., 500 MHz)\r\n    if2_tight = IF2Parametric(center_hz=if2_des_c, bw_hz=0.5e9,\r\n                              passband_il_db=1.0, stop_floor_db=-80.0, rolloff_db_per_dec=40.0)\r\n\r\n    # Sanity: both contain the desired band\r\n    assert if2_wide.contains_desired(if2_des_c, if1.bw_hz)\r\n    assert if2_tight.contains_desired(if2_des_c, if1.bw_hz)\r\n\r\n    # Evaluate both\r\n    summ_wide = enumerate_spurs(\r\n        if1, lo1, lo2, if2_wide, rf_filter_flat_pass, mixer1_model, mixer2_model, tiny_config,\r\n        inj1_sign=inj1, s2_sign=s2, carriers_lo1=C1, carriers_lo2=C2\r\n    )\r\n    summ_tight = enumerate_spurs(\r\n        if1, lo1, lo2, if2_tight, rf_filter_flat_pass, mixer1_model, mixer2_model, tiny_config,\r\n        inj1_sign=inj1, s2_sign=s2, carriers_lo1=C1, carriers_lo2=C2\r\n    )\r\n\r\n    # Tighter IF2 should not degrade worst-case margin and typically improves it\r\n    assert summ_tight.worst_margin_db >= summ_wide.worst_margin_db - 1e-6\r\n\r\n\r\ndef test_inband_vs_oob_mask_selection_changes_worst_margin(\r\n    tiny_config, simple_tile_if1, rf_filter_flat_pass, if2_window, mixer1_model, mixer2_model,\r\n    lo1_synth, lo2_synth\r\n):\r\n    \"\"\"\r\n    Make the OOB mask much stricter than in-band so that the worst-case margin is driven by OOB,\r\n    then relax OOB and verify the worst-case margin increases accordingly.\r\n    \"\"\"\r\n    cfg = tiny_config.model_copy()\r\n\r\n    # Force OOB much stricter at first\r\n    cfg.masks.inband.default_dbc = -20.0   # permissive in-band\r\n    cfg.masks.outofband.default_dbc = -90.0  # very strict OOB\r\n    cfg.constraints.guard_margin_db = 0.0\r\n\r\n    inj1, s2 = +1, +1\r\n    if1 = simple_tile_if1\r\n    if2 = if2_window\r\n\r\n    lo1 = _pick_snap(lo1_synth, 6.20e9, \"lo1\",\r\n                     mixer1_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mixer1_model.mdl.required_lo_drive_dbm[\"max\"])\r\n    lo2 = _pick_snap(lo2_synth, 24.60e9, \"lo2\",\r\n                     mixer2_model.mdl.required_lo_drive_dbm[\"min\"],\r\n                     mixer2_model.mdl.required_lo_drive_dbm[\"max\"])\r\n\r\n    mode1 = next(m for m in lo1_synth.mdl.modes if m.name == lo1.mode)\r\n    mode2 = next(m for m in lo2_synth.mdl.modes if m.name == lo2.mode)\r\n    C1 = lo1_synth.equivalent_carriers(lo1.f_out_hz, mode1, lo1.divider, pfd_hz=lo1.pfd_hz)\r\n    C2 = lo2_synth.equivalent_carriers(lo2.f_out_hz, mode2, lo2.divider, pfd_hz=lo2.pfd_hz)\r\n\r\n    # Strict-OOB pass\r\n    s_strict = enumerate_spurs(\r\n        if1, lo1, lo2, if2, rf_filter_flat_pass, mixer1_model, mixer2_model, cfg,\r\n        inj1_sign=inj1, s2_sign=s2, carriers_lo1=C1, carriers_lo2=C2\r\n    )\r\n\r\n    # Now relax the OOB mask notably\r\n    cfg_relaxed = cfg.model_copy()\r\n    cfg_relaxed.masks.outofband.default_dbc = -40.0\r\n\r\n    s_relaxed = enumerate_spurs(\r\n        if1, lo1, lo2, if2, rf_filter_flat_pass, mixer1_model, mixer2_model, cfg_relaxed,\r\n        inj1_sign=inj1, s2_sign=s2, carriers_lo1=C1, carriers_lo2=C2\r\n    )\r\n\r\n    # Worst-case margin should improve (become less negative / larger) when OOB mask is relaxed\r\n    assert s_relaxed.worst_margin_db >= s_strict.worst_margin_db - 1e-6\r\n\r\n\r\n# --------------------------\r\n# Small, direct checks that support enumerate_spurs behavior\r\n# --------------------------\r\n\r\ndef test_rbw_width_and_fixed_bin_coalescing_behave_as_expected():\r\n    \"\"\"Sanity-check rbw width formula and coalescing power sum behavior.\"\"\"\r\n    class RBW:\r\n        rbw_hz = 10e3\r\n        rbw_frac_of_bw = 0.0025\r\n        rbw_ppm_of_freq = 0.0\r\n\r\n    bw = 400e6\r\n    f0 = 29.25e9\r\n    w = rbw_width(RBW, bw, f0)\r\n    # With the defaults from conftest, the fractional term dominates: 0.0025 * 400 MHz = 1 MHz\r\n    assert w == pytest.approx(1e6, rel=0, abs=1e-6)\r\n\r\n    # Two tones inside one fixed bin should power-sum to ~ +3 dB\r\n    freqs = np.array([10.000e9 + 0.10e6, 10.000e9 + 0.50e6])  # both inside the same 1 MHz bin\r\n    levs_db = np.array([-65.0, -65.0])\r\n    bf, bL = coalesce_bins(freqs, levs_db, bin_width_hz=1e6)\r\n    assert len(bf) == 1\r\n    # 2 equal powers combine to +3.0103 dB\r\n    assert bL[0] == pytest.approx(-65.0 + 10*np.log10(2.0), abs=1e-3)\r\n\r\n\r\ndef test_desired_paths_math_matches_sign_conventions(simple_tile_if1):\r\n    \"\"\"Quick functional check of desired_paths() sign conventions.\"\"\"\r\n    inj1, s2 = +1, +1\r\n    lo1 = 6.20e9\r\n    lo2 = 24.60e9\r\n    if2, rf = desired_paths(simple_tile_if1, lo1, lo2, inj1, s2)\r\n    assert if2.center_hz == pytest.approx(abs(inj1*lo1 - simple_tile_if1.center_hz))\r\n    assert rf.center_hz == pytest.approx(abs(s2*lo2 + if2.center_hz))\r\n    # BW is preserved across stages\r\n    assert if2.bw_hz == pytest.approx(simple_tile_if1.bw_hz)\r\n    assert rf.bw_hz == pytest.approx(simple_tile_if1.bw_hz)\r\n",
          "encoding": "utf-8",
          "encoding_error": false
        }
      ]
    },
    {
      "type": "file",
      "name": ".gitignore",
      "path": ".gitignore",
      "size": 109,
      "content_truncated": false,
      "contents": "# Python-generated files\n__pycache__/\n*.py[oc]\nbuild/\ndist/\nwheels/\n*.egg-info\n\n# Virtual environments\n.venv\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": ".python-version",
      "path": ".python-version",
      "size": 5,
      "content_truncated": false,
      "contents": "3.13\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "pyproject.toml",
      "path": "pyproject.toml",
      "size": 483,
      "content_truncated": false,
      "contents": "[project]\nname = \"bucso\"\nversion = \"0.1.0\"\ndescription = \"Dual-conversion BUC spur optimization tool\"\nreadme = \"README.md\"\nrequires-python = \">=3.13\"\n\ndependencies = [\n  \"pydantic>=2.9\",\n  \"pydantic-settings>=2.5\",\n  \"pyyaml>=6.0.2\",\n  \"typer>=0.12\",\n  \"rich>=13.8\",\n  \"numpy>=2.1\",\n  \"pandas>=2.2\",\n  \"scipy>=1.14\",\n  \"jinja2>=3.1\",\n  \"pytest>=8.4.2\",\n]\n\n[project.scripts]\nbucso = \"bucso.cli:app\"\n\n[tool.pytest.ini_options]\naddopts = \"-q\"\npythonpath = [\"src\"]\ntestpaths = [\"tests\"]\n",
      "encoding": "utf-8",
      "encoding_error": false
    },
    {
      "type": "file",
      "name": "README.md",
      "path": "README.md",
      "size": 327,
      "content_truncated": false,
      "contents": "# bucso — Dual-Conversion BUC Spur Optimization\r\n\r\nPython 3.13 + uv.\r\n\r\n## Quick start\r\n\r\n```bash\r\nuv venv && source .venv/bin/activate\r\nuv pip install -e .\r\nbucso init-stubs examples/\r\nbucso validate examples/config.yaml\r\nbucso optimize examples/config.yaml --out out/\r\nbucso report out/policy.yaml --html out/summary.html\r\n",
      "encoding": "utf-8",
      "encoding_error": false
    }
  ]
}